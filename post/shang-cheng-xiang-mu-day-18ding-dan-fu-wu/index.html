<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>商城项目 day 18：订单服务 | Gridea</title>
<link rel="shortcut icon" href="https://dxone1.github.io//favicon.ico?v=1642163798088">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://dxone1.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="商城项目 day 18：订单服务 | Gridea - Atom Feed" href="https://dxone1.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="服务说明
包含4个服务页面：

订单详情页
等待支付页
结算页面
收银页面

订单支付会跳转到结算页面，然后收银。
成功则会有订单详情页面显示，否则会出现等待支付页供重新付款。
订单服务
首先引入SpringSession方便共享登录信息。..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://dxone1.github.io/">
  <img class="avatar" src="https://dxone1.github.io//images/avatar.png?v=1642163798088" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="/mall" class="menu">
          商城项目
        </a>
      
    
      
        <a href="/lwjgl" class="menu">
          LwJGL学习
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              商城项目 day 18：订单服务
            </h2>
            <div class="post-info">
              <span>
                2021-11-28
              </span>
              <span>
                37 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="服务说明">服务说明</h2>
<p>包含4个服务页面：</p>
<ul>
<li>订单详情页</li>
<li>等待支付页</li>
<li>结算页面</li>
<li>收银页面</li>
</ul>
<p>订单支付会跳转到结算页面，然后收银。<br>
成功则会有订单详情页面显示，否则会出现等待支付页供重新付款。</p>
<h2 id="订单服务">订单服务</h2>
<p>首先引入SpringSession方便共享登录信息。准备和打通各个页面的资源。然后进入后端程序的编写和调试。</p>
<h3 id="业务说明">业务说明</h3>
<p>电商系统涉及到 3 流， 分别时信息流， 资金流， 物流， 而订单系统作为中枢将三者有机的集合起来。订单模块是电商系统的枢纽， 在订单这个环节上需求获取多个模块的数据和信息， 同时对这些信息进行加工处理后流向下个环节， 这一系列就构成了订单的信息流通。<br>
<img src="https://dxone1.github.io//post-images/1638088841808.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1638089031556.png" alt="" loading="lazy"><br>
注意，整个订单服务必须已经是登陆状态才可进入，所以可以考虑使用拦截器</p>
<pre><code class="language-java">@Component
public class LoginUserInterceptor implements HandlerInterceptor {

    public static ThreadLocal&lt;MemberRespVo&gt; loginUser = new ThreadLocal&lt;&gt;();

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        MemberRespVo attribute = (MemberRespVo) request.getSession().getAttribute(AuthServerConstant.LOGIN_USER);
        if(attribute != null) {
            loginUser.set(attribute);
            return true;
        } else {
            request.getSession().setAttribute(&quot;msg&quot;, &quot;请先登录&quot;);
            response.sendRedirect(&quot;http://auth.mall.com/login.html&quot;);
            return false;
        }
    }
}
</code></pre>
<h3 id="订单确认结算页面">订单确认：结算页面</h3>
<p>从购物车点击去结算，因为有之前写好的拦截器存在，只有登录之后才可以前往结算页面。首先需要抽取出一个模型封装所有的结算页面信息。</p>
<pre><code class="language-java">@Data
public class OrderConfirmVo {
    // 用户收货地址列表
    List&lt;MemberAddressVo&gt; address;
    // 送货清单：购物项
    List&lt;OrderItemVo&gt; items;
    // 发票...
    // 积分信息
    private Integer integration;
    // 订单总额
    BigDecimal total;
    // 应付总价格
    BigDecimal payPrice;
}
</code></pre>
<ol>
<li>确认页的数据获取</li>
</ol>
<pre><code class="language-java">@Override
public OrderConfirmVo confirmOrder() {
    OrderConfirmVo confirmVo = new OrderConfirmVo();
    //1.远程查询用户的所有收货列表
    MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get();
    List&lt;MemberAddressVo&gt; address = memberFeignService.getAddress(memberRespVo.getId());
    confirmVo.setAddress(address);

    //2.远程查询购物车所有选中的购物项
    List&lt;OrderItemVo&gt; items = cartFeignService.getCurrentUserCartItems();
    confirmVo.setItems(items);

    //3.查询用户积分
    Integer integration = memberRespVo.getIntegration();
    confirmVo.setIntegration(integration);

    //其他数据自动计算


    return confirmVo;
}
</code></pre>
<ol start="2">
<li>问题<br>
在远程查询购物车购物项时的方法为：</li>
</ol>
<pre><code class="language-java">@Override
public List&lt;CartItem&gt; getUserCartItems() {
    UserInfoTo userInfoTo = CartInterceptor.threadLocal.get();
    if (userInfoTo.getUserId() == null) {
        return null;
    } else {
        String cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserId();
        List&lt;CartItem&gt; collect = getCartItems(cartKey).stream()
                .filter(item -&gt; item.getCheck())
                .map(item -&gt; {
                    // 在结算时必须获取最新价格
                    BigDecimal price = productFeignService.getPrice(item.getSkuId());
                    item.setPrice(price);
                    return item;
                })
                .collect(Collectors.toList());
        return collect;
    }
}
</code></pre>
<p><strong>通过feign远程调用会无法获取到用户session，这是因为Feign调用并不会持有名为MALLSESSION的cookie。</strong><br>
<img src="https://dxone1.github.io//post-images/1638104997936.png" alt="" loading="lazy"><br>
解决：在发送Feign请求时加入拦截器，添加丢失的cookie。</p>
<pre><code class="language-java">@Configuration
public class FeignConfig {

    @Bean
    public RequestInterceptor requestInterceptor() {
        return new RequestInterceptor() {
            @Override
            public void apply(RequestTemplate requestTemplate) {
                // 获得旧请求的数据
                ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
                HttpServletRequest request = attributes.getRequest();
                // 同步请求头信息
                String cookie = request.getHeader(&quot;Cookie&quot;);
                requestTemplate.header(&quot;Cookie&quot;, cookie);
            }
        };
    }
}
</code></pre>
<p><strong>在异步模式下，Feign会导致上下文丢失</strong>：<br>
异步模式下不在同一个线程，无法共享threadLocal实现的请求上下文，这样拦截器就无法获得请求。<br>
<img src="https://dxone1.github.io//post-images/1638107111126.png" alt="" loading="lazy"><br>
解决：异步下每开一个线程都设置上上下文信息。</p>
<pre><code class="language-java">@Override
public OrderConfirmVo confirmOrder() throws ExecutionException, InterruptedException {
    OrderConfirmVo confirmVo = new OrderConfirmVo();
    MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get();
    RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();

    CompletableFuture&lt;Void&gt; getAddressFuture = CompletableFuture.runAsync(() -&gt; {
        //1.远程查询用户的所有收货列表
        RequestContextHolder.setRequestAttributes(requestAttributes);
        List&lt;MemberAddressVo&gt; address = memberFeignService.getAddress(memberRespVo.getId());
        confirmVo.setAddress(address);
    }, executor);

    CompletableFuture&lt;Void&gt; getCartFuture = CompletableFuture.runAsync(() -&gt; {
        //2.远程查询购物车所有选中的购物项
        RequestContextHolder.setRequestAttributes(requestAttributes);
        List&lt;OrderItemVo&gt; items = cartFeignService.getCurrentUserCartItems();
        confirmVo.setItems(items);
    }, executor);

    //3.查询用户积分
    Integer integration = memberRespVo.getIntegration();
    confirmVo.setIntegration(integration);

    //其他数据自动计算
    CompletableFuture.allOf(getAddressFuture, getCartFuture).get();

    return confirmVo;
}
</code></pre>
<ol start="3">
<li>总结</li>
</ol>
<ul>
<li>通过拦截器给Feign的远程调用添加新的请求头信息。</li>
<li>异步下因为线程切换，基于ThreadLoacl的RequestContexHolder无法获取。需要在异步任务启动时将信息共享给异步方法。</li>
</ul>
<ol start="4">
<li>页面和方法的细化<br>
在页面展示中需要显示多个收获地址的选择，货物库存情况和运费情况的实现，也需要后台处理好数据并提交显示。<br>
<strong>库存情况</strong></li>
</ol>
<pre><code class="language-java">CompletableFuture&lt;Void&gt; getCartFuture = CompletableFuture.runAsync(() -&gt; {
    //2.远程查询购物车所有选中的购物项
    RequestContextHolder.setRequestAttributes(requestAttributes);
    List&lt;OrderItemVo&gt; items = cartFeignService.getCurrentUserCartItems();
    confirmVo.setItems(items);
}, executor).thenRunAsync(() -&gt; {
    // 远程查询库存信息。
    List&lt;OrderItemVo&gt; items = confirmVo.getItems();
    List&lt;Long&gt; skuIds = items.stream().map(item -&gt; item.getSkuId()).collect(Collectors.toList());
    R hasStock = wmsFeignService.getSkuHasStock(skuIds);
    List&lt;SkuStockVo&gt; data = hasStock.getData(new TypeReference&lt;List&lt;SkuStockVo&gt;&gt;(){});
    if(data != null) {
        Map&lt;Long, Boolean&gt; map = data.stream().collect(Collectors.toMap(SkuStockVo::getSkuId, SkuStockVo::getHasStock));
        confirmVo.setStocks(map);
    }
}, executor);
</code></pre>
<p><strong>运费模拟</strong><br>
通过远程调用库存和用户服务获取地址，进行简单的运费计算。</p>
<h2 id="提交订单">提交订单</h2>
<p>提交时必须注意接口幂等性，即同一个订单的放重复提交。<br>
接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的， 不会因为多次点击而产生了副作用； 比如说支付场景， 用户购买了商品支付扣款成功， 但是返回结果的时候网络异常， 此时钱已经扣了， 用户再次点击按钮， 此时会进行第二次扣款， 返回结果成功， 用户查询余额返发现多扣钱了， 流水记录也变成了两条,这就没有保证接口的幂等性。</p>
<ul>
<li>令牌机制（如验证码），如果匹配就删除令牌，注意匹配和删除使用lua脚本保证原子性</li>
<li>锁：
<ul>
<li>数据库悲观锁</li>
<li>数据库乐观锁</li>
<li>业务层的分布式锁</li>
</ul>
</li>
<li>唯一约束：例如使得订单号唯一</li>
<li>redis的set防重</li>
<li>数据库的放重复表</li>
<li>全局请求唯一id：每一个请求设置一个唯一的id</li>
</ul>
<h3 id="订单提交">订单提交</h3>
<p>使用令牌机制提交订单并解决幂等问题。在令牌验证通过之后要创建订单项，获取相关信息并跳转到结算页面。<br>
这部分具体要做以下的细节问题：</p>
<ul>
<li>原子的验证令牌并删除</li>
<li>创建订单</li>
<li>订单验价：当前购物车的价格和页面价格比较</li>
<li>保存订单信息</li>
<li>库存锁定，如果失败则需要回滚</li>
</ul>
<pre><code class="language-java">@Transactional
@Override
public SubmitOrderResponseVo submitOrder(OrderSubmitVo vo) {
    SubmitOrderResponseVo response = new SubmitOrderResponseVo();
    // 获取传来的令牌
    MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get();
    submitVoThreadLocal.set(vo);
    response.setCode(0);
    // lua脚本 0:失败 1:成功
    String script = &quot;if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end&quot;;
    String orderToken = vo.getOrderToken();

    Long result = redisTemplate.execute(new DefaultRedisScript&lt;Long&gt;(script, Long.class),
            Arrays.asList(OrderConstant.USER_ORDER_TOKEN_PREFIX + memberRespVo.getId()),
            orderToken);
    if (result == 0L) {
        //令牌验证失败
        response.setCode(1);
        return response;
    } else {
        //1.创建订单
        OrderCreateTo order = createOrder();
        //2.验价
        BigDecimal payAmount = order.getOrder().getPayAmount();
        BigDecimal payPrice = vo.getPayPrice();
        if(Math.abs(payAmount.subtract(payPrice).doubleValue()) &lt; 0.01) {
            //验价成功
            //保存订单信息
            saveOrder(order);
            //库存锁定，如果异常则需要回滚:调用库存服务
            WareSkuLockVo lockVo = new WareSkuLockVo();
            lockVo.setOrderSn(order.getOrder().getOrderSn());

            List&lt;OrderItemVo&gt; orderItemVos = order.getOrderItems().stream().map(item -&gt; {
                OrderItemVo itemVo = new OrderItemVo();
                itemVo.setSkuId(item.getSkuId());
                itemVo.setCount(item.getSkuQuantity());
                itemVo.setTitle(item.getSkuName());
                return itemVo;
            }).collect(Collectors.toList());
            lockVo.setLocks(orderItemVos);
            // 远程锁库存
            R r = wmsFeignService.orderLockStock(lockVo);
            if(r.getCode() == 0) {
                //锁成功
                response.setOrder(order.getOrder());
                return response;
            } else {
                String msg = (String) r.get(&quot;msg&quot;);
                throw new NoStockException(msg);
            }
        } else{
            //验价失败返回
            response.setCode(2);
            return response;
        }
    }
}
</code></pre>
<h2 id="分布式事务">分布式事务</h2>
<p>存储订单项和扣除库存必须是一个事务操作，而两个功能却在不同的服务中。必须使用分布式事务解决这个问题。在之前的代码中使用了异常机制，只要返回库存添加失败就抛出异常，于是调用链上的其他数据库操作也会回滚。但是存在假成功和假失败的问题。<br>
<img src="https://dxone1.github.io//post-images/1638359696008.png" alt="" loading="lazy"><br>
SpringBoot的@Transcational是使用代理对象实现的，只支持本地事务。同时，在本地同一个对象内事务方法互调会绕过代理对象，这会导致本地事务失效。解决方法如下：</p>
<ul>
<li>引入aop-starter，使用aspectj</li>
<li>开启aspectj动态代理<code>@EnableAspectJAutoProxy</code></li>
<li>使用AspectJ提供的动态代理</li>
</ul>
<h3 id="cap理论">CAP理论：</h3>
<p>在一致性（Consistency），可用性（Availability），分区容错性（Partition tolerance）中只能同时保证两个。其中，分区容错无法避免，所以C和A只能二选其一。<br>
满足CP的raft算法，通过领导选举和日志复制保证了CP特性。具体的过程如下：</p>
<ol>
<li>选举</li>
</ol>
<ul>
<li>起始状态均为follower，当自旋结束前没有其他的投票请求时，状态变更为candidata，同时发送投票请求</li>
<li>每轮接获投票请求时就投票，得到当前分布式系统一半以上票数的节点被推选为leader节点，通过心跳信息来维持连接</li>
<li>如果leader收到client的消息，就要进行日志复制</li>
</ul>
<ol start="2">
<li>日志复制</li>
</ol>
<ul>
<li>当leader受到更新请求，需要先在自己的日志上记录</li>
<li>leader将更新请求发送给所有其他节点，当收到大多数节点的回复后就执行更新，并返回更新命令给其他节点</li>
<li>一致性通过如下策略保证，如果某个区块发生了分区容错问题，那么该区块会自治的形成新的leader，但是如果这个区块没有达到总数的1/2那么就无法通过上一步完成最终的更新。当网络问题解决，因为该leader的轮数低，所以区块内所有节点的未提交更新全部回滚。这保证了强一致性。</li>
</ul>
<h3 id="base理论">BASE理论</h3>
<p>然而，互联网应用大部分更加注重高可用性（AP），思想是即使无法保证强一致性，也应采取合适的方法实现弱一致性。即最终一致性。<br>
BASE 是指</p>
<ul>
<li>基本可用（Basically Available）
<ul>
<li>基本可用是指分布式系统在出现故障的时候， 允许损失部分可用性（例如响应时间、功能上的可用性） ， 允许损失部分可用性。 需要注意的是， 基本可用绝不等价于系统不可用。</li>
<li>响应时间上的损失： 正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果， 但由于出现故障（比如系统部分机房发生断电或断网故障） ， 查询结果的响应时间增加到了 1~2 秒。</li>
<li>功能上的损失： 购物网站在购物高峰（如双十一） 时， 为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
</li>
<li>软状态（ Soft State）
<ul>
<li>软状态是指允许系统存在中间状态， 而该中间状态不会影响系统整体可用性。 分布式存储中一般一份数据会有多个副本， 允许不同副本同步的延时就是软状态的体现。 mysql replication 的异步复制也是一种体现。</li>
</ul>
</li>
<li>最终一致性（ Eventual Consistency）
<ul>
<li>最终一致性是指系统中的所有数据副本经过一定时间后， 最终能够达到一致的状态。 弱一致性和强一致性相反， 最终一致性是弱一致性的一种特殊情况。</li>
</ul>
</li>
</ul>
<p>遵循BASE理论则需要使用柔性事务，相比遵循强一致性ACID的刚性事务性能更强，并发性更好。</p>
<h3 id="seata">Seata</h3>
<p>Seata是实现分布式事务的一种框架，支持 AT、TCC、SAGA 和 XA 事务模式。<br>
<img src="https://dxone1.github.io//post-images/1638428912390.png" alt="" loading="lazy"></p>
<ul>
<li>TC (Transaction Coordinator) - 事务协调者<br>
维护全局和分支事务的状态，驱动全局事务提交或回滚。</li>
<li>TM (Transaction Manager) - 事务管理器<br>
定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li>
<li>RM (Resource Manager) - 资源管理器<br>
管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<ol>
<li>给每个服务的数据库建立undo_log表用于回滚</li>
<li>使用Seata服务器担任TC的功能</li>
<li>导入依赖和配置，修改seata中的registy.conf文件，指定注册中心和配置中心</li>
<li>开启全局事务：在业务上标注@GlobalTransactional</li>
<li>在容器中注入DataSourceProxy代理数据源</li>
<li>每个微服务复制一个file.conf和registry.conf,修改<code>vgroup_mapping.[mall-ware]-fescar-service-group = &quot;default&quot;</code><br>
库存锁定功能</li>
</ol>
<pre><code class="language-java">@Transactional
@Override
public Boolean orderLockStock(WareSkuLockVo vo) {
    //1.找到每个商品在哪个仓库有库存
    List&lt;OrderItemVo&gt; locks = vo.getLocks();
    List&lt;SkuWareHasStock&gt; collect = locks.stream().map(item -&gt; {
        SkuWareHasStock stock = new SkuWareHasStock();
        Long skuId = item.getSkuId();
        stock.setSkuId(skuId);
        List&lt;Long&gt; wareId = wareSkuDao.listWareIdHasSkuStock(skuId);
        stock.setWareId(wareId);
        stock.setNum(item.getCount());
        return stock;
    }).collect(Collectors.toList());

    //锁定库存
    for (SkuWareHasStock hasStock : collect) {
        Boolean skuStocked = false;
        Long skuId = hasStock.getSkuId();
        List&lt;Long&gt; wareIds = hasStock.getWareId();
        if (wareIds == null || wareIds.size() == 0) {
            throw new NoStockException(skuId);
        }
        for (Long wareId : wareIds) {
            //成功返回1
            Long count = wareSkuDao.lockSkuStock(skuId, wareId, hasStock.getNum());
            if(count == 1) {
                //成功
                skuStocked = true;
                break;
            } else {
                //当前仓库锁失败，试验下一个仓库
            }
        }
        if(skuStocked == false) {
            throw new NoStockException(skuId);
        }
    }
    return true;
}
</code></pre>
<h3 id="全局事务的最终方案选型">全局事务的最终方案选型</h3>
<p>默认使用AT模式，即使用的是二阶段提交的模型。区别是一阶段seata就已经提交更新，二阶段会进行回滚和反向补偿。这种模式适用于低并发的场景，如后台管理系统等。<br>
在高并发场景中，我们需要更高的吞吐量，所以采用基于通知的事务方法。最终决定使用可靠消息+最终一致性的柔性事务方案。实现： 业务处理服务在业务事务提交之前， 向实时消息服务请求发送消息， 实时消息服务只记录消息数据， 而不是真正的发送。 业务处理服务在业务事务提交之后， 向实时消息服务确认发送。 只有在得到确认发送指令后， 实时消息服务才会真正发送。<br>
最终的选型是使用消息队列完成分布式事务的功能</p>
<h2 id="订单服务的升级改造">订单服务的升级改造</h2>
<h3 id="rabbitmq延时队列">RabbitMQ延时队列</h3>
<p>RabbitMQ提供了演示队列机制，可以实现定时任务。<br>
<img src="https://dxone1.github.io//post-images/1638435703028.png" alt="" loading="lazy"><br>
<strong>为什么不使用轮询定时任务？</strong></p>
<ul>
<li>占用内存</li>
<li>每隔一段时间都需要读取数据库</li>
<li>有严重的时效性问题<br>
<img src="https://dxone1.github.io//post-images/1638435931664.png" alt="" loading="lazy"><br>
设定定时任务需要每隔一段时间查询数据库去探查订单是否失效关闭。而延时队列则经过特定长时间内容才可以被获取，解决了时效性问题。</li>
</ul>
<h4 id="ttl和dlx">TTL和DLX</h4>
<p>消息的TTL就是消息的存活时间。</p>
<ul>
<li>RabbitMQ可以对队列和消息分别设置TTL。</li>
<li>对队列设置就是队列没有消费者连着的保留时间，也可以对每一个单独的消息做单独的设置。超过了这个时间，我们认为这个消息就死了，称之为死信。</li>
<li>如果队列设置了，消息也设置了，那么会取小的。所以一个消息如果被路由到不同的队列中，这个消息死亡的时间有可能不一样（不同的队列设置）。这里单讲单个消息的TTL，因为它才是实现延迟任务的关键。可以通过设置消息的expiration字段或者xmessage-ttl属性来设置时间，两者是一样的效果。</li>
</ul>
<p>一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列，一个路由可以对应很多队列。</p>
<ul>
<li>一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。（basic.reject/ basic.nack）requeue=false</li>
<li>上面的消息的TTL到了，消息过期了。</li>
<li>队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上</li>
</ul>
<p>Dead Letter Exchange其实就是一种普通的exchange，和创建其他exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列<br>
<strong>通过死信路由会将超过TTL的的消息通过交换机路由到某个队列中，使用TTL + DLX即可实现延迟队列（订阅者订阅死信路由的队列即可）</strong><br>
<img src="https://dxone1.github.io//post-images/1638437013464.png" alt="" loading="lazy"></p>
<h3 id="实现订单自动关闭">实现订单自动关闭</h3>
<p>使用如下的MQ设计<br>
<img src="https://dxone1.github.io//post-images/1638437735015.png" alt="" loading="lazy"><br>
在SpringBoot中实现整合：</p>
<pre><code class="language-java">@Configuration
public class MyMQConfig {

    /**
     * 延时死信队列
     * @return
     */
    @Bean
    public Queue orderDelayQueue() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        // 设置死信路由的交换机,路由键和队列中的TTL
        arguments.put(&quot;x-dead-letter-exchange&quot;, &quot;order-event-exchange&quot;);
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;order.release.order&quot;);
        arguments.put(&quot;x-message-ttl&quot;, 60000);
        Queue queue = new Queue(&quot;order.delay.queue&quot;, true, false, false, arguments);
        return queue;
    }

    /**
     * 订单解除队列
     * @return
     */
    @Bean
    public Queue orderReleaseOrderQueue() {
        Queue queue = new Queue(&quot;order.release.order.queue&quot;, true, false, false);
        return queue;
    }

    /**
     * 交换机
     * @return
     */
    @Bean
    public Exchange orderEventExchange() {
        TopicExchange topicExchange = new TopicExchange(&quot;order-event-exchange&quot;, true, false);
        return topicExchange;
    }

    /**
     * 和延迟死信队列的绑定关系
     * @return
     */
    @Bean
    public Binding orderCreateOrderBinding() {
        Binding binding = new Binding(&quot;order.delay.queue&quot;,
                Binding.DestinationType.QUEUE,
                &quot;order-event-exchange&quot;,
                &quot;order.create.order&quot;, null);
        return binding;
    }

    /**
     * 和订单解除队列的绑定关系
     * @return
     */
    @Bean
    public Binding orderReleaseOrderBinding() {
        Binding binding = new Binding(&quot;order.release.order.queue&quot;,
                Binding.DestinationType.QUEUE,
                &quot;order-event-exchange&quot;,
                &quot;order.release.order&quot;, null);
        return binding;
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">// Listener
@RabbitListener(queues = &quot;order.release.order.queue&quot;)
public void listener(OrderEntity entity, Channel channel, Message message) throws IOException {
    System.out.println(&quot;收到过期订单消息,准备关闭订单&quot; + entity.getOrderSn());
    long deliveryTag = message.getMessageProperties().getDeliveryTag();
    channel.basicAck(deliveryTag, false);
}

// Sender
@ResponseBody
@GetMapping(&quot;/test/createOrder&quot;)
public String createOrderTest() {
    OrderEntity orderEntity = new OrderEntity();
    orderEntity.setOrderSn(UUID.randomUUID().toString());
    orderEntity.setModifyTime(new Date());
    //给MQ发送消息
    rabbitTemplate.convertAndSend(&quot;order-event-exchange&quot;, &quot;order.create.order&quot;, orderEntity);
    return &quot;Success&quot;;
}
</code></pre>
<h3 id="库存自动解锁">库存自动解锁</h3>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1638447108464.png" alt="" loading="lazy"></figure>
<ol>
<li>准备队列，交换机和绑定</li>
</ol>
<pre><code class="language-java">@Configuration
public class MyRabbitConfig {

    @Autowired
    RabbitTemplate rabbitTemplate;


    @Bean
    public MessageConverter messageConverter() {
        Jackson2JsonMessageConverter converter = new Jackson2JsonMessageConverter();
        return converter;
    }

    @PostConstruct
    public void initRabbitTemplate() {

        // Confirm Callback
        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
            /**
             *
             * @param correlationData 含有消息的唯一id
             * @param ack 消息是否成功
             * @param cause 失败的原因
             */
            @Override
            public void confirm(CorrelationData correlationData, boolean ack, String cause) {
                System.out.println(&quot;confirm...data: &quot; + correlationData + &quot; ==&gt; ack: &quot; + ack + &quot;==&gt; cause: &quot; + cause);
            }
        });

        // Return Callback
        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {
            /**
             * 消息投递失败给指定队列的回调
             * @param message 投递失败的详细信息
             * @param replyCode 回复码
             * @param replyText 回复文本
             * @param exchange 交换机
             * @param routingKey 路由键
             */
            @Override
            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
                System.out.println(&quot;Fail message:&quot; + message + &quot; ==&gt; replyCode:&quot; + replyCode + &quot; ==&gt; replyText:&quot; + replyText
                        + &quot; ==&gt; exchange:&quot; + exchange + &quot; ==&gt; routingKey:&quot; + routingKey);
            }
        });
    }

    /**
     * 库存交换机
     *
     * @return
     */
    @Bean
    public Exchange stockEventExchange() {
        TopicExchange topicExchange = new TopicExchange(&quot;stock-event-exchange&quot;, true, false);
        return topicExchange;
    }

    /**
     * 库存解锁队列
     *
     * @return
     */
    @Bean
    public Queue stockReleaseStockQueue() {
        return new Queue(&quot;stock.release.stock.queue&quot;, true, false, false);
    }

    /**
     * 延迟队列
     *
     * @return
     */
    @Bean
    public Queue stockDelayQueue() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        // 设置死信路由的交换机,路由键和队列中的TTL
        arguments.put(&quot;x-dead-letter-exchange&quot;, &quot;stock-event-exchange&quot;);
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;stock.release&quot;);
        arguments.put(&quot;x-message-ttl&quot;, 120000);
        return new Queue(&quot;stock.delay.queue&quot;, true, false, false, arguments);
    }

    /**
     * 交换机和库存解锁队列的绑定
     * @return
     */
    @Bean
    public Binding stockReleaseBinding() {
        return new Binding(&quot;stock.release.stock.queue&quot;,
                Binding.DestinationType.QUEUE,
                &quot;stock-event-exchange&quot;,
                &quot;stock.release.#&quot;,
                null);
    }

    /**
     * 交换机和延时队列的绑定
     * @return
     */
    @Bean
    public Binding stockLockedBinding() {
        return new Binding(&quot;stock.delay.queue&quot;,
                Binding.DestinationType.QUEUE,
                &quot;stock-event-exchange&quot;,
                &quot;stock.locked&quot;,
                null);
    }

    @RabbitListener(queues = &quot;stock.release.stock.queue&quot;)
    public void handle(Message message) {

    }
}
</code></pre>
<ol start="2">
<li>编写库存自动解锁功能<br>
库存解锁场景:<br>
1.下单成功,但是订单过期没有支付被系统自动取消或是用户手动取消<br>
2.下单成功,库存成功但是接下来流程的业务失败,之前锁定的库存也要</li>
</ol>
<p><strong>自动解锁库存业务的逻辑:</strong></p>
<ol>
<li>当锁定库存执行业务成功后,将会向wareEventExchange发送一个锁定库存的消息,路由到延时队列中。</li>
<li>延时到TTL之后将自动重新以release..的路由键路由，通过绑定关系会路由到release队列</li>
<li>提供一个解锁服务的Listener,绑定的是解锁队列。效果是在锁定库存后的指定时间，该Listener将会得到消息。执行解锁库存的逻辑。</li>
</ol>
<pre><code class="language-java">/**
     * 库存解锁场景:
     * 1.下单成功,但是订单过期没有支付被系统自动取消或是用户手动取消
    * 2.下单成功,库存成功但是接下来流程的业务失败,之前锁定的库存也要自动解锁
    *
    * @param vo
    * @return
    */
@Transactional
@Override
public Boolean orderLockStock(WareSkuLockVo vo) {
    /**
        * 保存库存工作单
        */
    WareOrderTaskEntity taskEntity = new WareOrderTaskEntity();
    taskEntity.setOrderSn(vo.getOrderSn());
    orderTaskService.save(taskEntity);

    //1.找到每个商品在哪个仓库有库存
    List&lt;OrderItemVo&gt; locks = vo.getLocks();
    List&lt;SkuWareHasStock&gt; collect = locks.stream().map(item -&gt; {
        SkuWareHasStock stock = new SkuWareHasStock();
        Long skuId = item.getSkuId();
        stock.setSkuId(skuId);
        List&lt;Long&gt; wareId = wareSkuDao.listWareIdHasSkuStock(skuId);
        stock.setWareId(wareId);
        stock.setNum(item.getCount());
        return stock;
    }).collect(Collectors.toList());

    //锁定库存
    for (SkuWareHasStock hasStock : collect) {
        Boolean skuStocked = false;
        Long skuId = hasStock.getSkuId();
        List&lt;Long&gt; wareIds = hasStock.getWareId();
        if (wareIds == null || wareIds.size() == 0) {
            throw new NoStockException(skuId);
        }
        /**
            * 每当一个商品锁定成功都会将当前锁定的工作单id,详情id发送给MQ
            * 当有一个失败,就会触发异常,本地事务回滚。发送的消息在数据库中就不会存在记录，如果订单服务触发解锁库存也会因找不到记录而不用解锁
            */
        for (Long wareId : wareIds) {
            //成功返回1
            Long count = wareSkuDao.lockSkuStock(skuId, wareId, hasStock.getNum());
            if (count == 1) {
                //成功
                skuStocked = true;
                /**
                    * 保存工作单详情
                    */
                WareOrderTaskDetailEntity entity = new WareOrderTaskDetailEntity(null, skuId, &quot;&quot;, hasStock.getNum(), taskEntity.getId(), wareId, 1);
                orderTaskDetailService.save(entity);
                //TODO 告知MQ库存锁定成功,发送格式是(工作单id,当前工作的详情id)
                StockLockedTo stockLockedTo = new StockLockedTo();
                stockLockedTo.setId(taskEntity.getId());
                StockDetailTo stockDetailTo = new StockDetailTo();
                BeanUtils.copyProperties(entity, stockDetailTo);
                stockLockedTo.setDetailTo(stockDetailTo);
                rabbitTemplate.convertAndSend(&quot;stock-event-exchange&quot;, &quot;stock.locked&quot;, stockLockedTo);
                break;
            } else {
                //当前仓库锁失败，试验下一个仓库
            }
        }
        if (skuStocked == false) {
            throw new NoStockException(skuId);
        }
    }
    return true;
}
</code></pre>
<p><strong>库存解锁逻辑</strong></p>
<ol>
<li>当收到消息时就是执行自动解锁库存的时机。按照以下逻辑处理业务：</li>
</ol>
<pre><code class="language-java">/**
  * 监听延时自动解锁队列
  * 1.如果发现此时没有订单，则必须解锁库存
  * 2.如果此时有订单，则要根据订单状态决定
  *      1.订单不存在或者订单状态为已取消，则解锁
  *      2.订单未取消，则不解锁
  */
</code></pre>
<ol start="2">
<li>具体的，使用手动Ack机制，这样只需要在特定场景中ack或reject即可</li>
</ol>
<pre><code class="language-java">@Service
@RabbitListener(queues = &quot;stock.release.stock.queue&quot;)
public class StockReleaseListener {

    @Autowired
    WareSkuService wareSkuService;
    /**
     * 监听延时自动解锁队列
     * 1.如果发现此时没有订单，则必须解锁库存
     * 2.如果此时有订单，则要根据订单状态决定
     *      1.订单不存在或者订单状态为已取消，则解锁
     *      2.订单未取消，则不解锁
     *
     * @param to
     * @param message
     */
    @RabbitHandler
    public void handleStockLockedRelease(StockLockedTo to, Message message, Channel channel) throws IOException {
        try {
            wareSkuService.unlockStock(to);
            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
        } catch (Exception e) {
            channel.basicReject(message.getMessageProperties().getDeliveryTag(), true);
        }
    }
}
/*******************************************************************/

@Override
public void unlockStock(StockLockedTo to) {
    System.out.println(&quot;收到解锁库存的消息&quot;);
    //查询数据库
    StockDetailTo detail = to.getDetailTo();
    Long detailId = detail.getId();
    WareOrderTaskDetailEntity byId = orderTaskDetailService.getById(detailId);
    if (byId != null) {
        //解锁
        //库存工作单的id
        Long id = to.getId();
        WareOrderTaskEntity taskEntity = orderTaskService.getById(id);
        //查询订单号
        String orderSn = taskEntity.getOrderSn();
        R r = orderFeignService.getOrderStatus(orderSn);
        if (r.getCode() == 0) {
            //订单数据返回成功
            OrderVo data = r.getData(new TypeReference&lt;OrderVo&gt;() {
            });
            // data == null时订单后续流程自己回滚了,也需要解锁库存
            if (data == null || data.getStatus() == 4) {
                // 订单已经取消状态,解锁库存
                unLockStock(detail.getSkuId(), detail.getWareId(), detail.getSkuNum(), detailId);
            } else {
                //无需解锁
            }
        } else {
            // 消息拒绝,重新放入队列
            throw new RuntimeException(&quot;远程服务失败&quot;);
        }
    } else {
        //无需解锁
    }
}

private void unLockStock(Long skuId, Long wareId, Integer num, Long taskDetailId) {
    this.wareSkuDao.unlockStock(skuId, wareId, num);
}
</code></pre>
<p>最后将会实现分布式的最终一致性：当自动解锁库存触发后，发现因为某种错误导致订单并没有生成或已被取消，则释放库存。注意具体实现中使用异常机制，如果触发解锁库存异常就会reject消息，否则ack。</p>
<h3 id="自动关单功能的整合">自动关单功能的整合</h3>
<p><img src="https://dxone1.github.io//post-images/1638524939325.png" alt="" loading="lazy"><br>
同样使用延时队列实现自动关单。</p>
<ol>
<li>在订单创建成功后，将订单创建成功的消息发送到对应的MQ中</li>
</ol>
<pre><code class="language-java">// 远程锁库存
......
    R r = wmsFeignService.orderLockStock(lockVo);
    if(r.getCode() == 0) {
        //锁成功
        response.setOrder(order.getOrder());
        //TODO 订单创建成功则发送消息给MQ
        rabbitTemplate.convertAndSend(&quot;order-event-exchange&quot;, &quot;order.create.order&quot;, order.getOrder());
        return response;
    } else {
        String msg = (String) r.get(&quot;msg&quot;);
        throw new NoStockException(msg);
    }
......
</code></pre>
<ol start="2">
<li>当监听到订单创建成功的消息已经是延时1分钟之后了。需要执行业务查看是否自动关单</li>
</ol>
<pre><code class="language-java">/**
    * 关闭订单
    * @param entity
    */
@Override
public void closeOrder(OrderEntity entity) {
    // 查询当前订单的状态
    OrderEntity orderEntity = getById(entity.getId());
    if(orderEntity.getStatus() == OrderStatusEnum.CREATE_NEW.getCode()) {
        //关单
        OrderEntity update = new OrderEntity();
        update.setId(entity.getId());
        update.setStatus(OrderStatusEnum.CANCLED.getCode());
        this.updateById(update);
    }
}
</code></pre>
<h3 id="解决消息延迟-丢失-堆压和重复">解决消息延迟、丢失、堆压和重复</h3>
<h4 id="1-消息延迟">1. 消息延迟</h4>
<p>我们设计关库存自动解锁慢于订单自动解锁，如果出现网络问题导致订单解锁延迟，就会出现库存无法解锁的情况<br>
<img src="https://dxone1.github.io//post-images/1638532052088.png" alt="" loading="lazy"><br>
<strong>解决：</strong><br>
当订单释放后要主动发出一个释放订单的消息，通过消息直接路由到库存解锁绑定的队列上，这样就能通知库存解锁。<br>
1）将订单事件交换机同库存解锁队列直接绑定</p>
<pre><code class="language-java">/**
    * 订单取消时通知库存解锁的绑定
    * @return
    */
@Bean
public Binding orderReleaseOtherBinding() {
    Binding binding = new Binding(&quot;stock.release.stock.queue&quot;,
            Binding.DestinationType.QUEUE,
            &quot;order-event-exchange&quot;,
            &quot;order.release.other.#&quot;, null);
    return binding;
}
</code></pre>
<p>2）关闭订单的同时发送库存解锁消息</p>
<pre><code class="language-java">/**
    * 关闭订单
    * @param entity
    */
@Override
public void closeOrder(OrderEntity entity) {
    // 查询当前订单的状态
    OrderEntity orderEntity = getById(entity.getId());
    if(orderEntity.getStatus() == OrderStatusEnum.CREATE_NEW.getCode()) {
        //关单
        OrderEntity update = new OrderEntity();
        update.setId(entity.getId());
        update.setStatus(OrderStatusEnum.CANCLED.getCode());
        this.updateById(update);
        //发送库存解锁信息
        OrderTo orderTo = new OrderTo();
        BeanUtils.copyProperties(orderEntity, orderTo);
        rabbitTemplate.convertAndSend(&quot;order-event-exchange&quot;, &quot;order.release.other&quot;, orderTo);
    }
}
</code></pre>
<p>3）编写接收订单关闭的库存解锁监听器和功能</p>
<pre><code class="language-java">@RabbitHandler
public void handleOrderCloseRelease(OrderTo orderTo, Message message, Channel channel) throws IOException {
    System.out.println(&quot;订单关闭,解锁库存...&quot;);
    try {
        wareSkuService.unlockStock(orderTo);
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    } catch (Exception e) {
        channel.basicReject(message.getMessageProperties().getDeliveryTag(), true);

    }
}
/*******************************************************/

/**
    * 订单服务通知的库存解锁
    * @param orderTo
    */
@Transactional
@Override
public void unlockStock(OrderTo orderTo) {
    String orderSn = orderTo.getOrderSn();
    //查询最新库存解锁状态
    WareOrderTaskEntity task = orderTaskService.getOrderTaskByOrderSn(orderSn);
    Long taskId = task.getId();
    //通过工作单找到但内所有没有解锁的订单项解锁
    List&lt;WareOrderTaskDetailEntity&gt; entities = orderTaskDetailService.list(new QueryWrapper&lt;WareOrderTaskDetailEntity&gt;()
            .eq(&quot;task_id&quot;, taskId)
            .eq(&quot;lock_status&quot;, 1));
    for (WareOrderTaskDetailEntity entity : entities) {
        unLockStock(entity.getSkuId(), entity.getWareId(), entity.getSkuNum(), entity.getId());
    }
}
</code></pre>
<h4 id="2-可靠消息">2. 可靠消息</h4>
<p>1、消息丢失</p>
<ul>
<li>消息发送出去，由于网络问题没有抵达服务器<br>
• 做好容错方法（try-catch），发送消息可能会网络失败，失败后要有重试机制，可记录到数据库，采用定期扫描重发的方式<br>
• 做好日志记录，每个消息状态是否都被服务器收到都应该记录<br>
• 做好定期重发，如果消息没有发送成功，定期去数据库扫描未成功的消息进行重发</li>
<li>消息抵达Broker，Broker要将消息写入磁盘（持久化）才算成功。此时Broker尚未持久化完成，宕机。<br>
• publisher也必须加入确认回调机制，确认成功的消息，修改数据库消息状态。</li>
<li>自动ACK的状态下。消费者收到消息，但没来得及消费然后宕机<br>
• 一定开启手动ACK，消费成功才移除，失败或者没来得及处理就noAck并重新入队</li>
</ul>
<p>2、消息重复</p>
<ul>
<li>消息消费失败，由于重试机制，自动又将消息发送出去</li>
<li>消息消费成功，事务已经提交，ack时，机器宕机。导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者<br>
• 消费者的业务消费接口应该设计为幂等性的。比如扣库存有工作单的状态标志（★）<br>
• 使用防重表（redis/mysql），发送消息每一个都有业务的唯一标识，处理过就不用处理<br>
• rabbitMQ的每一个消息都有redelivered字段，可以获取是否是被重新投递过来的，而不是第一次投递过来的</li>
</ul>
<p>3、消息积压</p>
<ul>
<li>消费者宕机积压</li>
<li>消费者消费能力不足积压</li>
<li>发送者发送流量太大<br>
• 上线更多的消费者，进行正常消费<br>
• 上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理</li>
</ul>
<h2 id="支付业务">支付业务</h2>
<p>使用支付宝沙箱环境进行测试。支付服务的验证和加密过程：<br>
<img src="https://dxone1.github.io//post-images/1638538080670.png" alt="" loading="lazy"></p>
<ol>
<li>内网穿透<br>
支付宝的回调必须使用可以通过外网访问的机器，这就需要内网穿透。<br>
<img src="https://dxone1.github.io//post-images/1638539750548.png" alt="" loading="lazy"></li>
<li>依赖Alipay SDK</li>
</ol>
<pre><code class="language-xml">&lt;!--支付宝SDK--&gt;
&lt;!-- https://mvnrepository.com/artifact/com.alipay.sdk/alipay-sdk-java --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt;
    &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt;
    &lt;version&gt;4.9.28.ALL&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="3">
<li>从demo中抽取工具类</li>
</ol>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;alipay&quot;)
@Component
@Data
public class AlipayTemplate {

    //在支付宝创建的应用的id
    private   String app_id = &quot;2021***&quot;;

    // 商户私钥，您的PKCS8格式RSA2私钥
    private  String merchant_private_key = &quot;&quot;;
    // 支付宝公钥,查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥。
    private  String alipay_public_key = &quot;&quot;;
    // 服务器[异步通知]页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
    // 支付宝会悄悄的给我们发送一个请求，告诉我们支付成功的信息
    private  String notify_url = &quot;http://x8jy34ij62.51xd.pub/alipay.trade.page.pay-JAVA-UTF-8/notify_url.jsp&quot;;

    // 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
    //同步通知，支付成功，一般跳转到成功页
    private  String return_url = &quot;http://x8jy34ij62.51xd.pub/alipay.trade.page.pay-JAVA-UTF-8/return_url.jsp&quot;;

    // 签名方式
    private  String sign_type = &quot;RSA2&quot;;

    // 字符编码格式
    private  String charset = &quot;utf-8&quot;;

    // 支付宝网关； https://openapi.alipaydev.com/gateway.do
    private  String gatewayUrl = &quot;https://openapi.alipaydev.com/gateway.do&quot;;

    public  String pay(PayVo vo) throws AlipayApiException {

        //AlipayClient alipayClient = new DefaultAlipayClient(AlipayTemplate.gatewayUrl, AlipayTemplate.app_id, AlipayTemplate.merchant_private_key, &quot;json&quot;, AlipayTemplate.charset, AlipayTemplate.alipay_public_key, AlipayTemplate.sign_type);
        //1、根据支付宝的配置生成一个支付客户端
        AlipayClient alipayClient = new DefaultAlipayClient(gatewayUrl,
                app_id, merchant_private_key, &quot;json&quot;,
                charset, alipay_public_key, sign_type);

        //2、创建一个支付请求 //设置请求参数
        AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();
        alipayRequest.setReturnUrl(return_url);
        alipayRequest.setNotifyUrl(notify_url);

        //商户订单号，商户网站订单系统中唯一订单号，必填
        String out_trade_no = vo.getOut_trade_no();
        //付款金额，必填
        String total_amount = vo.getTotal_amount();
        //订单名称，必填
        String subject = vo.getSubject();
        //商品描述，可空
        String body = vo.getBody();

        alipayRequest.setBizContent(&quot;{\&quot;out_trade_no\&quot;:\&quot;&quot;+ out_trade_no +&quot;\&quot;,&quot;
                + &quot;\&quot;total_amount\&quot;:\&quot;&quot;+ total_amount +&quot;\&quot;,&quot;
                + &quot;\&quot;subject\&quot;:\&quot;&quot;+ subject +&quot;\&quot;,&quot;
                + &quot;\&quot;body\&quot;:\&quot;&quot;+ body +&quot;\&quot;,&quot;
                + &quot;\&quot;product_code\&quot;:\&quot;FAST_INSTANT_TRADE_PAY\&quot;}&quot;);

        String result = alipayClient.pageExecute(alipayRequest).getBody();

        //会收到支付宝的响应，响应的是一个页面，只要浏览器显示这个页面，就会自动来到支付宝的收银台页面
        System.out.println(&quot;支付宝的响应：&quot;+result);

        return result;

    }
}
</code></pre>
<ol start="3">
<li>编写调用</li>
</ol>
<pre><code class="language-java">/**
    * 取得当前订单的支付信息
    * @param orderSn
    * @return
    */
@Override
public PayVo getOrderPay(String orderSn) {
    PayVo payVo = new PayVo();
    OrderEntity orderEntity = getOrderByOrderSn(orderSn);

    BigDecimal totalAmount = orderEntity.getPayAmount().setScale(2, BigDecimal.ROUND_UP);
    payVo.setTotal_amount(totalAmount.toString());//金额
    payVo.setOut_trade_no(orderEntity.getOrderSn());//订单号

    List&lt;OrderItemEntity&gt; order_sn = orderItemService.list(new QueryWrapper&lt;OrderItemEntity&gt;().eq(&quot;order_sn&quot;, orderSn));
    payVo.setSubject(order_sn.get(0).getSkuName());//订单信息,用第一个商品数据的标题作为主题
    payVo.setBody(order_sn.get(0).getSkuAttrsVals());//订单备注
    return payVo;
}
</code></pre>
<ol start="4">
<li>支付回调<br>
将支付成功后的回调设计为该用户的订单列表页面。需要查询当前用户的所有订单</li>
</ol>
<pre><code class="language-java">@Override
public PageUtils queryPageWithItem(Map&lt;String, Object&gt; params) {
    MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get();
    IPage&lt;OrderEntity&gt; page = this.page(
            new Query&lt;OrderEntity&gt;().getPage(params),
            new QueryWrapper&lt;OrderEntity&gt;().eq(&quot;member_id&quot;, memberRespVo.getId())
    );
    return new PageUtils(page);
}
</code></pre>
<ol start="5">
<li>在页面中显示，最终的结果页面如图所示：<br>
<img src="https://dxone1.github.io//post-images/1638612400084.png" alt="" loading="lazy"></li>
<li>异步通知<br>
只要支付成功，就会进行异步通知。其异步结果通知会以POST请求方式将所有支付结果发送给配置的异步回调地址。通过最大努力通知方案实现分布式事务的最终一致。<br>
<img src="https://dxone1.github.io//post-images/1638617579204.png" alt="" loading="lazy"><br>
异步通知的回调要使用内网穿透的外部地址，有这样的网络拓扑。可以看到在通过内网穿透的服务时会丢失请求Host导致无法匹配路由。<br>
<img src="https://dxone1.github.io//post-images/1638618188654.png" alt="" loading="lazy"><br>
<strong>解决</strong><br>
在Nginx直接配置精确的地址映射。<br>
<img src="https://dxone1.github.io//post-images/1638619238590.png" alt="" loading="lazy"><br>
在拦截器中解除这个访问被要求登录。</li>
<li>支付成功回调<br>
先将支付宝回调的数据封装起来：</li>
</ol>
<pre><code class="language-java">@ToString
@Data
public class PayAsyncVo {

    private String gmt_create;
    private String charset;
    private String gmt_payment;
    private String notify_time;
    private String subject;
    private String sign;
    private String buyer_id;//支付者的id
    private String body;//订单的信息
    private String invoice_amount;//支付金额
    private String version;
    private String notify_id;//通知id
    private String fund_bill_list;
    private String notify_type;//通知类型； trade_status_sync
    private String out_trade_no;//订单号
    private String total_amount;//支付的总额
    private String trade_status;//交易状态  TRADE_SUCCESS
    private String trade_no;//流水号
    private String auth_app_id;//
    private String receipt_amount;//商家收到的款
    private String point_amount;//
    private String app_id;//应用id
    private String buyer_pay_amount;//最终支付的金额
    private String sign_type;//签名类型
    private String seller_id;//商家的id

}
</code></pre>
<p><strong>处理：</strong><br>
既要修改订单状态和库存状态，也要在记录下支付流水记录。使用自动收单功能，防止长久不支付连库存都解锁了。</p>
<pre><code class="language-java">/**
    * 处理支付宝异步返回结果
    * @param vo
    * @return
    */
@Override
public String handlePayResult(PayAsyncVo vo) {
    //1.保存交易流水
    PaymentInfoEntity infoEntity = new PaymentInfoEntity();
    infoEntity.setAlipayTradeNo(vo.getTrade_no());//交易单号
    infoEntity.setOrderSn(vo.getOut_trade_no());//订单号
    infoEntity.setPaymentStatus(vo.getTrade_status());//支付状态
    infoEntity.setCallbackTime(vo.getNotify_time());//回调事件
    paymentInfoService.save(infoEntity);
    //2.修改订单状态
    if (vo.getTrade_status().equals(&quot;TRADE_SUCCESS&quot;) || vo.getTrade_status().equals(&quot;TRADE_FINISHED&quot;)) {
        //支付成功状态,修改订单为支付成功
        String outTradeNo = vo.getOut_trade_no();
        baseMapper.updateOrderStatus(outTradeNo, OrderStatusEnum.PAYED.getCode());
    }
    return &quot;success&quot;;
}
</code></pre>
<pre><code class="language-java">// 设置1分钟过期
alipayRequest.setBizContent(&quot;{\&quot;out_trade_no\&quot;:\&quot;&quot;+ out_trade_no +&quot;\&quot;,&quot;
                + &quot;\&quot;total_amount\&quot;:\&quot;&quot;+ total_amount +&quot;\&quot;,&quot;
                + &quot;\&quot;subject\&quot;:\&quot;&quot;+ subject +&quot;\&quot;,&quot;
                + &quot;\&quot;body\&quot;:\&quot;&quot;+ body +&quot;\&quot;,&quot;
                + &quot;\&quot;timeout_express\&quot;:\&quot;1m\&quot;,&quot;
                + &quot;\&quot;product_code\&quot;:\&quot;FAST_INSTANT_TRADE_PAY\&quot;}&quot;);
</code></pre>
<p>为了防止异步通知时延导致还未关单就支付成功，因为消息来晚了已经解锁库存，手动在解锁库存处调用收单。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%9C%8D%E5%8A%A1%E8%AF%B4%E6%98%8E">服务说明</a></li>
<li><a href="#%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1">订单服务</a>
<ul>
<li><a href="#%E4%B8%9A%E5%8A%A1%E8%AF%B4%E6%98%8E">业务说明</a></li>
<li><a href="#%E8%AE%A2%E5%8D%95%E7%A1%AE%E8%AE%A4%E7%BB%93%E7%AE%97%E9%A1%B5%E9%9D%A2">订单确认：结算页面</a></li>
</ul>
</li>
<li><a href="#%E6%8F%90%E4%BA%A4%E8%AE%A2%E5%8D%95">提交订单</a>
<ul>
<li><a href="#%E8%AE%A2%E5%8D%95%E6%8F%90%E4%BA%A4">订单提交</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">分布式事务</a>
<ul>
<li><a href="#cap%E7%90%86%E8%AE%BA">CAP理论：</a></li>
<li><a href="#base%E7%90%86%E8%AE%BA">BASE理论</a></li>
<li><a href="#seata">Seata</a></li>
<li><a href="#%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9C%80%E7%BB%88%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B">全局事务的最终方案选型</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8D%87%E7%BA%A7%E6%94%B9%E9%80%A0">订单服务的升级改造</a>
<ul>
<li><a href="#rabbitmq%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97">RabbitMQ延时队列</a>
<ul>
<li><a href="#ttl%E5%92%8Cdlx">TTL和DLX</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E8%AE%A2%E5%8D%95%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD">实现订单自动关闭</a></li>
<li><a href="#%E5%BA%93%E5%AD%98%E8%87%AA%E5%8A%A8%E8%A7%A3%E9%94%81">库存自动解锁</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E5%85%B3%E5%8D%95%E5%8A%9F%E8%83%BD%E7%9A%84%E6%95%B4%E5%90%88">自动关单功能的整合</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E5%BB%B6%E8%BF%9F-%E4%B8%A2%E5%A4%B1-%E5%A0%86%E5%8E%8B%E5%92%8C%E9%87%8D%E5%A4%8D">解决消息延迟、丢失、堆压和重复</a>
<ul>
<li><a href="#1-%E6%B6%88%E6%81%AF%E5%BB%B6%E8%BF%9F">1. 消息延迟</a></li>
<li><a href="#2-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF">2. 可靠消息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%94%AF%E4%BB%98%E4%B8%9A%E5%8A%A1">支付业务</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day17shi-yong-rabbitmq-shi-xian-fen-bu-shi-xiao-xi/">
              <h3 class="post-title">
                商城项目 day17：使用RabbitMQ实现分布式消息
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://dxone1.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
