<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dxone1.github.io/</id>
    <title>Gridea</title>
    <updated>2021-12-07T04:12:51.715Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dxone1.github.io/"/>
    <link rel="self" href="https://dxone1.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://dxone1.github.io/images/avatar.png</logo>
    <icon>https://dxone1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[商城项目 day19：瞬时高并发-秒杀业务]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day19shun-shi-gao-bing-fa-miao-sha-ye-wu/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day19shun-shi-gao-bing-fa-miao-sha-ye-wu/">
        </link>
        <updated>2021-12-04T13:13:05.000Z</updated>
        <content type="html"><![CDATA[<p>秒杀具有瞬间高并发的特点， 针对这一特点， 必须要做限流 + 异步 + 缓存（页面静态化）+ 独立部署。</p>
<h2 id="后台上架">后台上架</h2>
<p>在后台系统秒杀业务的上架页面，可以上架秒杀场次，并关联该场次的秒杀商品。需要修改相关后台程序完成对应场次商品的回显。</p>
<pre><code class="language-java">@Override
public PageUtils queryPage(Map&lt;String, Object&gt; params) {
    QueryWrapper&lt;SeckillSkuRelationEntity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    //获得场次id
    String promotionSessionId = (String) params.get(&quot;promotionSessionId&quot;);
    if(!StringUtils.isEmpty(promotionSessionId)) {
        queryWrapper.eq(&quot;promotion_session_id&quot;, promotionSessionId);
    }
    IPage&lt;SeckillSkuRelationEntity&gt; page = this.page(
            new Query&lt;SeckillSkuRelationEntity&gt;().getPage(params),
            queryWrapper
    );
    return new PageUtils(page);
}
</code></pre>
<p>后台系统功能如下：<br>
<img src="https://dxone1.github.io//post-images/1638625203321.png" alt="" loading="lazy"></p>
<h2 id="秒杀服务">秒杀服务</h2>
<p>使用独立部署的秒杀服务，限流方式包括：</p>
<ol>
<li>前端限流， 一些高并发的网站直接在前端页面开始限流， 例如： 小米的验证码设计</li>
<li>nginx 限流， 直接负载部分请求到错误的静态页面： 令牌算法 漏斗算法</li>
<li>网关限流， 限流的过滤器</li>
<li>代码中使用分布式信号量</li>
<li>rabbitmq 限流（能者多劳： chanel.basicQos(1)） ， 保证发挥所有服务器的性能。</li>
</ol>
<h3 id="定时上架秒杀商品">定时上架秒杀商品</h3>
<h4 id="定时任务">定时任务</h4>
<p>定时任务通过书写cron表达式编排，类似Linux中的cronTable。<br>
<img src="https://dxone1.github.io//post-images/1638626407056.png" alt="" loading="lazy"></p>
<pre><code class="language-java">特殊字符：
    ， ： 枚举；
    (cron=&quot;7,9,23 * * * * ?&quot;)： 任意时刻的 7,9， 23 秒启动这个任务；
    -： 范围：
    (cron=&quot;7-20 * * * * ?&quot;):任意时刻的 7-20 秒之间， 每秒启动一次
    *： 任意；
    指定位置的任意时刻都可以
    /： 步长；
    (cron=&quot;7/5 * * * * ?&quot;)： 第 7 秒启动， 每 5 秒一次；
    (cron=&quot;*/5 * * * * ?&quot;)： 任意秒启动， 每 5 秒一次；
    ？ ： （出现在日和周几的位置） ： 为了防止日和周冲突， 在周和日上如果要写通配符使
    用?
    (cron=&quot;* * * 1 * ?&quot;)： 每月的 1 号， 启动这个任务；
    L： （出现在日和周的位置） ”，
    last： 最后一个
    (cron=&quot;* * * ? * 3L&quot;)： 每月的最后一个周二
    W：
    Work Day： 工作日
    (cron=&quot;* * * W * ?&quot;)： 每个月的工作日触发
    (cron=&quot;* * * LW * ?&quot;)： 每个月的最后一个工作日触发
    #： 第几个
    (cron=&quot;* * * ? * 5#2&quot;)： 每个月的第 2 个周 4
</code></pre>
<p>注意：cron任务默认是阻塞的，如果业务时间过长就会导致定时任务执行和预期不符。可以采用异步编排方式执行或是定时任务线程池。设置spring.task.scheduling.pool.size</p>
<ol>
<li>使用线程池+异步编排</li>
<li>使用<code>spring.task.scheduling.pool.size</code>设置定时任务线程池大小</li>
<li>使用异步任务</li>
</ol>
<pre><code class="language-java">@Slf4j
@Component
@EnableAsync
@EnableScheduling
public class HelloSchedule {

    @Async
    @Scheduled(cron = &quot;* * * * * ?&quot;)
    public void hello() {
        log.info(&quot;hello&quot;);
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h4 id="定时商品上架">定时商品上架</h4>
<ol>
<li>先查出最近三天的所有秒杀活动场次</li>
</ol>
<pre><code class="language-java">@Override
public List&lt;SeckillSessionEntity&gt; getLatest3DaySession() {
    List&lt;SeckillSessionEntity&gt; list = list(new QueryWrapper&lt;SeckillSessionEntity&gt;().between(&quot;start_time&quot;, startTime(), endTime()));
    return list;
}

private String startTime() {
    LocalDate now = LocalDate.now();
    LocalTime min = LocalTime.MIN;
    LocalDateTime start = LocalDateTime.of(now, min);
    String format = start.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));
    return format;
}

private String endTime() {
    LocalDate now = LocalDate.now();
    LocalDate plus2 = now.plusDays(2);
    LocalTime max = LocalTime.MAX;
    LocalDateTime end = LocalDateTime.of(plus2, max);
    String format = end.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));
    return format;
}
</code></pre>
<ol start="2">
<li>查出这些场次的所有涉及商品并上架</li>
</ol>
<pre><code class="language-java">@Override
public List&lt;SeckillSessionEntity&gt; getLatest3DaySession() {
    //1.查出所有活动
    List&lt;SeckillSessionEntity&gt; list = list(new QueryWrapper&lt;SeckillSessionEntity&gt;().between(&quot;start_time&quot;, startTime(), endTime()));
    //2.封装活动关联的商品
    if(list != null &amp;&amp; list.size() &gt; 0) {
        List&lt;SeckillSessionEntity&gt; collect = list.stream().map(session -&gt; {
            Long id = session.getId();
            List&lt;SeckillSkuRelationEntity&gt; relationEntities = seckillSkuRelationService.list(new QueryWrapper&lt;SeckillSkuRelationEntity&gt;().eq(&quot;promotion_session_id&quot;, id));
            session.setRelationSkus(relationEntities);
            return session;
        }).collect(Collectors.toList());
        return collect;
    }
    return null;
}
</code></pre>
<ol start="3">
<li>上架<br>
<img src="https://dxone1.github.io//post-images/1638694282995.png" alt="" loading="lazy"><br>
需要在redis中存储两个信息：</li>
</ol>
<ul>
<li>秒杀场次时间为key，该场次的所有商品的skuId为值</li>
<li>Hash结构存储的商品id和商品信息</li>
</ul>
<p><strong>注意：这里面有两个重要的设计</strong></p>
<ul>
<li>在商品信息中携带一个随机码，防止事先取得而破坏公平</li>
<li>在其中设置一个分布式信号量，这样就能很快的在redis中进行库存判断，应对大并发场景（使用Redisson）</li>
</ul>
<pre><code class="language-java">@Override
public void uploadSeckillSkuLatest3Days() {
    //扫描需要参与秒杀的活动
    R session = couponFeignService.getLatest3DaySession();
    if(session.getCode() == 0) {
        //上架
        List&lt;SeckillSessionsWithSkus&gt; sessionData = session.getData(new TypeReference&lt;List&lt;SeckillSessionsWithSkus&gt;&gt;() {
        });
        //上架商品缓存到redis中
        //1.缓存活动信息
        saveSessionInfos(sessionData);
        //2.缓存活动关联商品信息
        saveSessionSkuInfos(sessionData);
    }
}

private void saveSessionInfos(List&lt;SeckillSessionsWithSkus&gt; sessions) {
    sessions.stream().forEach(session -&gt; {
        Long startTime = session.getStartTime().getTime();
        Long endTime = session.getEndTime().getTime();
        String key = SESSIONS_CACHE_PREFIX + startTime + &quot;_&quot; + endTime;
        List&lt;String&gt; collect = session.getRelationSkus().stream().map(item -&gt; item.getSkuId().toString()).collect(Collectors.toList());
        redisTemplate.opsForList().leftPushAll(key, collect);
    });
}

private void saveSessionSkuInfos(List&lt;SeckillSessionsWithSkus&gt; sessions) {
    sessions.stream().forEach(session -&gt; {
        //绑定Hash操作
        BoundHashOperations&lt;String, Object, Object&gt; ops = redisTemplate.boundHashOps(SKUKILL_CACHE_PREFIX);
        session.getRelationSkus().stream().forEach(seckillSkuVo -&gt; {
            SecKillSkuRedisTo redisTo = new SecKillSkuRedisTo();
            //sku基本数据
            R skuInfo = productFeignService.getSkuInfo(seckillSkuVo.getSkuId());
            if(skuInfo.getCode() == 0) {
                SkuInfoVo info = skuInfo.getData(&quot;skuInfo&quot;, new TypeReference&lt;SkuInfoVo&gt;() {
                });
                redisTo.setSkuInfo(info);
            }

            //sku秒杀信息
            BeanUtils.copyProperties(seckillSkuVo, redisTo);

            //设置商品的秒杀时间信息
            redisTo.setStartTime(session.getStartTime().getTime());
            redisTo.setEndTime(session.getEndTime().getTime());

            //商品随机码
            String token = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
            redisTo.setRandomCode(token);

            //设置商品的分布式信号量：保障非常快速的完成商品库存判断
            RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE_PREFIX + token);
            semaphore.trySetPermits(seckillSkuVo.getSeckillCount());

            String s = JSON.toJSONString(redisTo);
            ops.put(seckillSkuVo.getSkuId().toString(), s);
        });
    });
}
</code></pre>
<ol start="4">
<li>幂等性问题的解决<br>
在这种上架逻辑中会出现幂等性问题，即可能会出现多次重复上架。</li>
</ol>
<pre><code class="language-java">//1.首先保证同步，在使用之前先上分布式锁
private final String upload_lock = &quot;seckill:upload:lock&quot;;

/**
    * 定时上架最近三天的秒杀商品
    * 当天00：00：00 - 23：59：59
    * 明天00：00：00 - 23：59：59
    * 后天00：00：00 - 23：59：59
    */
@Scheduled(cron = &quot;*/3 * * * * ?&quot;)
public void uploadSeckillSkuLatest3Days() {
    log.info(&quot;上架秒杀商品信息&quot;);
    RLock lock = redissonClient.getLock(upload_lock);
    lock.lock(10, TimeUnit.SECONDS);
    try {
        seckillService.uploadSeckillSkuLatest3Days();
    } finally {
        lock.unlock();
    }
}
//2.添加幂等性判断
private void saveSessionInfos(List&lt;SeckillSessionsWithSkus&gt; sessions) {
    sessions.stream().forEach(session -&gt; {
        Long startTime = session.getStartTime().getTime();
        Long endTime = session.getEndTime().getTime();
        String key = SESSIONS_CACHE_PREFIX + startTime + &quot;_&quot; + endTime;
        Boolean hasKey = redisTemplate.hasKey(key);
        if(!hasKey) {
            List&lt;String&gt; collect = session.getRelationSkus().stream().map(item -&gt; item.getPromotionSessionId() + &quot;_&quot; + item.getSkuId().toString()).collect(Collectors.toList());
            redisTemplate.opsForList().leftPushAll(key, collect);
        }
    });
}

private void saveSessionSkuInfos(List&lt;SeckillSessionsWithSkus&gt; sessions) {
    sessions.stream().forEach(session -&gt; {
        //绑定Hash操作
        BoundHashOperations&lt;String, Object, Object&gt; ops = redisTemplate.boundHashOps(SKUKILL_CACHE_PREFIX);
        session.getRelationSkus().stream().forEach(seckillSkuVo -&gt; {
            SecKillSkuRedisTo redisTo = new SecKillSkuRedisTo();
            /**
                * 幂等性:当场次_skuId匹配存在时即已经上架过，不再上架
                */
            if(!ops.hasKey(seckillSkuVo.getPromotionSessionId().toString() + &quot;_&quot; + seckillSkuVo.getSkuId().toString())) {
                //sku基本数据
                R skuInfo = productFeignService.getSkuInfo(seckillSkuVo.getSkuId());
                if(skuInfo.getCode() == 0) {
                    SkuInfoVo info = skuInfo.getData(&quot;skuInfo&quot;, new TypeReference&lt;SkuInfoVo&gt;() {
                    });
                    redisTo.setSkuInfo(info);
                }

                //sku秒杀信息
                BeanUtils.copyProperties(seckillSkuVo, redisTo);

                //设置商品的秒杀时间信息
                redisTo.setStartTime(session.getStartTime().getTime());
                redisTo.setEndTime(session.getEndTime().getTime());

                //商品随机码
                String token = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
                redisTo.setRandomCode(token);

                //设置商品的分布式信号量：保障非常快速的完成商品库存判断
                RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE_PREFIX + token);
                semaphore.trySetPermits(seckillSkuVo.getSeckillCount());

                String s = JSON.toJSONString(redisTo);
                ops.put(seckillSkuVo.getPromotionSessionId().toString() + &quot;_&quot; + seckillSkuVo.getSkuId().toString(), s);
            }
        });
    });
}
</code></pre>
<h3 id="秒杀信息展示">秒杀信息展示</h3>
<h4 id="首页展示">首页展示</h4>
<p>在秒杀服务中直接查询redis数据库即可达成。</p>
<pre><code class="language-java">/**
    * 获取当前可以参与秒杀的商品信息
    *
    * @return
    */
@Override
public List&lt;SecKillSkuRedisTo&gt; getCurrentSeckillSkus() {
    //1.确定当前时间属于哪个秒杀场次
    //当前时间
    long time = new Date().getTime();
    //从redis获取所有秒杀场次信息
    Set&lt;String&gt; keys = redisTemplate.keys(SESSIONS_CACHE_PREFIX + &quot;*&quot;);
    for (String key : keys) {
        String replace = key.replace(SESSIONS_CACHE_PREFIX, &quot;&quot;);
        String[] s = replace.split(&quot;_&quot;);
        Long start = Long.parseLong(s[0]);
        Long end = Long.parseLong(s[1]);
        if (time &gt;= start &amp;&amp; time &lt;= end) {
            //当前场次,获取当前场次的信息
            List&lt;String&gt; range = redisTemplate.opsForList().range(key, 0, -1);
            BoundHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.boundHashOps(SKUKILL_CACHE_PREFIX);
            List&lt;String&gt; list = hashOps.multiGet(range);
            if (list != null) {
                List&lt;SecKillSkuRedisTo&gt; collect = list.stream().map(item -&gt; {
                    SecKillSkuRedisTo redis = JSON.parseObject(item, SecKillSkuRedisTo.class);
                    return redis;
                }).collect(Collectors.toList());
                return collect;
            }
            break;
        }
    }
    return null;
}
</code></pre>
<p>在页面加载时就通过ajax发送请求，获取当前秒杀商品的信息。再填充到页面的指定位置。</p>
<pre><code class="language-js">$.get(&quot;http://seckill.mall.com/currentSeckillSkus&quot;, function (resp) {
    if (resp.data.length &gt; 0) {
        resp.data.forEach(function (item) {
            $(&quot;&lt;li&gt;&lt;/li&gt;&quot;)
                .append($(&quot;&lt;img style='width: 130px; height: 130px;' src='&quot; + item.skuInfo.skuDefaultImg + &quot;'/&gt;&quot;))
                .append($(&quot;&lt;p&gt;&quot; + item.skuInfo.skuTitle + &quot;&lt;/p&gt;&quot;))
                .append($(&quot;&lt;span&gt;&quot; + item.seckillPrice + &quot;&lt;/span&gt;&quot;))
                .append($(&quot;&lt;s&gt;&quot; + item.skuInfo.price + &quot;&lt;/s&gt;&quot;))
                .appendTo(&quot;#seckillSkuContent&quot;);
        })
    }
})
</code></pre>
<p>效果<br>
<img src="https://dxone1.github.io//post-images/1638763784588.png" alt="" loading="lazy"></p>
<h4 id="商品详情页展示">商品详情页展示</h4>
<p>先查询当前商品的秒杀信息的预告，在商品详情页的查询中添加一个异步任务</p>
<pre><code class="language-java">CompletableFuture&lt;Void&gt; seckillFuture = CompletableFuture.runAsync(() -&gt; {
            // 查询sku是否是秒杀商品
            R r = seckillFeignService.getskuSeckillInfo(skuId);
            if (r.getCode() == 0) {
                SeckillInfoVo seckillInfoVo = r.getData(new TypeReference&lt;SeckillInfoVo&gt;() {
                });
                skuItemVo.setSeckillInfoVo(seckillInfoVo);
            }
        }, executor);
</code></pre>
<p>具体查询逻辑：</p>
<pre><code class="language-java">/**
    * 获取当前商品的秒杀预告信息
    * @param skuId
    * @return
    */
@Override
public SecKillSkuRedisTo getskuSeckillInfo(Long skuId) {
    //1.找到所有需要参与秒杀的商品的key信息
    BoundHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.boundHashOps(SKUKILL_CACHE_PREFIX);
    Set&lt;String&gt; keys = hashOps.keys();
    if(keys != null &amp;&amp; keys.size() &gt; 0) {
        String regx = &quot;\\d_&quot; + skuId;
        for(String key: keys) {
            if (Pattern.matches(regx, key)) {
                String json = hashOps.get(key);
                SecKillSkuRedisTo skuRedisTo = JSON.parseObject(json, SecKillSkuRedisTo.class);
                Long startTime = skuRedisTo.getStartTime();
                Long endTime = skuRedisTo.getEndTime();
                long current = new Date().getTime();
                if(current &gt; endTime) {
                    // 如果是已经结束的秒杀则不显示
                    continue;
                } else if(current &lt; startTime) {
                    // 如果还未开始，则将随机码隐藏
                    skuRedisTo.setRandomCode(null);
                }
                return skuRedisTo;
            }
        }
    }
    return null;
}
</code></pre>
<p>展示效果完成：<br>
<img src="https://dxone1.github.io//post-images/1638775716609.png" alt="" loading="lazy"></p>
<h3 id="秒杀系统">秒杀系统</h3>
<h4 id="秒杀系统设计">秒杀系统设计</h4>
<p>系统设计的原则<br>
<img src="https://dxone1.github.io//post-images/1638776349544.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1638776366926.png" alt="" loading="lazy"><br>
<strong>之前已经完成的功能：</strong></p>
<ul>
<li>使用单一职责独立部署的秒杀服务</li>
<li>每一个秒杀商品都包含一个随机生成的token，只有在秒杀业务开始之后请求页面才会暴露</li>
<li>库存预热和快速扣减，使用redis数据库+信号量机制</li>
<li>使用Nginx服务器进行动静分离</li>
</ul>
<h4 id="秒杀登录检查">秒杀登录检查</h4>
<p>在前端页面点击秒杀后向后台发送请求。请求会带上这次页面刷新获取到的skuId，秒杀场次id和token。前端页面需要判断是否存在<code>session.loginUser</code>，存在则说明已经登录，发送请求，否则跳转到登录页。同时也在后台配置登录拦截器。</p>
<pre><code class="language-java">@Component
public class LoginUserInterceptor implements HandlerInterceptor {

    public static ThreadLocal&lt;MemberRespVo&gt; loginUser = new ThreadLocal&lt;&gt;();

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        String uri = request.getRequestURI();
        AntPathMatcher antPathMatcher = new AntPathMatcher();
        boolean match = antPathMatcher.match(&quot;/kill&quot;, uri);
        if (match) {
            //秒杀服务才需要登录
            MemberRespVo attribute = (MemberRespVo) request.getSession().getAttribute(AuthServerConstant.LOGIN_USER);
            if (attribute != null) {
                loginUser.set(attribute);
                return true;
            } else {
                request.getSession().setAttribute(&quot;msg&quot;, &quot;请先登录&quot;);
                response.sendRedirect(&quot;http://auth.mall.com/login.html&quot;);
                return false;
            }
        }
        return true;
    }
}
</code></pre>
<h4 id="秒杀逻辑">秒杀逻辑</h4>
<p>考虑到系统大并发的场景，采用单独的一套系统逻辑完成秒杀下单、支付。和订单系统则通过消息队列沟通，能有效将流量影响控制在单个服务中。<br>
<img src="https://dxone1.github.io//post-images/1638782255151.png" alt="" loading="lazy"><br>
当秒杀成功，需要将下单的相关信息发送给<code>order-event-exchange</code>，有订单服务监听创建订单</p>
<pre><code class="language-java">/**
    * 秒杀业务逻辑
    *
    * @param killId
    * @param key
    * @param num
    * @return
    */
@Override
public String kill(String killId, String key, Integer num) {
    MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get();
    //1.获取商品的详细信息
    BoundHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.boundHashOps(SKUKILL_CACHE_PREFIX);
    String json = hashOps.get(killId);
    if (!StringUtils.isEmpty(json)) {
        SecKillSkuRedisTo redisTo = JSON.parseObject(json, SecKillSkuRedisTo.class);
        //2.校验合法性
        //时间
        Long startTime = redisTo.getStartTime();
        Long endTime = redisTo.getEndTime();
        long time = new Date().getTime();
        if (time &gt;= startTime &amp;&amp; time &lt;= endTime) {
            //3.校验token
            String randomCode = redisTo.getRandomCode();
            if (randomCode.equals(key)) {
                //4.数量是否合理
                Integer seckillLimit = redisTo.getSeckillLimit();
                if (num &lt;= seckillLimit) {
                    //5.只允许这个人购买一次,只要秒杀成功就占位
                    //userId_sessionId_skuId
                    String redisKey = memberRespVo.getId() + &quot;_&quot; + killId;
                    // 设定当前场次后过期
                    long ttl = endTime - time;
                    // 尝试将当前购物人信息保存占位，如果设置失败则表明已经秒杀过
                    if (redisTemplate.opsForValue().setIfAbsent(redisKey, num.toString(), ttl, TimeUnit.MILLISECONDS)) {
                        //6.使用Semaphore信号量减库存
                        RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE_PREFIX + randomCode);
                        try {
                            boolean b = semaphore.tryAcquire(num, 100, TimeUnit.MILLISECONDS);
                            //秒杀成功
                            //快速下单，直接发送MQ消息
                            String timeId = IdWorker.getTimeId();
                            //构建消息
                            SeckillOrderTo orderTo = new SeckillOrderTo();
                            orderTo.setOrderSn(timeId);
                            orderTo.setMemberId(memberRespVo.getId());
                            orderTo.setNum(num);
                            orderTo.setPromotionSessionId(redisTo.getPromotionSessionId());
                            orderTo.setSkuId(redisTo.getSkuId());
                            orderTo.setSeckillPrice(redisTo.getSeckillPrice());
                            //发送
                            rabbitTemplate.convertAndSend(&quot;order-event-exchange&quot;, &quot;order.seckill.order&quot;, orderTo);
                            return timeId;
                        } catch (InterruptedException e) {
                            return null;
                        }
                    }
                }
            }
        }
    }
    return null;
}
</code></pre>
<p>创建绑定和队列关系</p>
<pre><code class="language-java">/**
    * 秒杀业务创建订单
    * @return
    */
@Bean
public Queue orderSeckillOrderQueue() {
    Queue queue = new Queue(&quot;order.seckill.order.queue&quot;, true, false, false);
    return queue;
}

/**
    * 秒杀绑定关系
    * @return
    */
@Bean
public Binding orderSeckillOrder() {
    Binding binding = new Binding(&quot;order.seckill.order.queue&quot;,
            Binding.DestinationType.QUEUE,
            &quot;order-event-exchange&quot;,
            &quot;order.seckill.order&quot;, null);
    return binding;
}
</code></pre>
<p>在秒杀之后再通过监听消息队列即可。最终秒杀一件商品的耗时约为11ms，这是在单线程限制最大堆空间100m下得到的。<br>
<img src="https://dxone1.github.io//post-images/1638798499548.png" alt="" loading="lazy"></p>
<h4 id="秒杀页面和支付打通">秒杀页面和支付打通</h4>
<p>再秒杀之后会生成一个快速订单，快速订单生成之后会提供去支付的接口，这个接口将会携带订单号传递给支付业务。支付业务通过订单号查询订单数据库完成支付。效果：<br>
抢购页面<br>
<img src="https://dxone1.github.io//post-images/1638849519740.png" alt="" loading="lazy"><br>
抢购成功的后处理页面<br>
<img src="https://dxone1.github.io//post-images/1638849549108.png" alt="" loading="lazy"><br>
支付的是秒杀价格<br>
<img src="https://dxone1.github.io//post-images/1638849679713.png" alt="" loading="lazy"></p>
<p><strong>后续需要补充的点</strong></p>
<ul>
<li>上架秒杀商品时要将每个数据添加一个过期时间</li>
<li>秒杀后续流程（收获地址等）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城项目 day 18：订单服务]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day-18ding-dan-fu-wu/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day-18ding-dan-fu-wu/">
        </link>
        <updated>2021-11-28T06:20:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="服务说明">服务说明</h2>
<p>包含4个服务页面：</p>
<ul>
<li>订单详情页</li>
<li>等待支付页</li>
<li>结算页面</li>
<li>收银页面</li>
</ul>
<p>订单支付会跳转到结算页面，然后收银。<br>
成功则会有订单详情页面显示，否则会出现等待支付页供重新付款。</p>
<h2 id="订单服务">订单服务</h2>
<p>首先引入SpringSession方便共享登录信息。准备和打通各个页面的资源。然后进入后端程序的编写和调试。</p>
<h3 id="业务说明">业务说明</h3>
<p>电商系统涉及到 3 流， 分别时信息流， 资金流， 物流， 而订单系统作为中枢将三者有机的集合起来。订单模块是电商系统的枢纽， 在订单这个环节上需求获取多个模块的数据和信息， 同时对这些信息进行加工处理后流向下个环节， 这一系列就构成了订单的信息流通。<br>
<img src="https://dxone1.github.io//post-images/1638088841808.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1638089031556.png" alt="" loading="lazy"><br>
注意，整个订单服务必须已经是登陆状态才可进入，所以可以考虑使用拦截器</p>
<pre><code class="language-java">@Component
public class LoginUserInterceptor implements HandlerInterceptor {

    public static ThreadLocal&lt;MemberRespVo&gt; loginUser = new ThreadLocal&lt;&gt;();

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        MemberRespVo attribute = (MemberRespVo) request.getSession().getAttribute(AuthServerConstant.LOGIN_USER);
        if(attribute != null) {
            loginUser.set(attribute);
            return true;
        } else {
            request.getSession().setAttribute(&quot;msg&quot;, &quot;请先登录&quot;);
            response.sendRedirect(&quot;http://auth.mall.com/login.html&quot;);
            return false;
        }
    }
}
</code></pre>
<h3 id="订单确认结算页面">订单确认：结算页面</h3>
<p>从购物车点击去结算，因为有之前写好的拦截器存在，只有登录之后才可以前往结算页面。首先需要抽取出一个模型封装所有的结算页面信息。</p>
<pre><code class="language-java">@Data
public class OrderConfirmVo {
    // 用户收货地址列表
    List&lt;MemberAddressVo&gt; address;
    // 送货清单：购物项
    List&lt;OrderItemVo&gt; items;
    // 发票...
    // 积分信息
    private Integer integration;
    // 订单总额
    BigDecimal total;
    // 应付总价格
    BigDecimal payPrice;
}
</code></pre>
<ol>
<li>确认页的数据获取</li>
</ol>
<pre><code class="language-java">@Override
public OrderConfirmVo confirmOrder() {
    OrderConfirmVo confirmVo = new OrderConfirmVo();
    //1.远程查询用户的所有收货列表
    MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get();
    List&lt;MemberAddressVo&gt; address = memberFeignService.getAddress(memberRespVo.getId());
    confirmVo.setAddress(address);

    //2.远程查询购物车所有选中的购物项
    List&lt;OrderItemVo&gt; items = cartFeignService.getCurrentUserCartItems();
    confirmVo.setItems(items);

    //3.查询用户积分
    Integer integration = memberRespVo.getIntegration();
    confirmVo.setIntegration(integration);

    //其他数据自动计算


    return confirmVo;
}
</code></pre>
<ol start="2">
<li>问题<br>
在远程查询购物车购物项时的方法为：</li>
</ol>
<pre><code class="language-java">@Override
public List&lt;CartItem&gt; getUserCartItems() {
    UserInfoTo userInfoTo = CartInterceptor.threadLocal.get();
    if (userInfoTo.getUserId() == null) {
        return null;
    } else {
        String cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserId();
        List&lt;CartItem&gt; collect = getCartItems(cartKey).stream()
                .filter(item -&gt; item.getCheck())
                .map(item -&gt; {
                    // 在结算时必须获取最新价格
                    BigDecimal price = productFeignService.getPrice(item.getSkuId());
                    item.setPrice(price);
                    return item;
                })
                .collect(Collectors.toList());
        return collect;
    }
}
</code></pre>
<p><strong>通过feign远程调用会无法获取到用户session，这是因为Feign调用并不会持有名为MALLSESSION的cookie。</strong><br>
<img src="https://dxone1.github.io//post-images/1638104997936.png" alt="" loading="lazy"><br>
解决：在发送Feign请求时加入拦截器，添加丢失的cookie。</p>
<pre><code class="language-java">@Configuration
public class FeignConfig {

    @Bean
    public RequestInterceptor requestInterceptor() {
        return new RequestInterceptor() {
            @Override
            public void apply(RequestTemplate requestTemplate) {
                // 获得旧请求的数据
                ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
                HttpServletRequest request = attributes.getRequest();
                // 同步请求头信息
                String cookie = request.getHeader(&quot;Cookie&quot;);
                requestTemplate.header(&quot;Cookie&quot;, cookie);
            }
        };
    }
}
</code></pre>
<p><strong>在异步模式下，Feign会导致上下文丢失</strong>：<br>
异步模式下不在同一个线程，无法共享threadLocal实现的请求上下文，这样拦截器就无法获得请求。<br>
<img src="https://dxone1.github.io//post-images/1638107111126.png" alt="" loading="lazy"><br>
解决：异步下每开一个线程都设置上上下文信息。</p>
<pre><code class="language-java">@Override
public OrderConfirmVo confirmOrder() throws ExecutionException, InterruptedException {
    OrderConfirmVo confirmVo = new OrderConfirmVo();
    MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get();
    RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();

    CompletableFuture&lt;Void&gt; getAddressFuture = CompletableFuture.runAsync(() -&gt; {
        //1.远程查询用户的所有收货列表
        RequestContextHolder.setRequestAttributes(requestAttributes);
        List&lt;MemberAddressVo&gt; address = memberFeignService.getAddress(memberRespVo.getId());
        confirmVo.setAddress(address);
    }, executor);

    CompletableFuture&lt;Void&gt; getCartFuture = CompletableFuture.runAsync(() -&gt; {
        //2.远程查询购物车所有选中的购物项
        RequestContextHolder.setRequestAttributes(requestAttributes);
        List&lt;OrderItemVo&gt; items = cartFeignService.getCurrentUserCartItems();
        confirmVo.setItems(items);
    }, executor);

    //3.查询用户积分
    Integer integration = memberRespVo.getIntegration();
    confirmVo.setIntegration(integration);

    //其他数据自动计算
    CompletableFuture.allOf(getAddressFuture, getCartFuture).get();

    return confirmVo;
}
</code></pre>
<ol start="3">
<li>总结</li>
</ol>
<ul>
<li>通过拦截器给Feign的远程调用添加新的请求头信息。</li>
<li>异步下因为线程切换，基于ThreadLoacl的RequestContexHolder无法获取。需要在异步任务启动时将信息共享给异步方法。</li>
</ul>
<ol start="4">
<li>页面和方法的细化<br>
在页面展示中需要显示多个收获地址的选择，货物库存情况和运费情况的实现，也需要后台处理好数据并提交显示。<br>
<strong>库存情况</strong></li>
</ol>
<pre><code class="language-java">CompletableFuture&lt;Void&gt; getCartFuture = CompletableFuture.runAsync(() -&gt; {
    //2.远程查询购物车所有选中的购物项
    RequestContextHolder.setRequestAttributes(requestAttributes);
    List&lt;OrderItemVo&gt; items = cartFeignService.getCurrentUserCartItems();
    confirmVo.setItems(items);
}, executor).thenRunAsync(() -&gt; {
    // 远程查询库存信息。
    List&lt;OrderItemVo&gt; items = confirmVo.getItems();
    List&lt;Long&gt; skuIds = items.stream().map(item -&gt; item.getSkuId()).collect(Collectors.toList());
    R hasStock = wmsFeignService.getSkuHasStock(skuIds);
    List&lt;SkuStockVo&gt; data = hasStock.getData(new TypeReference&lt;List&lt;SkuStockVo&gt;&gt;(){});
    if(data != null) {
        Map&lt;Long, Boolean&gt; map = data.stream().collect(Collectors.toMap(SkuStockVo::getSkuId, SkuStockVo::getHasStock));
        confirmVo.setStocks(map);
    }
}, executor);
</code></pre>
<p><strong>运费模拟</strong><br>
通过远程调用库存和用户服务获取地址，进行简单的运费计算。</p>
<h2 id="提交订单">提交订单</h2>
<p>提交时必须注意接口幂等性，即同一个订单的放重复提交。<br>
接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的， 不会因为多次点击而产生了副作用； 比如说支付场景， 用户购买了商品支付扣款成功， 但是返回结果的时候网络异常， 此时钱已经扣了， 用户再次点击按钮， 此时会进行第二次扣款， 返回结果成功， 用户查询余额返发现多扣钱了， 流水记录也变成了两条,这就没有保证接口的幂等性。</p>
<ul>
<li>令牌机制（如验证码），如果匹配就删除令牌，注意匹配和删除使用lua脚本保证原子性</li>
<li>锁：
<ul>
<li>数据库悲观锁</li>
<li>数据库乐观锁</li>
<li>业务层的分布式锁</li>
</ul>
</li>
<li>唯一约束：例如使得订单号唯一</li>
<li>redis的set防重</li>
<li>数据库的放重复表</li>
<li>全局请求唯一id：每一个请求设置一个唯一的id</li>
</ul>
<h3 id="订单提交">订单提交</h3>
<p>使用令牌机制提交订单并解决幂等问题。在令牌验证通过之后要创建订单项，获取相关信息并跳转到结算页面。<br>
这部分具体要做以下的细节问题：</p>
<ul>
<li>原子的验证令牌并删除</li>
<li>创建订单</li>
<li>订单验价：当前购物车的价格和页面价格比较</li>
<li>保存订单信息</li>
<li>库存锁定，如果失败则需要回滚</li>
</ul>
<pre><code class="language-java">@Transactional
@Override
public SubmitOrderResponseVo submitOrder(OrderSubmitVo vo) {
    SubmitOrderResponseVo response = new SubmitOrderResponseVo();
    // 获取传来的令牌
    MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get();
    submitVoThreadLocal.set(vo);
    response.setCode(0);
    // lua脚本 0:失败 1:成功
    String script = &quot;if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end&quot;;
    String orderToken = vo.getOrderToken();

    Long result = redisTemplate.execute(new DefaultRedisScript&lt;Long&gt;(script, Long.class),
            Arrays.asList(OrderConstant.USER_ORDER_TOKEN_PREFIX + memberRespVo.getId()),
            orderToken);
    if (result == 0L) {
        //令牌验证失败
        response.setCode(1);
        return response;
    } else {
        //1.创建订单
        OrderCreateTo order = createOrder();
        //2.验价
        BigDecimal payAmount = order.getOrder().getPayAmount();
        BigDecimal payPrice = vo.getPayPrice();
        if(Math.abs(payAmount.subtract(payPrice).doubleValue()) &lt; 0.01) {
            //验价成功
            //保存订单信息
            saveOrder(order);
            //库存锁定，如果异常则需要回滚:调用库存服务
            WareSkuLockVo lockVo = new WareSkuLockVo();
            lockVo.setOrderSn(order.getOrder().getOrderSn());

            List&lt;OrderItemVo&gt; orderItemVos = order.getOrderItems().stream().map(item -&gt; {
                OrderItemVo itemVo = new OrderItemVo();
                itemVo.setSkuId(item.getSkuId());
                itemVo.setCount(item.getSkuQuantity());
                itemVo.setTitle(item.getSkuName());
                return itemVo;
            }).collect(Collectors.toList());
            lockVo.setLocks(orderItemVos);
            // 远程锁库存
            R r = wmsFeignService.orderLockStock(lockVo);
            if(r.getCode() == 0) {
                //锁成功
                response.setOrder(order.getOrder());
                return response;
            } else {
                String msg = (String) r.get(&quot;msg&quot;);
                throw new NoStockException(msg);
            }
        } else{
            //验价失败返回
            response.setCode(2);
            return response;
        }
    }
}
</code></pre>
<h2 id="分布式事务">分布式事务</h2>
<p>存储订单项和扣除库存必须是一个事务操作，而两个功能却在不同的服务中。必须使用分布式事务解决这个问题。在之前的代码中使用了异常机制，只要返回库存添加失败就抛出异常，于是调用链上的其他数据库操作也会回滚。但是存在假成功和假失败的问题。<br>
<img src="https://dxone1.github.io//post-images/1638359696008.png" alt="" loading="lazy"><br>
SpringBoot的@Transcational是使用代理对象实现的，只支持本地事务。同时，在本地同一个对象内事务方法互调会绕过代理对象，这会导致本地事务失效。解决方法如下：</p>
<ul>
<li>引入aop-starter，使用aspectj</li>
<li>开启aspectj动态代理<code>@EnableAspectJAutoProxy</code></li>
<li>使用AspectJ提供的动态代理</li>
</ul>
<h3 id="cap理论">CAP理论：</h3>
<p>在一致性（Consistency），可用性（Availability），分区容错性（Partition tolerance）中只能同时保证两个。其中，分区容错无法避免，所以C和A只能二选其一。<br>
满足CP的raft算法，通过领导选举和日志复制保证了CP特性。具体的过程如下：</p>
<ol>
<li>选举</li>
</ol>
<ul>
<li>起始状态均为follower，当自旋结束前没有其他的投票请求时，状态变更为candidata，同时发送投票请求</li>
<li>每轮接获投票请求时就投票，得到当前分布式系统一半以上票数的节点被推选为leader节点，通过心跳信息来维持连接</li>
<li>如果leader收到client的消息，就要进行日志复制</li>
</ul>
<ol start="2">
<li>日志复制</li>
</ol>
<ul>
<li>当leader受到更新请求，需要先在自己的日志上记录</li>
<li>leader将更新请求发送给所有其他节点，当收到大多数节点的回复后就执行更新，并返回更新命令给其他节点</li>
<li>一致性通过如下策略保证，如果某个区块发生了分区容错问题，那么该区块会自治的形成新的leader，但是如果这个区块没有达到总数的1/2那么就无法通过上一步完成最终的更新。当网络问题解决，因为该leader的轮数低，所以区块内所有节点的未提交更新全部回滚。这保证了强一致性。</li>
</ul>
<h3 id="base理论">BASE理论</h3>
<p>然而，互联网应用大部分更加注重高可用性（AP），思想是即使无法保证强一致性，也应采取合适的方法实现弱一致性。即最终一致性。<br>
BASE 是指</p>
<ul>
<li>基本可用（Basically Available）
<ul>
<li>基本可用是指分布式系统在出现故障的时候， 允许损失部分可用性（例如响应时间、功能上的可用性） ， 允许损失部分可用性。 需要注意的是， 基本可用绝不等价于系统不可用。</li>
<li>响应时间上的损失： 正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果， 但由于出现故障（比如系统部分机房发生断电或断网故障） ， 查询结果的响应时间增加到了 1~2 秒。</li>
<li>功能上的损失： 购物网站在购物高峰（如双十一） 时， 为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
</li>
<li>软状态（ Soft State）
<ul>
<li>软状态是指允许系统存在中间状态， 而该中间状态不会影响系统整体可用性。 分布式存储中一般一份数据会有多个副本， 允许不同副本同步的延时就是软状态的体现。 mysql replication 的异步复制也是一种体现。</li>
</ul>
</li>
<li>最终一致性（ Eventual Consistency）
<ul>
<li>最终一致性是指系统中的所有数据副本经过一定时间后， 最终能够达到一致的状态。 弱一致性和强一致性相反， 最终一致性是弱一致性的一种特殊情况。</li>
</ul>
</li>
</ul>
<p>遵循BASE理论则需要使用柔性事务，相比遵循强一致性ACID的刚性事务性能更强，并发性更好。</p>
<h3 id="seata">Seata</h3>
<p>Seata是实现分布式事务的一种框架，支持 AT、TCC、SAGA 和 XA 事务模式。<br>
<img src="https://dxone1.github.io//post-images/1638428912390.png" alt="" loading="lazy"></p>
<ul>
<li>TC (Transaction Coordinator) - 事务协调者<br>
维护全局和分支事务的状态，驱动全局事务提交或回滚。</li>
<li>TM (Transaction Manager) - 事务管理器<br>
定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li>
<li>RM (Resource Manager) - 资源管理器<br>
管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<ol>
<li>给每个服务的数据库建立undo_log表用于回滚</li>
<li>使用Seata服务器担任TC的功能</li>
<li>导入依赖和配置，修改seata中的registy.conf文件，指定注册中心和配置中心</li>
<li>开启全局事务：在业务上标注@GlobalTransactional</li>
<li>在容器中注入DataSourceProxy代理数据源</li>
<li>每个微服务复制一个file.conf和registry.conf,修改<code>vgroup_mapping.[mall-ware]-fescar-service-group = &quot;default&quot;</code><br>
库存锁定功能</li>
</ol>
<pre><code class="language-java">@Transactional
@Override
public Boolean orderLockStock(WareSkuLockVo vo) {
    //1.找到每个商品在哪个仓库有库存
    List&lt;OrderItemVo&gt; locks = vo.getLocks();
    List&lt;SkuWareHasStock&gt; collect = locks.stream().map(item -&gt; {
        SkuWareHasStock stock = new SkuWareHasStock();
        Long skuId = item.getSkuId();
        stock.setSkuId(skuId);
        List&lt;Long&gt; wareId = wareSkuDao.listWareIdHasSkuStock(skuId);
        stock.setWareId(wareId);
        stock.setNum(item.getCount());
        return stock;
    }).collect(Collectors.toList());

    //锁定库存
    for (SkuWareHasStock hasStock : collect) {
        Boolean skuStocked = false;
        Long skuId = hasStock.getSkuId();
        List&lt;Long&gt; wareIds = hasStock.getWareId();
        if (wareIds == null || wareIds.size() == 0) {
            throw new NoStockException(skuId);
        }
        for (Long wareId : wareIds) {
            //成功返回1
            Long count = wareSkuDao.lockSkuStock(skuId, wareId, hasStock.getNum());
            if(count == 1) {
                //成功
                skuStocked = true;
                break;
            } else {
                //当前仓库锁失败，试验下一个仓库
            }
        }
        if(skuStocked == false) {
            throw new NoStockException(skuId);
        }
    }
    return true;
}
</code></pre>
<h3 id="全局事务的最终方案选型">全局事务的最终方案选型</h3>
<p>默认使用AT模式，即使用的是二阶段提交的模型。区别是一阶段seata就已经提交更新，二阶段会进行回滚和反向补偿。这种模式适用于低并发的场景，如后台管理系统等。<br>
在高并发场景中，我们需要更高的吞吐量，所以采用基于通知的事务方法。最终决定使用可靠消息+最终一致性的柔性事务方案。实现： 业务处理服务在业务事务提交之前， 向实时消息服务请求发送消息， 实时消息服务只记录消息数据， 而不是真正的发送。 业务处理服务在业务事务提交之后， 向实时消息服务确认发送。 只有在得到确认发送指令后， 实时消息服务才会真正发送。<br>
最终的选型是使用消息队列完成分布式事务的功能</p>
<h2 id="订单服务的升级改造">订单服务的升级改造</h2>
<h3 id="rabbitmq延时队列">RabbitMQ延时队列</h3>
<p>RabbitMQ提供了演示队列机制，可以实现定时任务。<br>
<img src="https://dxone1.github.io//post-images/1638435703028.png" alt="" loading="lazy"><br>
<strong>为什么不使用轮询定时任务？</strong></p>
<ul>
<li>占用内存</li>
<li>每隔一段时间都需要读取数据库</li>
<li>有严重的时效性问题<br>
<img src="https://dxone1.github.io//post-images/1638435931664.png" alt="" loading="lazy"><br>
设定定时任务需要每隔一段时间查询数据库去探查订单是否失效关闭。而延时队列则经过特定长时间内容才可以被获取，解决了时效性问题。</li>
</ul>
<h4 id="ttl和dlx">TTL和DLX</h4>
<p>消息的TTL就是消息的存活时间。</p>
<ul>
<li>RabbitMQ可以对队列和消息分别设置TTL。</li>
<li>对队列设置就是队列没有消费者连着的保留时间，也可以对每一个单独的消息做单独的设置。超过了这个时间，我们认为这个消息就死了，称之为死信。</li>
<li>如果队列设置了，消息也设置了，那么会取小的。所以一个消息如果被路由到不同的队列中，这个消息死亡的时间有可能不一样（不同的队列设置）。这里单讲单个消息的TTL，因为它才是实现延迟任务的关键。可以通过设置消息的expiration字段或者xmessage-ttl属性来设置时间，两者是一样的效果。</li>
</ul>
<p>一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列，一个路由可以对应很多队列。</p>
<ul>
<li>一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。（basic.reject/ basic.nack）requeue=false</li>
<li>上面的消息的TTL到了，消息过期了。</li>
<li>队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上</li>
</ul>
<p>Dead Letter Exchange其实就是一种普通的exchange，和创建其他exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列<br>
<strong>通过死信路由会将超过TTL的的消息通过交换机路由到某个队列中，使用TTL + DLX即可实现延迟队列（订阅者订阅死信路由的队列即可）</strong><br>
<img src="https://dxone1.github.io//post-images/1638437013464.png" alt="" loading="lazy"></p>
<h3 id="实现订单自动关闭">实现订单自动关闭</h3>
<p>使用如下的MQ设计<br>
<img src="https://dxone1.github.io//post-images/1638437735015.png" alt="" loading="lazy"><br>
在SpringBoot中实现整合：</p>
<pre><code class="language-java">@Configuration
public class MyMQConfig {

    /**
     * 延时死信队列
     * @return
     */
    @Bean
    public Queue orderDelayQueue() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        // 设置死信路由的交换机,路由键和队列中的TTL
        arguments.put(&quot;x-dead-letter-exchange&quot;, &quot;order-event-exchange&quot;);
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;order.release.order&quot;);
        arguments.put(&quot;x-message-ttl&quot;, 60000);
        Queue queue = new Queue(&quot;order.delay.queue&quot;, true, false, false, arguments);
        return queue;
    }

    /**
     * 订单解除队列
     * @return
     */
    @Bean
    public Queue orderReleaseOrderQueue() {
        Queue queue = new Queue(&quot;order.release.order.queue&quot;, true, false, false);
        return queue;
    }

    /**
     * 交换机
     * @return
     */
    @Bean
    public Exchange orderEventExchange() {
        TopicExchange topicExchange = new TopicExchange(&quot;order-event-exchange&quot;, true, false);
        return topicExchange;
    }

    /**
     * 和延迟死信队列的绑定关系
     * @return
     */
    @Bean
    public Binding orderCreateOrderBinding() {
        Binding binding = new Binding(&quot;order.delay.queue&quot;,
                Binding.DestinationType.QUEUE,
                &quot;order-event-exchange&quot;,
                &quot;order.create.order&quot;, null);
        return binding;
    }

    /**
     * 和订单解除队列的绑定关系
     * @return
     */
    @Bean
    public Binding orderReleaseOrderBinding() {
        Binding binding = new Binding(&quot;order.release.order.queue&quot;,
                Binding.DestinationType.QUEUE,
                &quot;order-event-exchange&quot;,
                &quot;order.release.order&quot;, null);
        return binding;
    }
}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">// Listener
@RabbitListener(queues = &quot;order.release.order.queue&quot;)
public void listener(OrderEntity entity, Channel channel, Message message) throws IOException {
    System.out.println(&quot;收到过期订单消息,准备关闭订单&quot; + entity.getOrderSn());
    long deliveryTag = message.getMessageProperties().getDeliveryTag();
    channel.basicAck(deliveryTag, false);
}

// Sender
@ResponseBody
@GetMapping(&quot;/test/createOrder&quot;)
public String createOrderTest() {
    OrderEntity orderEntity = new OrderEntity();
    orderEntity.setOrderSn(UUID.randomUUID().toString());
    orderEntity.setModifyTime(new Date());
    //给MQ发送消息
    rabbitTemplate.convertAndSend(&quot;order-event-exchange&quot;, &quot;order.create.order&quot;, orderEntity);
    return &quot;Success&quot;;
}
</code></pre>
<h3 id="库存自动解锁">库存自动解锁</h3>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1638447108464.png" alt="" loading="lazy"></figure>
<ol>
<li>准备队列，交换机和绑定</li>
</ol>
<pre><code class="language-java">@Configuration
public class MyRabbitConfig {

    @Autowired
    RabbitTemplate rabbitTemplate;


    @Bean
    public MessageConverter messageConverter() {
        Jackson2JsonMessageConverter converter = new Jackson2JsonMessageConverter();
        return converter;
    }

    @PostConstruct
    public void initRabbitTemplate() {

        // Confirm Callback
        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
            /**
             *
             * @param correlationData 含有消息的唯一id
             * @param ack 消息是否成功
             * @param cause 失败的原因
             */
            @Override
            public void confirm(CorrelationData correlationData, boolean ack, String cause) {
                System.out.println(&quot;confirm...data: &quot; + correlationData + &quot; ==&gt; ack: &quot; + ack + &quot;==&gt; cause: &quot; + cause);
            }
        });

        // Return Callback
        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {
            /**
             * 消息投递失败给指定队列的回调
             * @param message 投递失败的详细信息
             * @param replyCode 回复码
             * @param replyText 回复文本
             * @param exchange 交换机
             * @param routingKey 路由键
             */
            @Override
            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
                System.out.println(&quot;Fail message:&quot; + message + &quot; ==&gt; replyCode:&quot; + replyCode + &quot; ==&gt; replyText:&quot; + replyText
                        + &quot; ==&gt; exchange:&quot; + exchange + &quot; ==&gt; routingKey:&quot; + routingKey);
            }
        });
    }

    /**
     * 库存交换机
     *
     * @return
     */
    @Bean
    public Exchange stockEventExchange() {
        TopicExchange topicExchange = new TopicExchange(&quot;stock-event-exchange&quot;, true, false);
        return topicExchange;
    }

    /**
     * 库存解锁队列
     *
     * @return
     */
    @Bean
    public Queue stockReleaseStockQueue() {
        return new Queue(&quot;stock.release.stock.queue&quot;, true, false, false);
    }

    /**
     * 延迟队列
     *
     * @return
     */
    @Bean
    public Queue stockDelayQueue() {
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        // 设置死信路由的交换机,路由键和队列中的TTL
        arguments.put(&quot;x-dead-letter-exchange&quot;, &quot;stock-event-exchange&quot;);
        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;stock.release&quot;);
        arguments.put(&quot;x-message-ttl&quot;, 120000);
        return new Queue(&quot;stock.delay.queue&quot;, true, false, false, arguments);
    }

    /**
     * 交换机和库存解锁队列的绑定
     * @return
     */
    @Bean
    public Binding stockReleaseBinding() {
        return new Binding(&quot;stock.release.stock.queue&quot;,
                Binding.DestinationType.QUEUE,
                &quot;stock-event-exchange&quot;,
                &quot;stock.release.#&quot;,
                null);
    }

    /**
     * 交换机和延时队列的绑定
     * @return
     */
    @Bean
    public Binding stockLockedBinding() {
        return new Binding(&quot;stock.delay.queue&quot;,
                Binding.DestinationType.QUEUE,
                &quot;stock-event-exchange&quot;,
                &quot;stock.locked&quot;,
                null);
    }

    @RabbitListener(queues = &quot;stock.release.stock.queue&quot;)
    public void handle(Message message) {

    }
}
</code></pre>
<ol start="2">
<li>编写库存自动解锁功能<br>
库存解锁场景:<br>
1.下单成功,但是订单过期没有支付被系统自动取消或是用户手动取消<br>
2.下单成功,库存成功但是接下来流程的业务失败,之前锁定的库存也要</li>
</ol>
<p><strong>自动解锁库存业务的逻辑:</strong></p>
<ol>
<li>当锁定库存执行业务成功后,将会向wareEventExchange发送一个锁定库存的消息,路由到延时队列中。</li>
<li>延时到TTL之后将自动重新以release..的路由键路由，通过绑定关系会路由到release队列</li>
<li>提供一个解锁服务的Listener,绑定的是解锁队列。效果是在锁定库存后的指定时间，该Listener将会得到消息。执行解锁库存的逻辑。</li>
</ol>
<pre><code class="language-java">/**
     * 库存解锁场景:
     * 1.下单成功,但是订单过期没有支付被系统自动取消或是用户手动取消
    * 2.下单成功,库存成功但是接下来流程的业务失败,之前锁定的库存也要自动解锁
    *
    * @param vo
    * @return
    */
@Transactional
@Override
public Boolean orderLockStock(WareSkuLockVo vo) {
    /**
        * 保存库存工作单
        */
    WareOrderTaskEntity taskEntity = new WareOrderTaskEntity();
    taskEntity.setOrderSn(vo.getOrderSn());
    orderTaskService.save(taskEntity);

    //1.找到每个商品在哪个仓库有库存
    List&lt;OrderItemVo&gt; locks = vo.getLocks();
    List&lt;SkuWareHasStock&gt; collect = locks.stream().map(item -&gt; {
        SkuWareHasStock stock = new SkuWareHasStock();
        Long skuId = item.getSkuId();
        stock.setSkuId(skuId);
        List&lt;Long&gt; wareId = wareSkuDao.listWareIdHasSkuStock(skuId);
        stock.setWareId(wareId);
        stock.setNum(item.getCount());
        return stock;
    }).collect(Collectors.toList());

    //锁定库存
    for (SkuWareHasStock hasStock : collect) {
        Boolean skuStocked = false;
        Long skuId = hasStock.getSkuId();
        List&lt;Long&gt; wareIds = hasStock.getWareId();
        if (wareIds == null || wareIds.size() == 0) {
            throw new NoStockException(skuId);
        }
        /**
            * 每当一个商品锁定成功都会将当前锁定的工作单id,详情id发送给MQ
            * 当有一个失败,就会触发异常,本地事务回滚。发送的消息在数据库中就不会存在记录，如果订单服务触发解锁库存也会因找不到记录而不用解锁
            */
        for (Long wareId : wareIds) {
            //成功返回1
            Long count = wareSkuDao.lockSkuStock(skuId, wareId, hasStock.getNum());
            if (count == 1) {
                //成功
                skuStocked = true;
                /**
                    * 保存工作单详情
                    */
                WareOrderTaskDetailEntity entity = new WareOrderTaskDetailEntity(null, skuId, &quot;&quot;, hasStock.getNum(), taskEntity.getId(), wareId, 1);
                orderTaskDetailService.save(entity);
                //TODO 告知MQ库存锁定成功,发送格式是(工作单id,当前工作的详情id)
                StockLockedTo stockLockedTo = new StockLockedTo();
                stockLockedTo.setId(taskEntity.getId());
                StockDetailTo stockDetailTo = new StockDetailTo();
                BeanUtils.copyProperties(entity, stockDetailTo);
                stockLockedTo.setDetailTo(stockDetailTo);
                rabbitTemplate.convertAndSend(&quot;stock-event-exchange&quot;, &quot;stock.locked&quot;, stockLockedTo);
                break;
            } else {
                //当前仓库锁失败，试验下一个仓库
            }
        }
        if (skuStocked == false) {
            throw new NoStockException(skuId);
        }
    }
    return true;
}
</code></pre>
<p><strong>库存解锁逻辑</strong></p>
<ol>
<li>当收到消息时就是执行自动解锁库存的时机。按照以下逻辑处理业务：</li>
</ol>
<pre><code class="language-java">/**
  * 监听延时自动解锁队列
  * 1.如果发现此时没有订单，则必须解锁库存
  * 2.如果此时有订单，则要根据订单状态决定
  *      1.订单不存在或者订单状态为已取消，则解锁
  *      2.订单未取消，则不解锁
  */
</code></pre>
<ol start="2">
<li>具体的，使用手动Ack机制，这样只需要在特定场景中ack或reject即可</li>
</ol>
<pre><code class="language-java">@Service
@RabbitListener(queues = &quot;stock.release.stock.queue&quot;)
public class StockReleaseListener {

    @Autowired
    WareSkuService wareSkuService;
    /**
     * 监听延时自动解锁队列
     * 1.如果发现此时没有订单，则必须解锁库存
     * 2.如果此时有订单，则要根据订单状态决定
     *      1.订单不存在或者订单状态为已取消，则解锁
     *      2.订单未取消，则不解锁
     *
     * @param to
     * @param message
     */
    @RabbitHandler
    public void handleStockLockedRelease(StockLockedTo to, Message message, Channel channel) throws IOException {
        try {
            wareSkuService.unlockStock(to);
            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
        } catch (Exception e) {
            channel.basicReject(message.getMessageProperties().getDeliveryTag(), true);
        }
    }
}
/*******************************************************************/

@Override
public void unlockStock(StockLockedTo to) {
    System.out.println(&quot;收到解锁库存的消息&quot;);
    //查询数据库
    StockDetailTo detail = to.getDetailTo();
    Long detailId = detail.getId();
    WareOrderTaskDetailEntity byId = orderTaskDetailService.getById(detailId);
    if (byId != null) {
        //解锁
        //库存工作单的id
        Long id = to.getId();
        WareOrderTaskEntity taskEntity = orderTaskService.getById(id);
        //查询订单号
        String orderSn = taskEntity.getOrderSn();
        R r = orderFeignService.getOrderStatus(orderSn);
        if (r.getCode() == 0) {
            //订单数据返回成功
            OrderVo data = r.getData(new TypeReference&lt;OrderVo&gt;() {
            });
            // data == null时订单后续流程自己回滚了,也需要解锁库存
            if (data == null || data.getStatus() == 4) {
                // 订单已经取消状态,解锁库存
                unLockStock(detail.getSkuId(), detail.getWareId(), detail.getSkuNum(), detailId);
            } else {
                //无需解锁
            }
        } else {
            // 消息拒绝,重新放入队列
            throw new RuntimeException(&quot;远程服务失败&quot;);
        }
    } else {
        //无需解锁
    }
}

private void unLockStock(Long skuId, Long wareId, Integer num, Long taskDetailId) {
    this.wareSkuDao.unlockStock(skuId, wareId, num);
}
</code></pre>
<p>最后将会实现分布式的最终一致性：当自动解锁库存触发后，发现因为某种错误导致订单并没有生成或已被取消，则释放库存。注意具体实现中使用异常机制，如果触发解锁库存异常就会reject消息，否则ack。</p>
<h3 id="自动关单功能的整合">自动关单功能的整合</h3>
<p><img src="https://dxone1.github.io//post-images/1638524939325.png" alt="" loading="lazy"><br>
同样使用延时队列实现自动关单。</p>
<ol>
<li>在订单创建成功后，将订单创建成功的消息发送到对应的MQ中</li>
</ol>
<pre><code class="language-java">// 远程锁库存
......
    R r = wmsFeignService.orderLockStock(lockVo);
    if(r.getCode() == 0) {
        //锁成功
        response.setOrder(order.getOrder());
        //TODO 订单创建成功则发送消息给MQ
        rabbitTemplate.convertAndSend(&quot;order-event-exchange&quot;, &quot;order.create.order&quot;, order.getOrder());
        return response;
    } else {
        String msg = (String) r.get(&quot;msg&quot;);
        throw new NoStockException(msg);
    }
......
</code></pre>
<ol start="2">
<li>当监听到订单创建成功的消息已经是延时1分钟之后了。需要执行业务查看是否自动关单</li>
</ol>
<pre><code class="language-java">/**
    * 关闭订单
    * @param entity
    */
@Override
public void closeOrder(OrderEntity entity) {
    // 查询当前订单的状态
    OrderEntity orderEntity = getById(entity.getId());
    if(orderEntity.getStatus() == OrderStatusEnum.CREATE_NEW.getCode()) {
        //关单
        OrderEntity update = new OrderEntity();
        update.setId(entity.getId());
        update.setStatus(OrderStatusEnum.CANCLED.getCode());
        this.updateById(update);
    }
}
</code></pre>
<h3 id="解决消息延迟-丢失-堆压和重复">解决消息延迟、丢失、堆压和重复</h3>
<h4 id="1-消息延迟">1. 消息延迟</h4>
<p>我们设计关库存自动解锁慢于订单自动解锁，如果出现网络问题导致订单解锁延迟，就会出现库存无法解锁的情况<br>
<img src="https://dxone1.github.io//post-images/1638532052088.png" alt="" loading="lazy"><br>
<strong>解决：</strong><br>
当订单释放后要主动发出一个释放订单的消息，通过消息直接路由到库存解锁绑定的队列上，这样就能通知库存解锁。<br>
1）将订单事件交换机同库存解锁队列直接绑定</p>
<pre><code class="language-java">/**
    * 订单取消时通知库存解锁的绑定
    * @return
    */
@Bean
public Binding orderReleaseOtherBinding() {
    Binding binding = new Binding(&quot;stock.release.stock.queue&quot;,
            Binding.DestinationType.QUEUE,
            &quot;order-event-exchange&quot;,
            &quot;order.release.other.#&quot;, null);
    return binding;
}
</code></pre>
<p>2）关闭订单的同时发送库存解锁消息</p>
<pre><code class="language-java">/**
    * 关闭订单
    * @param entity
    */
@Override
public void closeOrder(OrderEntity entity) {
    // 查询当前订单的状态
    OrderEntity orderEntity = getById(entity.getId());
    if(orderEntity.getStatus() == OrderStatusEnum.CREATE_NEW.getCode()) {
        //关单
        OrderEntity update = new OrderEntity();
        update.setId(entity.getId());
        update.setStatus(OrderStatusEnum.CANCLED.getCode());
        this.updateById(update);
        //发送库存解锁信息
        OrderTo orderTo = new OrderTo();
        BeanUtils.copyProperties(orderEntity, orderTo);
        rabbitTemplate.convertAndSend(&quot;order-event-exchange&quot;, &quot;order.release.other&quot;, orderTo);
    }
}
</code></pre>
<p>3）编写接收订单关闭的库存解锁监听器和功能</p>
<pre><code class="language-java">@RabbitHandler
public void handleOrderCloseRelease(OrderTo orderTo, Message message, Channel channel) throws IOException {
    System.out.println(&quot;订单关闭,解锁库存...&quot;);
    try {
        wareSkuService.unlockStock(orderTo);
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    } catch (Exception e) {
        channel.basicReject(message.getMessageProperties().getDeliveryTag(), true);

    }
}
/*******************************************************/

/**
    * 订单服务通知的库存解锁
    * @param orderTo
    */
@Transactional
@Override
public void unlockStock(OrderTo orderTo) {
    String orderSn = orderTo.getOrderSn();
    //查询最新库存解锁状态
    WareOrderTaskEntity task = orderTaskService.getOrderTaskByOrderSn(orderSn);
    Long taskId = task.getId();
    //通过工作单找到但内所有没有解锁的订单项解锁
    List&lt;WareOrderTaskDetailEntity&gt; entities = orderTaskDetailService.list(new QueryWrapper&lt;WareOrderTaskDetailEntity&gt;()
            .eq(&quot;task_id&quot;, taskId)
            .eq(&quot;lock_status&quot;, 1));
    for (WareOrderTaskDetailEntity entity : entities) {
        unLockStock(entity.getSkuId(), entity.getWareId(), entity.getSkuNum(), entity.getId());
    }
}
</code></pre>
<h4 id="2-可靠消息">2. 可靠消息</h4>
<p>1、消息丢失</p>
<ul>
<li>消息发送出去，由于网络问题没有抵达服务器<br>
• 做好容错方法（try-catch），发送消息可能会网络失败，失败后要有重试机制，可记录到数据库，采用定期扫描重发的方式<br>
• 做好日志记录，每个消息状态是否都被服务器收到都应该记录<br>
• 做好定期重发，如果消息没有发送成功，定期去数据库扫描未成功的消息进行重发</li>
<li>消息抵达Broker，Broker要将消息写入磁盘（持久化）才算成功。此时Broker尚未持久化完成，宕机。<br>
• publisher也必须加入确认回调机制，确认成功的消息，修改数据库消息状态。</li>
<li>自动ACK的状态下。消费者收到消息，但没来得及消费然后宕机<br>
• 一定开启手动ACK，消费成功才移除，失败或者没来得及处理就noAck并重新入队</li>
</ul>
<p>2、消息重复</p>
<ul>
<li>消息消费失败，由于重试机制，自动又将消息发送出去</li>
<li>消息消费成功，事务已经提交，ack时，机器宕机。导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者<br>
• 消费者的业务消费接口应该设计为幂等性的。比如扣库存有工作单的状态标志（★）<br>
• 使用防重表（redis/mysql），发送消息每一个都有业务的唯一标识，处理过就不用处理<br>
• rabbitMQ的每一个消息都有redelivered字段，可以获取是否是被重新投递过来的，而不是第一次投递过来的</li>
</ul>
<p>3、消息积压</p>
<ul>
<li>消费者宕机积压</li>
<li>消费者消费能力不足积压</li>
<li>发送者发送流量太大<br>
• 上线更多的消费者，进行正常消费<br>
• 上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理</li>
</ul>
<h2 id="支付业务">支付业务</h2>
<p>使用支付宝沙箱环境进行测试。支付服务的验证和加密过程：<br>
<img src="https://dxone1.github.io//post-images/1638538080670.png" alt="" loading="lazy"></p>
<ol>
<li>内网穿透<br>
支付宝的回调必须使用可以通过外网访问的机器，这就需要内网穿透。<br>
<img src="https://dxone1.github.io//post-images/1638539750548.png" alt="" loading="lazy"></li>
<li>依赖Alipay SDK</li>
</ol>
<pre><code class="language-xml">&lt;!--支付宝SDK--&gt;
&lt;!-- https://mvnrepository.com/artifact/com.alipay.sdk/alipay-sdk-java --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt;
    &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt;
    &lt;version&gt;4.9.28.ALL&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="3">
<li>从demo中抽取工具类</li>
</ol>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;alipay&quot;)
@Component
@Data
public class AlipayTemplate {

    //在支付宝创建的应用的id
    private   String app_id = &quot;2021***&quot;;

    // 商户私钥，您的PKCS8格式RSA2私钥
    private  String merchant_private_key = &quot;&quot;;
    // 支付宝公钥,查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥。
    private  String alipay_public_key = &quot;&quot;;
    // 服务器[异步通知]页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
    // 支付宝会悄悄的给我们发送一个请求，告诉我们支付成功的信息
    private  String notify_url = &quot;http://x8jy34ij62.51xd.pub/alipay.trade.page.pay-JAVA-UTF-8/notify_url.jsp&quot;;

    // 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
    //同步通知，支付成功，一般跳转到成功页
    private  String return_url = &quot;http://x8jy34ij62.51xd.pub/alipay.trade.page.pay-JAVA-UTF-8/return_url.jsp&quot;;

    // 签名方式
    private  String sign_type = &quot;RSA2&quot;;

    // 字符编码格式
    private  String charset = &quot;utf-8&quot;;

    // 支付宝网关； https://openapi.alipaydev.com/gateway.do
    private  String gatewayUrl = &quot;https://openapi.alipaydev.com/gateway.do&quot;;

    public  String pay(PayVo vo) throws AlipayApiException {

        //AlipayClient alipayClient = new DefaultAlipayClient(AlipayTemplate.gatewayUrl, AlipayTemplate.app_id, AlipayTemplate.merchant_private_key, &quot;json&quot;, AlipayTemplate.charset, AlipayTemplate.alipay_public_key, AlipayTemplate.sign_type);
        //1、根据支付宝的配置生成一个支付客户端
        AlipayClient alipayClient = new DefaultAlipayClient(gatewayUrl,
                app_id, merchant_private_key, &quot;json&quot;,
                charset, alipay_public_key, sign_type);

        //2、创建一个支付请求 //设置请求参数
        AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();
        alipayRequest.setReturnUrl(return_url);
        alipayRequest.setNotifyUrl(notify_url);

        //商户订单号，商户网站订单系统中唯一订单号，必填
        String out_trade_no = vo.getOut_trade_no();
        //付款金额，必填
        String total_amount = vo.getTotal_amount();
        //订单名称，必填
        String subject = vo.getSubject();
        //商品描述，可空
        String body = vo.getBody();

        alipayRequest.setBizContent(&quot;{\&quot;out_trade_no\&quot;:\&quot;&quot;+ out_trade_no +&quot;\&quot;,&quot;
                + &quot;\&quot;total_amount\&quot;:\&quot;&quot;+ total_amount +&quot;\&quot;,&quot;
                + &quot;\&quot;subject\&quot;:\&quot;&quot;+ subject +&quot;\&quot;,&quot;
                + &quot;\&quot;body\&quot;:\&quot;&quot;+ body +&quot;\&quot;,&quot;
                + &quot;\&quot;product_code\&quot;:\&quot;FAST_INSTANT_TRADE_PAY\&quot;}&quot;);

        String result = alipayClient.pageExecute(alipayRequest).getBody();

        //会收到支付宝的响应，响应的是一个页面，只要浏览器显示这个页面，就会自动来到支付宝的收银台页面
        System.out.println(&quot;支付宝的响应：&quot;+result);

        return result;

    }
}
</code></pre>
<ol start="3">
<li>编写调用</li>
</ol>
<pre><code class="language-java">/**
    * 取得当前订单的支付信息
    * @param orderSn
    * @return
    */
@Override
public PayVo getOrderPay(String orderSn) {
    PayVo payVo = new PayVo();
    OrderEntity orderEntity = getOrderByOrderSn(orderSn);

    BigDecimal totalAmount = orderEntity.getPayAmount().setScale(2, BigDecimal.ROUND_UP);
    payVo.setTotal_amount(totalAmount.toString());//金额
    payVo.setOut_trade_no(orderEntity.getOrderSn());//订单号

    List&lt;OrderItemEntity&gt; order_sn = orderItemService.list(new QueryWrapper&lt;OrderItemEntity&gt;().eq(&quot;order_sn&quot;, orderSn));
    payVo.setSubject(order_sn.get(0).getSkuName());//订单信息,用第一个商品数据的标题作为主题
    payVo.setBody(order_sn.get(0).getSkuAttrsVals());//订单备注
    return payVo;
}
</code></pre>
<ol start="4">
<li>支付回调<br>
将支付成功后的回调设计为该用户的订单列表页面。需要查询当前用户的所有订单</li>
</ol>
<pre><code class="language-java">@Override
public PageUtils queryPageWithItem(Map&lt;String, Object&gt; params) {
    MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get();
    IPage&lt;OrderEntity&gt; page = this.page(
            new Query&lt;OrderEntity&gt;().getPage(params),
            new QueryWrapper&lt;OrderEntity&gt;().eq(&quot;member_id&quot;, memberRespVo.getId())
    );
    return new PageUtils(page);
}
</code></pre>
<ol start="5">
<li>在页面中显示，最终的结果页面如图所示：<br>
<img src="https://dxone1.github.io//post-images/1638612400084.png" alt="" loading="lazy"></li>
<li>异步通知<br>
只要支付成功，就会进行异步通知。其异步结果通知会以POST请求方式将所有支付结果发送给配置的异步回调地址。通过最大努力通知方案实现分布式事务的最终一致。<br>
<img src="https://dxone1.github.io//post-images/1638617579204.png" alt="" loading="lazy"><br>
异步通知的回调要使用内网穿透的外部地址，有这样的网络拓扑。可以看到在通过内网穿透的服务时会丢失请求Host导致无法匹配路由。<br>
<img src="https://dxone1.github.io//post-images/1638618188654.png" alt="" loading="lazy"><br>
<strong>解决</strong><br>
在Nginx直接配置精确的地址映射。<br>
<img src="https://dxone1.github.io//post-images/1638619238590.png" alt="" loading="lazy"><br>
在拦截器中解除这个访问被要求登录。</li>
<li>支付成功回调<br>
先将支付宝回调的数据封装起来：</li>
</ol>
<pre><code class="language-java">@ToString
@Data
public class PayAsyncVo {

    private String gmt_create;
    private String charset;
    private String gmt_payment;
    private String notify_time;
    private String subject;
    private String sign;
    private String buyer_id;//支付者的id
    private String body;//订单的信息
    private String invoice_amount;//支付金额
    private String version;
    private String notify_id;//通知id
    private String fund_bill_list;
    private String notify_type;//通知类型； trade_status_sync
    private String out_trade_no;//订单号
    private String total_amount;//支付的总额
    private String trade_status;//交易状态  TRADE_SUCCESS
    private String trade_no;//流水号
    private String auth_app_id;//
    private String receipt_amount;//商家收到的款
    private String point_amount;//
    private String app_id;//应用id
    private String buyer_pay_amount;//最终支付的金额
    private String sign_type;//签名类型
    private String seller_id;//商家的id

}
</code></pre>
<p><strong>处理：</strong><br>
既要修改订单状态和库存状态，也要在记录下支付流水记录。使用自动收单功能，防止长久不支付连库存都解锁了。</p>
<pre><code class="language-java">/**
    * 处理支付宝异步返回结果
    * @param vo
    * @return
    */
@Override
public String handlePayResult(PayAsyncVo vo) {
    //1.保存交易流水
    PaymentInfoEntity infoEntity = new PaymentInfoEntity();
    infoEntity.setAlipayTradeNo(vo.getTrade_no());//交易单号
    infoEntity.setOrderSn(vo.getOut_trade_no());//订单号
    infoEntity.setPaymentStatus(vo.getTrade_status());//支付状态
    infoEntity.setCallbackTime(vo.getNotify_time());//回调事件
    paymentInfoService.save(infoEntity);
    //2.修改订单状态
    if (vo.getTrade_status().equals(&quot;TRADE_SUCCESS&quot;) || vo.getTrade_status().equals(&quot;TRADE_FINISHED&quot;)) {
        //支付成功状态,修改订单为支付成功
        String outTradeNo = vo.getOut_trade_no();
        baseMapper.updateOrderStatus(outTradeNo, OrderStatusEnum.PAYED.getCode());
    }
    return &quot;success&quot;;
}
</code></pre>
<pre><code class="language-java">// 设置1分钟过期
alipayRequest.setBizContent(&quot;{\&quot;out_trade_no\&quot;:\&quot;&quot;+ out_trade_no +&quot;\&quot;,&quot;
                + &quot;\&quot;total_amount\&quot;:\&quot;&quot;+ total_amount +&quot;\&quot;,&quot;
                + &quot;\&quot;subject\&quot;:\&quot;&quot;+ subject +&quot;\&quot;,&quot;
                + &quot;\&quot;body\&quot;:\&quot;&quot;+ body +&quot;\&quot;,&quot;
                + &quot;\&quot;timeout_express\&quot;:\&quot;1m\&quot;,&quot;
                + &quot;\&quot;product_code\&quot;:\&quot;FAST_INSTANT_TRADE_PAY\&quot;}&quot;);
</code></pre>
<p>为了防止异步通知时延导致还未关单就支付成功，因为消息来晚了已经解锁库存，手动在解锁库存处调用收单。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城项目 day17：使用RabbitMQ实现分布式消息]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day17shi-yong-rabbitmq-shi-xian-fen-bu-shi-xiao-xi/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day17shi-yong-rabbitmq-shi-xian-fen-bu-shi-xiao-xi/">
        </link>
        <updated>2021-11-27T03:14:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="消息中间件在项目中的应用">消息中间件在项目中的应用</h2>
<ol>
<li>实现异步处理</li>
</ol>
<p>例如：原先有如下工作流程<br>
<img src="https://dxone1.github.io//post-images/1637983169916.png" alt="" loading="lazy"><br>
调整为异步模式：<br>
<img src="https://dxone1.github.io//post-images/1637983189849.png" alt="" loading="lazy"><br>
考察这个场景，其实反馈根本无需等待发送邮件和短信成功，则使用消息中间件的流程如下：<br>
<img src="https://dxone1.github.io//post-images/1637983256227.png" alt="" loading="lazy"><br>
2. 应用解耦</p>
<p>以下为例，如果库存系统的接口改变，订单系统也不需要改变调用<br>
<img src="https://dxone1.github.io//post-images/1637983651720.png" alt="" loading="lazy"></p>
<ol start="3">
<li>流量控制</li>
</ol>
<p>瞬时流量很大的秒杀业务等，将大并发量的请求全部存储到消息队列中，真正的业务处理订阅消息队列挨个处理即可。不会造成后台的资源耗尽。</p>
<h2 id="rabbitmq">RabbitMQ</h2>
<p>消息代理：安装了消息中间件的服务器<br>
目的地：</p>
<ul>
<li>队列：点对点的消息通信：可以有多个接收者监听，但同一个消息只会被一个消费者消费</li>
<li>主题：发布订阅模式的消息通信：将消息发送到主题中，能有同时多个接收者消费该消息</li>
</ul>
<p>RabbitMQ基于AMOP实现，也兼容了JMS规范<br>
<img src="https://dxone1.github.io//post-images/1637985445167.png" alt="" loading="lazy"></p>
<h3 id="简介">简介</h3>
<p>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。<br>
<img src="https://dxone1.github.io//post-images/1637993392181.png" alt="" loading="lazy"></p>
<h3 id="安装">安装</h3>
<p>使用Docker安装，端口定义如下</p>
<ul>
<li>4369, 25672 (Erlang发现&amp;集群端口)</li>
<li>5672, 5671 (AMQP端口)</li>
<li>15672 (web管理后台端口)</li>
<li>61613, 61614 (STOMP协议端口)</li>
<li>1883, 8883 (MQTT协议端口)</li>
</ul>
<p>官网：https://www.rabbitmq.com/networking.html</p>
<pre><code class="language-dockerfile">docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1638000519523.png" alt="" loading="lazy"></figure>
<h3 id="交换机">交换机</h3>
<p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</p>
<ol>
<li>Direct （点对点）<br>
消息中的路由键（routing key）如果和Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routingkey 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式<br>
<img src="https://dxone1.github.io//post-images/1638001476440.png" alt="" loading="lazy"></li>
<li>Fanout （订阅）：广播<br>
每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。<br>
<img src="https://dxone1.github.io//post-images/1638001459277.png" alt="" loading="lazy"></li>
<li>Topic（订阅）：泛匹配<br>
opic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“*”。#匹配0个或多个单词，*匹配一个单词。<br>
<img src="https://dxone1.github.io//post-images/1638001363325.png" alt="" loading="lazy"></li>
</ol>
<p>通过可视化界面创建交换机、队列并将它们绑定<br>
<img src="https://dxone1.github.io//post-images/1638001804408.png" alt="" loading="lazy"></p>
<h3 id="测试">测试</h3>
<p>按照如下的图片结构建立交换网络<br>
<img src="https://dxone1.github.io//post-images/1638001915949.png" alt="" loading="lazy"></p>
<h3 id="springboot整合">springboot整合</h3>
<ol>
<li>引入依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>开启RabbitMQ功能<code>@EnableRabbit</code></li>
<li>配置rabbitMQ的连接功能</li>
</ol>
<pre><code class="language-yaml">spring.rabbitmq.host=192.168.180.3
spring.rabbitmq.port=5672
spring.rabbitmq.virtual-host=/
</code></pre>
<ol start="4">
<li>测试创建</li>
</ol>
<pre><code class="language-java">@Slf4j
@SpringBootTest
@RunWith(SpringRunner.class)
public class MallOrderApplicationTests {

    /**
     * 1 使用AmqpAdmin创建exchange, Queue, Binding等
     * 2 配置连接信息 spring.rabbitmq.*
      */
    @Autowired
    AmqpAdmin amqpAdmin;

    @Test
    public void createExchange() {
        //创建交换机
        DirectExchange directExchange = new DirectExchange(&quot;hello-java-exchange&quot;, true, false);
        amqpAdmin.declareExchange(directExchange);
        log.info(&quot;exchange[{}]创建成功&quot;, directExchange.getName());
    }

    @Test
    public void createQueue() {
        Queue queue = new Queue(&quot;hello-java-queue&quot;, true, false, false);
        amqpAdmin.declareQueue(queue);
        log.info(&quot;Queue[{}]创建成功&quot;, queue.getName());
    }

    @Test
    public void createBinding() {
        Binding binding = new Binding(&quot;hello-java-queue&quot;,
                Binding.DestinationType.QUEUE,
                &quot;hello-java-exchange&quot;,
                &quot;hello.java&quot;, null);
        amqpAdmin.declareBinding(binding);
        log.info(&quot;Binding创建成功&quot;);

    }
}
</code></pre>
<ol start="5">
<li>测试发送消息<br>
如果希望使用JSON序列化，则要给IOC添加一个JSON的MessageConverter</li>
</ol>
<pre><code class="language-java">@Configuration
public class MyRabbitConfig {

    @Bean
    public MessageConverter messageConverter() {
        Jackson2JsonMessageConverter converter = new Jackson2JsonMessageConverter();
        return converter;
    }
}
</code></pre>
<pre><code class="language-java">@Test
    public void sendMessageTest() {
        String msg = &quot;Hello World!&quot;;
        // 如果发送一个对象，则该对象必须序列化
        OrderReturnReasonEntity reasonEntity = new OrderReturnReasonEntity();
        reasonEntity.setId(1L);
        reasonEntity.setCreateTime(new Date());
        reasonEntity.setName(&quot;呵呵&quot;);
        // 使用json序列化
        rabbitTemplate.convertAndSend(&quot;hello-java-exchange&quot;, &quot;hello.java&quot;, reasonEntity);
        log.info(&quot;消息发送完成{}&quot;, reasonEntity);
    }
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1638005185596.png" alt="" loading="lazy"><br>
6. 测试接收消息<br>
使用@RabbitListener注解监听消息</p>
<pre><code class="language-java">//@RabbitListener(queues = {&quot;hello-java-queue&quot;})
// RabbitHandler可以使用重载接收多种类型
@RabbitHandler
public void receiveMessage(Message message,
                            OrderReturnReasonEntity content,
                            Channel channel) throws InterruptedException {
    System.out.println(&quot;接收到消息...&quot;);
    Thread.sleep(3000);
    // 有消息头也有消息体
    System.out.println(message);
    // 直接使用对应类型接收
    System.out.println(content);
    // 也可以通过通道传输
    System.out.println(channel);
    System.out.println(&quot;消息处理完成&quot;);
}
</code></pre>
<h3 id="rabbitmq的可靠抵达">RabbitMQ的可靠抵达</h3>
<p>保证消息不丢失，可靠抵达，可以使用事务消息，性能下降250倍，为此引入确认机制<br>
• publisher confirmCallback 确认模式<br>
• publisher returnCallback 未投递到 queue 退回模式<br>
• consumer ack机制<br>
<img src="https://dxone1.github.io//post-images/1638006893744.png" alt="" loading="lazy"></p>
<ol>
<li>spring.rabbitmq.publisher-confirms=true</li>
</ol>
<ul>
<li>在创建 connectionFactory 的时候设置 PublisherConfirms(true) 选项，开启confirmcallback 。</li>
<li>CorrelationData：用来表示当前消息唯一性。</li>
<li>消息只要被 broker 接收到就会执行 confirmCallback，如果是 cluster 模式，需要所有broker 接收到才会调用confirmCallback。</li>
<li>被 broker 接收到只能表示 message 已经到达服务器，并不能保证消息一定会被投递 到目标 queue 里。所以需要用到接下来的returnCallback 。</li>
</ul>
<ol start="2">
<li>spring.rabbitmq.publisher-returns=true<br>
spring.rabbitmq.template.mandatory=true</li>
</ol>
<ul>
<li>confrim 模式只能保证消息到达 broker，不能保证消息准确投递到目标 queue 里。在有 些业务场景下，我们需要保证消息一定要投递到目标 queue 里，此时就需要用到return 退回模式。</li>
<li>这样如果未能投递到目标 queue 里将调用 returnCallback ，可以记录下详细到投递数 据，定期的巡检或者自动纠错都需要这些数据。</li>
</ul>
<ol start="3">
<li>Ack消息确认机制</li>
</ol>
<ul>
<li>消费者获取到消息，成功处理，可以回复Ack给Broker
<ul>
<li>basic.ack用于肯定确认；broker将移除此消息</li>
<li>basic.nack用于否定确认；可以指定broker是否丢弃此消息，可以批量</li>
<li>basic.reject用于否定确认；同上，但不能批量</li>
</ul>
</li>
<li>默认自动ack，消息被消费者收到，就会从broker的queue中移除</li>
<li>queue无消费者，消息依然会被存储，直到消费者消费</li>
<li>消费者收到消息，默认会自动ack。但是如果无法确定此消息是否被处理完成， 或者成功处理。我们可以开启手动ack模式
<ul>
<li>消息处理成功，ack()，接受下一个消息，此消息broker就会移除</li>
<li>消息处理失败，nack()/reject()，重新发送给其他人进行处理，或者容错处理后ack</li>
<li>消息一直没有调用ack/nack方法，broker认为此消息正在被处理，不会投递给别人，此时客户 端断开，消息不会被broker移除，会投递给别人</li>
</ul>
</li>
</ul>
<h4 id="confirmcallback抵达服务器的回调">confirmCallback：抵达服务器的回调</h4>
<p>在配置中开启</p>
<pre><code class="language-yaml">spring.rabbitmq.publisher-confirms=true
</code></pre>
<p>定制RabbitTemplate，设置confirmCallback</p>
<pre><code class="language-java">@PostConstruct
public void initRabbitTemplate() {
    rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
        /**
            *
            * @param correlationData 含有消息的唯一id
            * @param ack 消息是否成功
            * @param cause 失败的原因
            */
        @Override
        public void confirm(CorrelationData correlationData, boolean ack, String cause) {
            System.out.println(&quot;confirm...id: &quot; + correlationData.getId() + &quot; ==&gt; ack: &quot; + ack + &quot;==&gt; cause: &quot; + cause);
        }
    });
}
</code></pre>
<p>只要消息能顺利抵达服务器broker，就会回调confirmCallback，其中<code>ack = true</code>。</p>
<h4 id="returncallback投递给队列失败">returnCallback：投递给队列失败</h4>
<p>消息抵达队列会进行回调。</p>
<pre><code class="language-yaml">#发送端消息抵达队列callback
spring.rabbitmq.publisher-returns=true
#以异步方式优先回调return confirm
spring.rabbitmq.template.mandatory=true
</code></pre>
<pre><code class="language-java">@PostConstruct
public void initRabbitTemplate() {

    // Confirm Callback
    ......
    // Return Callback
    rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {
        /**
            * 消息投递失败给指定队列的回调
            * @param message 投递失败的详细信息
            * @param replyCode 回复码
            * @param replyText 回复文本
            * @param exchange 交换机
            * @param routingKey 路由键
            */
        @Override
        public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
            System.out.println(&quot;Fail message:&quot; + message + &quot; ==&gt; replyCode:&quot; + replyCode + &quot; ==&gt; replyText:&quot; + replyText
                    + &quot; ==&gt; exchange:&quot; + exchange + &quot; ==&gt; routingKey:&quot; + routingKey);
        }
    });
}
</code></pre>
<h4 id="ack消息确认机制">Ack消息确认机制</h4>
<p>消费端确认默认是自动确认，当有Listener监听到就取出并确认。队列就将自动移除该消息。如果接收了所有消息就会自动删除队列中消息。然而如果此时处理失败就会导致消息丢失。所以可能需要手动在处理成功后手动ack。</p>
<pre><code class="language-yaml">spring.rabbitmq.listener.simple.acknowledge-mode=manual
</code></pre>
<pre><code class="language-java">@RabbitListener(queues = {&quot;hello-java-queue&quot;})
// RabbitHandler可以使用重载接收多种类型
//@RabbitHandler
public void receiveMessage(Message message,
                            OrderReturnReasonEntity content,
                            Channel channel) {
    System.out.println(&quot;接收到消息...&quot;);
    //Thread.sleep(3000);
    // 有消息头也有消息体
    System.out.println(message);
    // 直接使用对应类型接收
    System.out.println(content);
    // 也可以通过通道传输
    System.out.println(channel);
    System.out.println(&quot;消息处理完成&quot;);
    /**
        * 手动ack
        * 传入deliverTag表示签收哪个消息，不多个一起签收
        */
    long deliveryTag = message.getMessageProperties().getDeliveryTag();
    try {
        System.out.println(deliveryTag);
        if(deliveryTag % 2 == 0) {
            channel.basicAck(deliveryTag, false);
        } else {
            /**
                * 是否多个一起签收
                * 是否重复入队
                */
            channel.basicNack(deliveryTag, false, false);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城项目 day16：购物车服务]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day16gou-wu-che-fu-wu/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day16gou-wu-che-fu-wu/">
        </link>
        <updated>2021-11-26T02:54:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="配置环境">配置环境</h2>
<p>新启动一个模块，配置好端口，应用名，nacos地址，启动服务注册和发现与FeignClients。</p>
<pre><code class="language-xml">server.port=30000
spring.application.name=mall-cart

spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
</code></pre>
<p>将网关配置到该服务的转发</p>
<h2 id="购物车功能">购物车功能</h2>
<p>购物车需要有离线购物车功能，未登陆状态添加到购物车中会保存到这里。<br>
在登录状态，购物车会将临时购物车项目合并到购物车中，同时清除离线购物车。</p>
<ul>
<li>用户可以使用购物车一起结算下单</li>
<li>给购物车添加商品</li>
<li>用户可以查询自己的购物车</li>
<li>用户可以在购物车中修改购买商品的数量。</li>
<li>用户可以在购物车中删除商品。</li>
<li>选中不选中商品</li>
<li>在购物车中展示商品优惠信息</li>
<li>提示购物车商品价格变化</li>
</ul>
<p>技术选择：</p>
<ul>
<li>用户购物车：使用Redis+持久化策略实现</li>
<li>临时购物车：使用Redis实现</li>
</ul>
<p>Redis数据结构：<br>
每一条商品都是这样的结构：</p>
<pre><code class="language-json">{
    skuId: 2131241,
    check: true,
    title: &quot;Apple iphone.....&quot;,
    defaultImage: &quot;...&quot;,
    price: 4999,
    count: 1,
    totalPrice: 4999,
    skuSaleVO: {...}
}
</code></pre>
<p>每个购物车的value，都是一个双层hash类型（Hash表），这样每件商品的每一个属性都能快速的查找和修改。</p>
<pre><code class="language-yaml">key: cart_id
value: {
  { 
    key: sku_id
    value : {
      {key: check, value: true}
      {key: totalPrice, value: 4999}     
      ......      
    }
  }
}
</code></pre>
<h2 id="功能编写">功能编写</h2>
<ol>
<li>VO的编写<br>
根据上面的分析，购物车中每个商品的数据结构应该是一个双层的hash表，据此编写VO封装。每个cartItem中要有如下数据</li>
</ol>
<pre><code class="language-java">public class CartItem {
    private Long skuId;
    //是否选中
    private Boolean check = true;
    private String title;
    private String image;
    //sku销售属性
    private List&lt;String&gt; skuAttr;
    private BigDecimal price;
    private Integer count;
    private BigDecimal totalPrice;
}
</code></pre>
<ol start="2">
<li>整合SpringSession<br>
因为需要从Session获取登录信息，所以也需要整合Spring Session实现共享Session：得到登录信息。</li>
</ol>
<h3 id="使用threadlocal和拦截器进行用户身份鉴定">使用ThreadLocal和拦截器进行用户身份鉴定</h3>
<ul>
<li>如果登录：则session中有用户信息</li>
<li>如果没登录：则通过cookie中记录一个user-key来标识用户身份</li>
<li>没有登录且没有user-key，需要给用户创建一个这个cookie</li>
</ul>
<p>要实现如上业务逻辑，可以考虑使用一个拦截器实现。</p>
<pre><code class="language-java">public class CartInterceptor implements HandlerInterceptor {

    public static ThreadLocal&lt;UserInfoTo&gt; threadLocal = new ThreadLocal&lt;&gt;();
    /**
     * 执行前拦截
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        UserInfoTo userInfoTo = new UserInfoTo();

        HttpSession session = request.getSession();
        MemberRespVo member = (MemberRespVo) session.getAttribute(AuthServerConstant.LOGIN_USER);
        if(member != null) {
            // 用户登陆
            userInfoTo.setUserId(member.getId());
        }
        Cookie[] cookies = request.getCookies();
        if(cookies != null &amp;&amp; cookies.length &gt; 0) {
            for (Cookie cookie : cookies) {
                String name = cookie.getName();
                if(name.equals(CartConstant.TEMP_USER_COOKIE_NAME)) {
                    userInfoTo.setUserKey(cookie.getValue());
                    // 标记为已经存在临时用户
                    userInfoTo.setTempUser(true);
                }
            }
        }
        //第一次非登录使用时必须创建临时用户
        if(StringUtils.isEmpty(userInfoTo.getUserKey())) {
            String uuid = UUID.randomUUID().toString();
            userInfoTo.setUserKey(uuid);
        }

        //目标方法执行前放入threadLocal
        threadLocal.set(userInfoTo);
        return true;
    }

    /**
     * 业务执行之后要通知浏览器保存一个cookie
     * 其中存放了user-key，这样以后浏览器就可以使用这个cookie作为临时用户访问临时购物车
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        UserInfoTo userInfoTo = threadLocal.get();
        if(!userInfoTo.isTempUser()) {
            Cookie cookie = new Cookie(CartConstant.TEMP_USER_COOKIE_NAME, userInfoTo.getUserKey());
            cookie.setDomain(&quot;mall.com&quot;);
            cookie.setMaxAge(CartConstant.TEMP_USER_COOKIE_TIMEOUT);
            response.addCookie(cookie);
        }
        threadLocal.remove();
    }
}
</code></pre>
<p>记得在一个继承了<code>WebMvcConfigurer</code>的配置类中将该拦截器注册进调用链中。因为拦截器处理到最后的返回都在同一个线程内执行，所以考虑使用ThreadLoacl保证线程内的安全和共享。</p>
<h3 id="页面逻辑关系">页面逻辑关系</h3>
<ol>
<li>在商品详情页点击添加购物车后，成功跳转到成功页，同时会执行商品添加逻辑。</li>
<li>首页和检索页通过点击我的购物车都会跳转到cartList页面</li>
<li>首页跳转<br>
......</li>
</ol>
<h3 id="一个坑的解决">一个坑的解决</h3>
<p>在Nginx中配置http stream转发时，因为Linux服务器设置在虚拟机中，网段与本机的外部ip不同，一直以来设置本机外部ip的转发速度都很差。<br>
解决方案：<br>
将其ip设置为以太网适配器 VMware Network Adapter VMnet8所指使的虚拟ip，速度大幅提升</p>
<h2 id="添加购物车">添加购物车</h2>
<h3 id="添加到购物车基本功能">添加到购物车：基本功能</h3>
<ol>
<li>添加到购物车时页面传参skuId和数量</li>
</ol>
<pre><code class="language-js">$(&quot;#addToCartA&quot;).click(function () {
    var num = $(&quot;#numInput&quot;).val();
    var skuId = $(this).attr(&quot;skuId&quot;);
    location.href = &quot;http://cart.mall.com/addToCart?skuId=&quot; + skuId + &quot;&amp;num=&quot; + num;
});
</code></pre>
<ol start="2">
<li>处理<br>
通过传入skuId和num可以查询商品的具体信息和组合属性等信息。将其保存在对应的Redis数据项中即可。然而需要注意：如果已经存在相关的商品，需要合并。</li>
</ol>
<pre><code class="language-java">@Slf4j
@Service
public class CartServiceImpl implements CartService {
    @Autowired
    StringRedisTemplate redisTemplate;

    @Autowired
    ProductFeignService productFeignService;

    @Autowired
    ThreadPoolExecutor executor;

    /**
     * 添加到购物车方法
     * @param skuId
     * @param num
     * @return
     * @throws ExecutionException
     * @throws InterruptedException
     */
    @Override
    public CartItem addToCart(Long skuId, Integer num) throws ExecutionException, InterruptedException {
        BoundHashOperations&lt;String, Object, Object&gt; cartOps = getCartOps();
        String res = (String) cartOps.get(skuId.toString());
        if (StringUtils.isEmpty(res)) {
            //购物车没有此商品
            //添加新商品
            CartItem cartItem = new CartItem();
            /********* 异步方式远程调用获取商品信息和sku的组合属性 *********/
            CompletableFuture&lt;Void&gt; getSkuInfoTask = CompletableFuture.runAsync(() -&gt; {
                //1.远程查询当前要添加的商品信息
                R skuInfo = productFeignService.getSkuInfo(skuId);
                SkuInfoVo data = skuInfo.getData(&quot;skuInfo&quot;, new TypeReference&lt;SkuInfoVo&gt;() {
                });
                //2.将商品信息添加到购物车
                cartItem.setCheck(true);
                cartItem.setCount(num);
                cartItem.setImage(data.getSkuDefaultImg());
                cartItem.setTitle(data.getSkuTitle());
                cartItem.setSkuId(skuId);
                cartItem.setPrice(data.getPrice());
            }, executor);

            CompletableFuture&lt;Void&gt; getSkuSaleAttrValues = CompletableFuture.runAsync(() -&gt; {
                //3.远程查询sku的组合属性
                List&lt;String&gt; values = productFeignService.getSkuSaleAttrValues(skuId);
                cartItem.setSkuAttr(values);
            }, executor);

            CompletableFuture.allOf(getSkuInfoTask, getSkuSaleAttrValues).get();
            /********* 在redis中存储数据 *********/
            String s = JSON.toJSONString(cartItem);
            cartOps.put(skuId.toString(), s);
            return cartItem;
        } else {
            // 已经存在该商品
            CartItem cartItem = JSON.parseObject(res, CartItem.class);
            cartItem.setCount(cartItem.getCount() + num);
            // 更新redis
            cartOps.put(skuId.toString(), JSON.toJSONString(cartItem));
            return cartItem;
        }
    }

    /**
     * 获取一个绑定了一个购物车项的操作
     * @return
     */
    private BoundHashOperations&lt;String, Object, Object&gt; getCartOps() {
        // 获得当前用户信息
        UserInfoTo userInfoTo = CartInterceptor.threadLocal.get();
        // 1.判断用户登录情况
        String cartKey = &quot;&quot;;
        if (userInfoTo.getUserId() != null) {
            // 已经登录过，则添加到用户购物车中
            // 例：mall:cart:1
            cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserId();
        } else {
            //使用user-key标识临时用户
            cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserKey();
        }
        // 绑定一个Hash项执行一系列增删改查操作
        BoundHashOperations&lt;String, Object, Object&gt; operations = redisTemplate.boundHashOps(cartKey);
        return operations;
    }
}
</code></pre>
<h3 id="添加到购物车进阶调整">添加到购物车：进阶调整</h3>
<p><strong>防止重复提交</strong><br>
在提交成功页面如果反复刷新会重复提交添加购物车的请求，需要做出调整。原因是Controller跳转到成功页采用的转发而非重定向方式。更改为重定向到成功页面，同时添加上一个RedirectAttributes带上skuId作为参数，展示页面每次访问都查询一遍当前id的购物车内容。</p>
<pre><code class="language-java">@GetMapping(&quot;/addToCart&quot;)
public String addToCart(@RequestParam(&quot;skuId&quot;) Long skuId,
                        @RequestParam(&quot;num&quot;) Integer num,
                        RedirectAttributes ra) throws ExecutionException, InterruptedException {
    CartItem cartItem = cartService.addToCart(skuId, num);
    // 采用重定向方式，会添加到requestParam中
    ra.addAttribute(&quot;skuId&quot;, skuId);
    return &quot;redirect:http://cart.mall.com/addToCartSuccess.html&quot;;
}

/**
    * 跳转到添加购物车成功页，总是会刷新数据
    * @param skuId
    * @param model
    * @return
    */
@GetMapping(&quot;/addToCartSuccess.html&quot;)
public String addToCartSuccessPage(@RequestParam(&quot;skuId&quot;) Long skuId,
                                    Model model) {
    // 重定向到成功页面，再次查一遍购物车即可。
    CartItem cartItem = cartService.getCartItem(skuId);
    model.addAttribute(&quot;item&quot;, cartItem);
    return &quot;success&quot;;
}
</code></pre>
<h2 id="获取和合并购物车">获取和合并购物车</h2>
<p>合并购物车的逻辑是：当有用户登录后查看购物车，则会将cookie中保存的user-key所指示的临时购物车合并到用户购物车中，同时清空临时购物车。</p>
<pre><code class="language-java">@Override
public Cart getCart() throws ExecutionException, InterruptedException {
    Cart cart = new Cart();
    // 判断是否登录
    UserInfoTo userInfoTo = CartInterceptor.threadLocal.get();
    if (userInfoTo.getUserId() != null) {
        // 登录了,需要考察合并的问题
        // 如果临时购物车没有合并
        String tmpCartKey = CartConstant.CART_PREFIX + userInfoTo.getUserKey();
        List&lt;CartItem&gt; tmpCartItems = getCartItems(tmpCartKey);
        if(tmpCartItems != null) {
            // 临时购物车有数据不为空，要合并
            // 此时在登录状态下，调用addToCart()一定会走登录的添加流程，直接添加即可
            for (CartItem item : tmpCartItems) {
                addToCart(item.getSkuId(), item.getCount());
            }
            // 清空临时购物车
            clearCart(tmpCartKey);
        }
        // 合并结束，取出数据
        String cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserId();
        List&lt;CartItem&gt; cartItems = getCartItems(cartKey);
        cart.setItems(cartItems);
    } else {
        // 没登陆
        String cartKey = CartConstant.CART_PREFIX + userInfoTo.getUserKey();
        List&lt;CartItem&gt; cartItems = getCartItems(cartKey);
        cart.setItems(cartItems);
    }
    return cart;
}
</code></pre>
<h2 id="购物车中的其他操作">购物车中的其他操作</h2>
<h3 id="选中购物项">选中购物项</h3>
<pre><code class="language-java">@Override
public void checkItem(Long skuId, Integer check) {
    BoundHashOperations&lt;String, Object, Object&gt; cartOps = getCartOps();
    //获取购物项并更改check状态
    CartItem cartItem = getCartItem(skuId);
    cartItem.setCheck(check == 1 ? true : false);
    String s = JSON.toJSONString(cartItem);
    cartOps.put(skuId.toString(), s);        
}
</code></pre>
<h3 id="改变购物项数量">改变购物项数量</h3>
<p>业务逻辑和上面基本一样，区别只在于修改数量项目。</p>
<h3 id="删除购物项">删除购物项</h3>
<p>逻辑更加简单，使用绑定hash的操作直接删除该项目即可</p>
<p>最终的实现效果：<br>
<img src="https://dxone1.github.io//post-images/1637981515113.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城项目 day15：认证服务]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day15ren-zheng-fu-wu/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day15ren-zheng-fu-wu/">
        </link>
        <updated>2021-11-22T02:54:30.000Z</updated>
        <content type="html"><![CDATA[<p>在登陆时需要通过认证服务获得可以使用部分业务功能的权限和用户的服务，这是系统必备的一项功能。一样的，首先创建一个认证的服务模块<code>mall-auth-server</code>，会集成社交登录，OAuth2.0，单点登录</p>
<h2 id="环境搭建">环境搭建</h2>
<ol>
<li>编排服务的host地址和Nginx、网关的转发</li>
<li>Nginx放置静态资源</li>
<li>controller的设置</li>
</ol>
<h2 id="手机验证码服务">手机验证码服务</h2>
<ol>
<li>验证码倒计时功能<br>
手机验证码遵循：发送验证码 -&gt; 倒计时 -&gt; 再次可以发送验证码的流程，实现使用js的倒计时器，当点击发送验证码时会将文本替换为<code>(倒计时时间) + 秒后可以再次发送</code>，同时标记一个<code>disabled</code>的class防止产生多个倒计时器。当倒计时到0时重置文本和最大倒计时。倒计时器一秒触发一次。</li>
</ol>
<pre><code class="language-js">$(function () {
    $(&quot;#sendCode&quot;).click(function () {
        //1.发送验证码
        // TODO
        //2.倒计时
        if(!$(this).hasClass(&quot;disabled&quot;)) {
            timeoutChangeStyle();
        }
    });
})

var num = 60;
function timeoutChangeStyle() {
    $(&quot;#sendCode&quot;).attr(&quot;class&quot;, &quot;disabled&quot;);
    if(num == 0) {
        $(&quot;#sendCode&quot;).text(&quot;发送验证码&quot;);
        num = 60;
        $(&quot;#sendCode&quot;).attr(&quot;class&quot;, &quot;&quot;);
    } else {
        var str = num+&quot;秒后可以再次发送&quot;;
        $(&quot;#sendCode&quot;).text(str);
        num--;
        setTimeout(&quot;timeoutChangeStyle()&quot;,1000);
    }
}
</code></pre>
<p>使用viewController实现视图解析跳转</p>
<pre><code class="language-java">@Configuration
public class MallWebConfig implements WebMvcConfigurer {
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController(&quot;/login.html&quot;).setViewName(&quot;login&quot;);
        registry.addViewController(&quot;/reg.html&quot;).setViewName(&quot;reg&quot;);        
    }
}
</code></pre>
<h2 id="短信验证码服务">短信验证码服务</h2>
<p>先在阿里云上购买一个短信接口服务，然后调试完成短信发送功能</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;spring.cloud.alicloud.sms&quot;)
@Data
@Component
public class SmsComponent {

    private String host;
    private String path;
    private String skin;
    private String appcode;

    public void sendSmsCode(String phone, String code) {
        String method = &quot;GET&quot;;
        System.out.println(&quot;请先替换成自己的AppCode&quot;);
        Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();
        headers.put(&quot;Authorization&quot;, &quot;APPCODE &quot; + appcode); //格式为:Authorization:APPCODE 83359fd73fe11248385f570e3c139xxx
        Map&lt;String, String&gt; querys = new HashMap&lt;String, String&gt;();
        querys.put(&quot;code&quot;, code);// !!! 请求参数
        querys.put(&quot;phone&quot;, phone);// !!! 请求参数
        querys.put(&quot;skin&quot;, skin);// !!! 请求参数
        try {
            HttpResponse response = HttpUtils.doGet(host, path, method, headers, querys);
            //System.out.println(response.toString()); //输出头部
            System.out.println(EntityUtils.toString(response.getEntity())); //输出json
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>需要注意的是，后端要进行验证并阻止反复刷验证，同时也要保存一定时间的验证码结果，这可以使用Redis实现</p>
<pre><code class="language-java">@ResponseBody
@GetMapping(&quot;/sms/sendcode&quot;)
public R sendCode(@RequestParam(&quot;phone&quot;) String phone) {
    // 1. 接口防刷
    String redisCode = redisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + phone);
    if(redisCode != null) {
        long l = Long.parseLong(redisCode.split(&quot;_&quot;)[1]);
        if (System.currentTimeMillis() - l &lt; 60000) {
            // 60秒内不能再发
            return R.error(BizCodeEnum.SMS_CODE_EXCEPTION.getCode(), BizCodeEnum.SMS_CODE_EXCEPTION.getMsg());
        }
    }

    String code = UUID.randomUUID().toString().substring(0, 6) + &quot;_&quot; + System.currentTimeMillis();
    // 2. 验证码再次校验: 存入redis缓存: key:phoneNum - value:code
    redisTemplate.opsForValue().set(AuthServerConstant.SMS_CODE_CACHE_PREFIX + phone, code, 20, TimeUnit.MINUTES);
    //实际接入短信验证码接口
    //thirdPartFeignService.sendCode(phone, code.split(&quot;_&quot;)[0]);
    // 测试
    System.out.println(&quot;phone:&quot; + phone + &quot; code:&quot; + code.split(&quot;_&quot;)[0]);
    return R.ok();
}
</code></pre>
<h2 id="注册功能">注册功能</h2>
<p>在注册页面的控制器如下，能够完成校验和错误封装功能，并调用远程服务实际完成注册。详细拆解这一部分的内容</p>
<h3 id="格式验证">格式验证</h3>
<p>需要对传递过来的注册信息进行格式验证，仍然使用JSR的标准注解，同时使用RedirectAttributes重定向后保存错误信息</p>
<pre><code class="language-java">if (result.hasErrors()) {
    // 验证出错转发到注册页
    Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
    result.getFieldErrors().stream().forEach(fieldError -&gt; {
        if (errors.containsKey(fieldError.getField()) &amp;&amp; errors.get(fieldError.getField()).contains(&quot;必须填写&quot;)) {

        } else {
            errors.put(fieldError.getField(), fieldError.getDefaultMessage());
        }
    });
    redirectAttributes.addFlashAttribute(&quot;errors&quot;, errors);
    return &quot;redirect:http://auth.mall.com/reg.html&quot;;
}
</code></pre>
<h3 id="验证码时效验证">验证码时效验证</h3>
<p>从Redis中取出缓存，查看是否失效和匹配</p>
<pre><code class="language-java">// 真正注册：远程服务注册
String code = vo.getCode();
String s = redisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + vo.getPhone());
if (!StringUtils.isEmpty(s) &amp;&amp; code.equals(s.split(&quot;_&quot;)[0])) {
    // 删除验证码，令牌机制
    redisTemplate.delete(AuthServerConstant.SMS_CODE_CACHE_PREFIX + vo.getPhone());
    // 验证码通过，远程注册

} else {
    HashMap&lt;String, String&gt; errors = new HashMap&lt;&gt;();
    errors.put(&quot;code&quot;, &quot;验证码错误&quot;);
    redirectAttributes.addFlashAttribute(&quot;errors&quot;, errors);
    return &quot;redirect:http://auth.mall.com/reg.html&quot;;
}

return &quot;redirect:/login.html&quot;;
</code></pre>
<h3 id="唯一性异常">唯一性异常</h3>
<p>当出现唯一性校验问题时直接由方法抛出异常，在controller接收数据后封装。</p>
<pre><code class="language-java">@Override
public void regist(MemberRegistVo vo) {
    MemberEntity memberEntity = new MemberEntity();

    // 设置为默认等级
    MemberLevelEntity levelEntity = memberLevelDao.getDefaultLevel();
    memberEntity.setLevelId(levelEntity.getId());

    // 设置
    // 唯一性校验 - 使用异常机制
    checkPhoneUnique(vo.getPhone());
    checkPhoneUnique(vo.getUserName());

    memberEntity.setMobile(vo.getPhone());
    memberEntity.setUsername(vo.getUserName());

    // 密码保存：使用MD5加密存储密码


    baseMapper.insert(memberEntity);
}


@Override
public void checkPhoneUnique(String phone) throws PhoneExistsException {
    Integer count = this.baseMapper.selectCount(new QueryWrapper&lt;MemberEntity&gt;().eq(&quot;mobile&quot;, phone));
    if(count &gt; 0) {
        throw new PhoneExistsException();
    }
}

@Override
public void checkUsernameUnique(String username) throws UsernameExistsException {
    Integer count = this.baseMapper.selectCount(new QueryWrapper&lt;MemberEntity&gt;().eq(&quot;username&quot;, username));
    if(count &gt; 0) {
        throw new UsernameExistsException();
    }
}
</code></pre>
<p>Controller的异常处理</p>
<pre><code class="language-java">@PostMapping(&quot;/regist&quot;)
public R regist(@RequestBody MemberRegistVo vo) {
    try {
        memberService.regist(vo);
    } catch (PhoneExistsException e) {
        return R.error(BizCodeEnum.PHONE_EXIST_EXCEPTION.getCode(), BizCodeEnum.PHONE_EXIST_EXCEPTION.getMsg());
    } catch (UsernameExistsException e) {
        return R.error(BizCodeEnum.USER_EXIST_EXCEPTION.getCode(), BizCodeEnum.USER_EXIST_EXCEPTION.getMsg())
    }
    return R.ok();
}
</code></pre>
<h3 id="md5盐值加密">MD5盐值加密</h3>
<p>MD5是一种不可逆的明文加密手段，但是如果直接加密很有可能通过暴力枚举的数据库查询到。使用盐值加密增加了一个扰动使得破解变得困难无比。Spring提供了一个封装</p>
<pre><code class="language-java">@Test
public void contextLoads() {
    BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
    String encode = passwordEncoder.encode(&quot;123456&quot;);
    boolean matches = passwordEncoder.matches(&quot;123456&quot;, &quot;$2a$10$dAr8XERaa3rX3qt3dkBp4uzoRkPHIOn4dS2DkcaA3niFs4A9CKkPe&quot;);
    System.out.println(matches);
}
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1637587348313.png" alt="" loading="lazy"><br>
完整版Controller</p>
<pre><code class="language-java">@PostMapping(&quot;/regist&quot;)
public String regist(@Valid UserRegistVo vo, BindingResult result, RedirectAttributes redirectAttributes) {
    if (result.hasErrors()) {
        // 验证出错转发到注册页
        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
        result.getFieldErrors().stream().forEach(fieldError -&gt; {
            if (errors.containsKey(fieldError.getField()) &amp;&amp; errors.get(fieldError.getField()).contains(&quot;必须填写&quot;)) {

            } else {
                errors.put(fieldError.getField(), fieldError.getDefaultMessage());
            }
        });
        redirectAttributes.addFlashAttribute(&quot;errors&quot;, errors);
        return &quot;redirect:http://auth.mall.com/reg.html&quot;;
    }
    // 真正注册：远程服务注册
    String code = vo.getCode();
    String s = redisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + vo.getPhone());
    if (!StringUtils.isEmpty(s) &amp;&amp; code.equals(s.split(&quot;_&quot;)[0])) {
        // 删除验证码，令牌机制
        redisTemplate.delete(AuthServerConstant.SMS_CODE_CACHE_PREFIX + vo.getPhone());
        // 验证码通过，远程注册

        R r = memberFeignService.regist(vo);
        if(r.getCode() == 0) {
            // 成功
            return &quot;redirect:http://auth.mall.com/login.html&quot;;
        } else {
            Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
            errors.put(&quot;msg&quot;, r.getData(&quot;msg&quot;, new TypeReference&lt;String&gt;(){}));
            redirectAttributes.addFlashAttribute(&quot;errors&quot;, errors);
            return &quot;redirect:http://auth.mall.com/reg.html&quot;;
        }
    } else {
        HashMap&lt;String, String&gt; errors = new HashMap&lt;&gt;();
        errors.put(&quot;code&quot;, &quot;验证码错误&quot;);
        redirectAttributes.addFlashAttribute(&quot;errors&quot;, errors);
        return &quot;redirect:http://auth.mall.com/reg.html&quot;;
    }
}
</code></pre>
<p>注册成功会跳转到登录页，否则回到注册页并显示问题</p>
<h2 id="账号密码登录">账号密码登录</h2>
<pre><code class="language-java">@Override
public MemberEntity login(MemberLoginVo vo) {
    String loginacct = vo.getLoginacct();
    String password = vo.getPassword();

    // 1. 去数据库查询密码
    MemberEntity entity = baseMapper.selectOne(new QueryWrapper&lt;MemberEntity&gt;().eq(&quot;username&quot;, loginacct).or().eq(&quot;mobile&quot;, loginacct));
    if(entity == null) {
        return null;
    } else {
        String passwordDb = entity.getPassword();
        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
        // 2. 密码匹配
        if (passwordEncoder.matches(password, passwordDb)) {
            return entity;
        } else {
            return null;
        }
    }
}
</code></pre>
<h2 id="社交登录">社交登录</h2>
<ul>
<li>OAuth（开放授权） 是一个开放标准， 允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息， 而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。</li>
<li>OAuth2.0： 对于用户相关的 OpenAPI（例如获取用户信息， 动态同步， 照片， 日志， 分享等） ， 为了保护用户数据的安全和隐私， 第三方网站访问用户数据前都需要显式的向用户征求授权<br>
<img src="https://dxone1.github.io//post-images/1637643932048.png" alt="" loading="lazy"></li>
</ul>
<h3 id="接入微博第三方登录">接入微博第三方登录</h3>
<p>先在微博开放平台创建账号、应用并填写相关信息<br>
<img src="https://dxone1.github.io//post-images/1637742996836.png" alt="" loading="lazy"></p>
<ol>
<li>当点击微博登陆时，跳转到如下超链接</li>
</ol>
<pre><code class="language-java">https://api.weibo.com/oauth2/authorize?client_id=YOUR_CLIENT_ID&amp;response_type=code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI
</code></pre>
<ol start="2">
<li>成功授权后会跳转到指定成功回调页面，同时返回code</li>
</ol>
<pre><code class="language-java">http://mall.com/success?code=197c0fba7cf6066ef5dc7cac1aed1289
</code></pre>
<ol start="3">
<li>使用code到如下地址换取access Token</li>
</ol>
<pre><code class="language-java">https://api.weibo.com/oauth2/access_token?client_id=YOUR_CLIENT_ID&amp;client_secret=YOUR_CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=YOUR_REGISTERED_REDIRECT_URI&amp;code=CODE
</code></pre>
<ol start="4">
<li>使用AccessToken获取weibo的各类型开放数据</li>
<li>获取当前用户的id，查询是否已经注册。已经注册的登录，否则新建一个默认账号</li>
</ol>
<pre><code class="language-java">@Override
public MemberEntity login(SocialUser socialUser) throws Exception {
    // 登录和注册两个逻辑
    MemberEntity memberEntity = baseMapper.selectOne(new QueryWrapper&lt;MemberEntity&gt;().eq(&quot;social_uid&quot;, socialUser.getUid()));
    if (memberEntity != null) {
        //已经注册了
        //更新数据库
        MemberEntity update = new MemberEntity();
        update.setId(memberEntity.getId());
        update.setAccessToken(socialUser.getAccess_token());
        update.setExpiresIn(socialUser.getExpires_in());
        baseMapper.updateById(update);
        //返回
        memberEntity.setAccessToken(socialUser.getAccess_token());
        memberEntity.setExpiresIn(socialUser.getExpires_in());
        return memberEntity;
    } else {
        MemberEntity regist = new MemberEntity();
        try {
            // 查询社交帐号信息（昵称，性别等）
            Map&lt;String, String&gt; query = new HashMap&lt;&gt;();
            query.put(&quot;access_token&quot;, socialUser.getAccess_token());
            query.put(&quot;uid&quot;, socialUser.getUid());
            HttpResponse response = HttpUtils.doGet(&quot;https://api.weibo.com&quot;, &quot;/2/users/show.json&quot;, &quot;get&quot;, new HashMap&lt;String, String&gt;(), query);
            if (response.getStatusLine().getStatusCode() == 200) {
                //成功
                String json = EntityUtils.toString(response.getEntity());
                JSONObject jsonObject = JSON.parseObject(json);
                String name = jsonObject.getString(&quot;name&quot;);
                String gender = jsonObject.getString(&quot;gender&quot;);
                regist.setNickname(name);
                if (gender != null) {
                    regist.setGender(&quot;m&quot;.equals(gender) ? 1 : 0);
                }
            }
        } catch (Exception e) {
            
        }
        regist.setSocialIUid(socialUser.getUid());
        regist.setAccessToken(socialUser.getAccess_token());
        regist.setExpiresIn(socialUser.getExpires_in());
        
        baseMapper.insert(regist);
        return regist;
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1637818018183.png" alt="" loading="lazy"></figure>
<h2 id="分布式session">分布式Session</h2>
<p>如果想使用Session在分布式系统中就必须解决分布式Session的问题</p>
<ul>
<li>如果是同个服务的集群，那么就必须解决共享问题</li>
<li>如果要在服务之间共享session，就需要互通</li>
</ul>
<ol>
<li>Session复制<br>
tomcat原生支持，只需要修改配置文件即可。然而其会占用大量的带宽，会降低业务处理能力。</li>
<li>客户端存储<br>
用户自己保存session信息到cookie中，然而安全信很低，也很消耗带宽。http请求能保存的信息也不多。</li>
<li>使用Hash一致性<br>
负载均衡使只有固定的服务器服务同一个ip。</li>
<li>统一Session存储<br>
<img src="https://dxone1.github.io//post-images/1637761441421.png" alt="" loading="lazy"><br>
子域session共享：<br>
第一次使用session会命令浏览器保存JSESSIONID的cookie，此后访问那个网站都会带上cookie<br>
子域之间共享seesion的cookie，则需要在设置JSESSIONID时将domain扩大（域扩大为它们的父）。</li>
</ol>
<h3 id="spring-session">Spring Session</h3>
<p>spring Session基于统一Session存储解决session共享问题，使用resdis担任session存储。</p>
<ol>
<li>导入依赖</li>
<li>在配置类上添加@EnableRedisHttpSession注解，开启基于Redis的HttpSession功能</li>
<li>需要更改SESSION的Domain为父域，这样同一个父域下的服务才能共享同一组SESSION。</li>
<li>在mall-product服务下的首页通过取出session的内容即可知道当前用户的id等信息。<br>
需要解决两个问题：</li>
</ol>
<ul>
<li>改变SESSION的作用域</li>
<li>改变序列化机制为JSON</li>
</ul>
<h3 id="修改cookie的作用域">修改cookie的作用域</h3>
<p>参考文档，在容器中放置一个CookieSerializer。</p>
<pre><code class="language-java">@Configuration
public class MallSessionConfig {
    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();
        cookieSerializer.setDomainName(&quot;mall.com&quot;);
        cookieSerializer.setCookieName(&quot;MALLSESSION&quot;);
        return cookieSerializer;
    }
}
</code></pre>
<h3 id="使用json序列化的redis-spring-session">使用JSON序列化的Redis Spring Session</h3>
<p>参考官方文档，在容器中添加一个RedisSerializer</p>
<pre><code class="language-java">@Bean
public RedisSerializer&lt;Object&gt; springSessionDefaultRedisSerializer() {
    return new GenericJackson2JsonRedisSerializer();
}
</code></pre>
<p>成功实现了跨域、跨服务的分布式Session登录效果<br>
<img src="https://dxone1.github.io//post-images/1637818316762.png" alt="" loading="lazy"></p>
<h3 id="spring-session的原理">Spring Session的原理</h3>
<p>@EnableRedisHttpSession添加了</p>
<ul>
<li>RedisOperationSessionRepository的组件，是Session的增删改查的封装类。</li>
<li>SessionRepositoryFilter，过滤每一个Http的请求。</li>
</ul>
<p>一旦创建 SessionRepositoryFilter就要组合一个SessionRepository，执行doFilter会：</p>
<ul>
<li>先设置当前请求的Session操作实例</li>
<li>将原生请求包装成适配的形式</li>
<li>使用过滤器链（职责链模式）执行包装请求<br>
<img src="https://dxone1.github.io//post-images/1637832139052.png" alt="" loading="lazy"><br>
原因在于：<br>
原生的session通过如下方法获取：</li>
</ul>
<pre><code class="language-java">HttpSession session = request.getSession();
</code></pre>
<p>而在这个拦截器中将原生的Request包装了。那么以后调用<code>session.getSession()</code>调用的就是SessionRepositoryRequestWrapper的方法：</p>
<pre><code class="language-java">@Override
public HttpSessionWrapper getSession(boolean create) {
    HttpSessionWrapper currentSession = getCurrentSession();
    if (currentSession != null) {
        return currentSession;
    }
    S requestedSession = getRequestedSession();
    if (requestedSession != null) {
        if (getAttribute(INVALID_SESSION_ID_ATTR) == null) {
            requestedSession.setLastAccessedTime(Instant.now());
            this.requestedSessionIdValid = true;
            currentSession = new HttpSessionWrapper(requestedSession, getServletContext());
            currentSession.setNew(false);
            setCurrentSession(currentSession);
            return currentSession;
        }
    }
    else {
        // This is an invalid session id. No need to ask again if
        // request.getSession is invoked for the duration of this request
        if (SESSION_LOGGER.isDebugEnabled()) {
            SESSION_LOGGER.debug(
                    &quot;No session found by id: Caching result for getSession(false) for this HttpServletRequest.&quot;);
        }
        setAttribute(INVALID_SESSION_ID_ATTR, &quot;true&quot;);
    }
    if (!create) {
        return null;
    }
    if (SESSION_LOGGER.isDebugEnabled()) {
        SESSION_LOGGER.debug(
                &quot;A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for &quot;
                        + SESSION_LOGGER_NAME,
                new RuntimeException(
                        &quot;For debugging purposes only (not an error)&quot;));
    }
    S session = SessionRepositoryFilter.this.sessionRepository.createSession();
    session.setLastAccessedTime(Instant.now());
    currentSession = new HttpSessionWrapper(session, getServletContext());
    setCurrentSession(currentSession);
    return currentSession;
}
</code></pre>
<p>是使用SessionRepository中获取的，而这里的实现是RedisOperationSessionRepository，故是通过Redis获取的。使用了装饰者模式。</p>
<h2 id="单点登录">单点登录</h2>
<p>多系统场景中，希望不同系统之间可以统一的进行认证。而在这个场景中最多将域名放大至一级域名，这会导致多系统间无法共享session而难以完成共享登录信息的业务功能。<br>
使用gitee的单点登录框架即可实现在一个统一认证中心登录之后处处都可以登录的效果。<br>
系统流程：</p>
<ol>
<li>client1进入服务时要求登录，跳转到登录服务器，在参数中带上url</li>
<li>服务器得到登录请求，将url封装到model中传递给页面</li>
<li>页面得到url和相关登录参数，返回controller，验证是否登录成功。如果成功则添加用户信息到redis中，同时将key作为令牌回传给登录发起服务页，这个页面是一路传递的url</li>
<li>登录发起页判断token是否成功获取，并以此得到用户信息。</li>
<li>通过添加一个cookie标记浏览器，则同浏览器都可以获取单点登录的sso_token。于是只要一个页面登录成功过凡是访问到登录页面都可以发现这里有一个sso_token的cookie。</li>
<li>在登录页一开始就判断：如果有sso_token这个cookie则直接返回，否则再进行登录流程。</li>
</ol>
<p>服务器：</p>
<pre><code class="language-java">@Controller
public class LoginController {

    @ResponseBody
    @GetMapping(&quot;/userInfo&quot;)
    public String userInfo(@RequestParam(&quot;token&quot;) String token) {
        String s = redisTemplate.opsForValue().get(token);
        return s;
    }

    @Autowired
    StringRedisTemplate redisTemplate;

    @PostMapping(&quot;/doLogin&quot;)
    public String doLogin(@RequestParam(&quot;username&quot;) String username,
                          @RequestParam(&quot;password&quot;) String password,
                          @RequestParam(&quot;url&quot;) String url,
                          HttpServletResponse response) {


        if (!StringUtils.isEmpty(username) &amp;&amp; !StringUtils.isEmpty(password)) {
            // 认为登录成功

            String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
            // 保存到redis中，标记登录成功
            redisTemplate.opsForValue().set(uuid, username);
            // 保存到session中，单点登录
            Cookie sso_token = new Cookie(&quot;sso_token&quot;, uuid);
            response.addCookie(sso_token);
            return &quot;redirect:&quot; + url + &quot;?token=&quot; + uuid;
        } else {
            return &quot;redirect:http://sso.com:8080/login?redirect_url=&quot; + url;
        }
    }

    @GetMapping(&quot;/login&quot;)
    public String loginPage(@RequestParam(&quot;redirect_url&quot;) String url,
                            Model model,
                            @CookieValue(value = &quot;sso_token&quot;, required = false) String sso_token) {
        //说明以前已经登录过了！
        if (!StringUtils.isEmpty(sso_token)) {
            return &quot;redirect:&quot; + url + &quot;?token=&quot; + sso_token;
        }
        model.addAttribute(&quot;url&quot;, url);
        return &quot;login&quot;;
    }
}
</code></pre>
<p>服务器页面</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/doLogin&quot; method=&quot;post&quot;&gt;
    姓名：&lt;input name=&quot;username&quot;/&gt;&lt;/br&gt;
    密码：&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/br&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;url&quot; th:value=&quot;${url}&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;提交&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>单点登录发起控制器</p>
<pre><code class="language-java">@Controller
public class HelloController {

    @Value(&quot;${sso.server.url}&quot;)
    String ssoServerUrl;

    @ResponseBody
    @GetMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;hello&quot;;
    }

    @GetMapping(&quot;/employees&quot;)
    public String employees(Model model, HttpSession session, @RequestParam(value = &quot;token&quot;, required = false) String token) {
        if(!StringUtils.isEmpty(token)) {
            //认为登录成功
            RestTemplate restTemplate = new RestTemplate();
            ResponseEntity&lt;String&gt; forEntity = restTemplate.getForEntity(&quot;http://sso.com:8080/userInfo?token=&quot; + token, String.class);
            String body = forEntity.getBody();
            session.setAttribute(&quot;loginUser&quot;, body);
        }

        Object loginUser = session.getAttribute(&quot;loginUser&quot;);
        if(loginUser == null) {
            //未登录，跳转到登录服务器登录
            //带上参数标识回跳页面
            return &quot;redirect:&quot; + ssoServerUrl+&quot;?redirect_url=http://client2.com:8081/employees&quot;;
        } else {
            List&lt;String&gt; emps = new ArrayList&lt;&gt;();
            emps.add(&quot;张三&quot;);
            emps.add(&quot;李四&quot;);
            model.addAttribute(&quot;emps&quot;, emps);
            return &quot;list&quot;;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城项目 day14：异步处理]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day14yi-bu-chu-li/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day14yi-bu-chu-li/">
        </link>
        <updated>2021-11-20T11:58:30.000Z</updated>
        <content type="html"><![CDATA[<p>实现异步处理的商品详情页功能</p>
<h2 id="来源">来源</h2>
<p>商品详情页往往需要远程调用，数据库查询等多种操作。在IO操作上阻塞显然不是好的主意。于是需要进行异步编排。具体的，有如下渲染和获取步骤：</p>
<ol>
<li>商品详情</li>
<li>同种商品不同的SKU信息</li>
<li>SPU信息</li>
<li>库存信息</li>
<li>优惠信息</li>
<li>...<br>
可以看到找出哪一种商品是最先需要做的，可以使用ComplateableFuture实现异步任务的同步和管理。</li>
</ol>
<h2 id="实现">实现</h2>
<p>同样配置好一个item.mall.com的本地Hosts，因为Nginx已经匹配了*.mall.com的路径跳转至网关，所以只需要配置网关路由即可。</p>
<ol>
<li>编写一个Controller，返回跳转到item页面</li>
<li>封装一个SkuItemVo的对象，用于封装需要返回给页面的数据</li>
</ol>
<pre><code class="language-java">@Data
public class SkuItemVo {
    //基本sku信息
    SkuInfoEntity info;
    //sku的图片
    List&lt;SkuImagesEntity&gt; images;
    //sku的各种销售属性的集合
    List&lt;SkuItemSaleAttrVo&gt; saleAttr;
    //spu的商品介绍
    SpuInfoDescEntity desp;
    //spu的基本信息分组集合
    List&lt;SpuItemAttrGroupVo&gt; groupAttrs;

    @Data
    public static class SkuItemSaleAttrVo {
        private Long attrId;
        private String attrName;
        private List&lt;String&gt; attrValues;
    }

    @Data
    public static class SpuItemAttrGroupVo {
        private String groupName;
        private List&lt;SpuBaseAttrVo&gt; attrs;
    }

    @Data
    public static class SpuBaseAttrVo {
        private Long attrId;
        private String attrValues;
    }
}
</code></pre>
<ol start="3">
<li>封装这个对象的业务代码编写<br>
业务上都是与之前的大同小异，关键在于异步编排<br>
异步之前也可以实现业务，如下：</li>
</ol>
<pre><code class="language-java">@Override
public SkuItemVo item(Long skuId) {
    SkuItemVo skuItemVo = new SkuItemVo();
    
    // 1. pms_sku_inf
    SkuInfoEntity info = this.getById(skuId);
    Long catalogId = info.getCatalogId();
    Long spuId = info.getSpuId();
    skuItemVo.setInfo(info);

    // 2. pms_sku_images
    List&lt;SkuImagesEntity&gt; images = skuImagesService.getImagesBySkuId(skuId);
    skuItemVo.setImages(images);

    // 3. spu的销售属性组合
    List&lt;SkuItemSaleAttrVo&gt; saleAttrVos = skuSaleAttrValueService.getSaleAttrsBySpuId(spuId);
    skuItemVo.setSaleAttr(saleAttrVos);

    // 4. spu的介绍
    SpuInfoDescEntity spuInfoDesc = spuInfoDescService.getById(spuId);
    skuItemVo.setDesp(spuInfoDesc);

    // 5. spu的规格参数信息
    List&lt;SpuItemAttrGroupVo&gt; attrGroupVos = attrGroupService.getAttrGroupWithAttrsBySpuId(spuId, catalogId);
    skuItemVo.setGroupAttrs(attrGroupVos);

    return skuItemVo;
}
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1637501476084.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1637501479800.png" alt="" loading="lazy"><br>
<strong>使用异步方式进行</strong><br>
1，2相互独立<br>
3，4，5依赖于1的查询结果</p>
<ol>
<li>首先放一个单例的可配置线程池</li>
</ol>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;mall.thread&quot;)
@Data
public class ThreadPollConfigProperties {
    private Integer coreSize;
    private Integer maxSize;
    private Integer keepAliveTime;
}

/********************/
@EnableConfigurationProperties(ThreadPollConfigProperties.class)
@Configuration
public class MyThreadConfig {
    @Bean
    public ThreadPoolExecutor threadPoolExecutor(ThreadPollConfigProperties pool) {
        return new ThreadPoolExecutor(pool.getCoreSize(),
                pool.getMaxSize(),
                pool.getKeepAliveTime(),
                TimeUnit.SECONDS,
                new LinkedBlockingDeque&lt;&gt;(100000),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy());
    }
}
</code></pre>
<p>修改为异步方式执行后端逻辑</p>
<pre><code class="language-java">@Override
public SkuItemVo item(Long skuId) throws ExecutionException, InterruptedException {
    SkuItemVo skuItemVo = new SkuItemVo();

    CompletableFuture&lt;SkuInfoEntity&gt; infoFuture = CompletableFuture.supplyAsync(() -&gt; {
        // 1. pms_sku_info
        SkuInfoEntity info = getById(skuId);
        skuItemVo.setInfo(info);
        return info;
    }, executor);

    CompletableFuture&lt;Void&gt; saleAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; {
        // 3. spu的销售属性组合
        List&lt;SkuItemSaleAttrVo&gt; saleAttrVos = skuSaleAttrValueService.getSaleAttrsBySpuId(res.getSpuId());
        skuItemVo.setSaleAttr(saleAttrVos);
    }, executor);

    CompletableFuture&lt;Void&gt; descFuture = infoFuture.thenAcceptAsync((res) -&gt; {
        // 4. spu的介绍
        SpuInfoDescEntity spuInfoDesc = spuInfoDescService.getById(res.getSpuId());
        skuItemVo.setDesp(spuInfoDesc);
    }, executor);

    CompletableFuture&lt;Void&gt; baseAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; {
        // 5. spu的规格参数信息
        List&lt;SpuItemAttrGroupVo&gt; attrGroupVos = attrGroupService.getAttrGroupWithAttrsBySpuId(res.getSpuId(), res.getCatalogId());
        skuItemVo.setGroupAttrs(attrGroupVos);
    }, executor);

    CompletableFuture&lt;Void&gt; imagesFuture = CompletableFuture.runAsync(() -&gt; {
        // 2. pms_sku_images
        List&lt;SkuImagesEntity&gt; images = skuImagesService.getImagesBySkuId(skuId);
        skuItemVo.setImages(images);
    }, executor);

    CompletableFuture.allOf(saleAttrFuture, descFuture, baseAttrFuture, imagesFuture).get();

    return skuItemVo;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城服务 day13：检索服务]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-fu-wu-day13jian-suo-fu-wu/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-fu-wu-day13jian-suo-fu-wu/">
        </link>
        <updated>2021-11-18T08:50:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="搭建页面">搭建页面</h2>
<p>之前的布置已经完成了后台系统上架商品到ES的业务，现在需要检索商品的业务。仍然采用Nginx动静分离的模式</p>
<ol>
<li>在nginx中配置所有*.mall.com和mall.com都发送到网关</li>
<li>我们设定所有search.mall.com为搜索服务，在html/static/search中放置了其静态资源</li>
<li>设定网关的转发</li>
</ol>
<pre><code class="language-yaml">- id: mall_search_route
    uri: lb://mall-search
    # 使用Host域名方式进行路由：任意mall.com旗下的全部路由给mall-product
    predicates:
    - Host=search.mall.com
</code></pre>
<h2 id="进入页面">进入页面</h2>
<ol>
<li>三级分类进入</li>
<li>检索框检索</li>
<li>选择筛选条件进入<br>
<strong>封装查询参数：</strong></li>
</ol>
<pre><code class="language-java">@Data
public class SearchParam {

    private String keyword;
    private Long catalog3Id;

    /**
     * 排序条件
     * sort=saleCount_asc/desc
     * sort=skuPrice_asc/desc
     * sort=hotScore_asc/desc
     */
    private String sort;

    /**
     * 过滤条件
     * hasStock=0/1
     * skuPrice=1_500/_500/500_
     * brandId
     * attrs：属性值
     * attrs=1_其他:安卓&amp;attrs=2_5寸:6寸
     */
    private Integer hasStock; // 有货
    private String skuPrice; // 价格区间
    private List&lt;Long&gt; brandId;
    private List&lt;String&gt; attrs;

    private Integer pageNum; //页面号

}
</code></pre>
<p><strong>封装搜索返回</strong></p>
<pre><code class="language-java">@Data
public class SearchResult {
    //查询到的所有商品信息
    private List&lt;SkuEsModel&gt; products;
    //分页信息
    private Integer pageNum;
    private Long total;
    private Integer totalPages;
    //当前查询到的结果中所有涉及的品牌
    private List&lt;BrandVo&gt; brands;
    //当前查询到的结果中所有涉及的分类
    private List&lt;CatalogVo&gt; catalogs;
    //当前查询到的结果中所有涉及的属性
    private List&lt;AttrVo&gt; attrs;

    @Data
    public static class BrandVo {
        private Long brandId;
        private String brandName;
        private String brandImg;
    }

    @Data
    public static class AttrVo {
        private Long attrId;
        private String attrName;
        private List&lt;String&gt; attrValue;
    }

    @Data
    public static class CatalogVo {
        private Long catalogId;
        private String catalogName;
    }
}
</code></pre>
<h2 id="es查询业务">ES查询业务</h2>
<p>主要有以下三块：</p>
<ol>
<li>must模糊匹配titile，过滤（按照属性，品牌，分类，价格区间，库存）</li>
<li>排序，分页，高亮</li>
<li>聚合分析</li>
</ol>
<h3 id="动态构建dsl语句">动态构建DSL语句</h3>
<p>逻辑：自动注入一个RestHighLevelClient，client可以执行search等操作。执行search操作要放一个SearchRequest，而SearchRequest由SourceBuilder构建。SourceBuilder在执行query查询时使用QueryBuilder。</p>
<pre><code class="language-java">/**
    * 准备检索请求
    * @return
    */
private SearchRequest buildSearchRequest(SearchParam param) {
    // sourceBuilder构建请求
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    /**
        * must模糊匹配，过滤（按照属性，品牌，分类，价格区间，库存）
        */
    //1.构建bool queryBuilder
    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
    //1.1 must: 匹配skuTitle
    if(!StringUtils.isEmpty(param.getKeyword())) {
        boolQuery.must(QueryBuilders.matchQuery(&quot;skuTitle&quot;, param.getKeyword()));
    }
    //1.2 filter: 三级分类ID
    if(param.getCatalog3Id() != null) {
        boolQuery.filter(QueryBuilders.termQuery(&quot;catalogId&quot;, param.getCatalog3Id()));
    }
    //1.2 filter: brandId
    if(param.getBrandId() != null &amp;&amp; param.getBrandId().size() &gt; 0) {
        boolQuery.filter(QueryBuilders.termsQuery(&quot;brandId&quot;, param.getBrandId()));
    }
    //1.2 filter: attrs nested查询
    if(param.getAttrs() != null &amp;&amp; param.getAttrs().size() &gt; 0) {
        //形如 attr=1_5寸:6寸&amp;attr=2_16GB:8GB
        for (String attr : param.getAttrs()) {
            // 每个属性开始一个bool查询
            BoolQueryBuilder nestedBoolQuery = QueryBuilders.boolQuery();
            String[] s = attr.split(&quot;_&quot;);
            String attrId = s[0];
            String[] attrValues = s[1].split(&quot;:&quot;);
            nestedBoolQuery.must(QueryBuilders.termsQuery(&quot;attrs.attrId&quot;, attrId));
            nestedBoolQuery.must(QueryBuilders.termsQuery(&quot;attrs.attrValue&quot;, attrValues));
            // 构建nested查询
            NestedQueryBuilder nestedQuery = QueryBuilders.nestedQuery(&quot;attrs&quot;, nestedBoolQuery, ScoreMode.None);
            boolQuery.filter(nestedQuery);
        }
    }
    //1.2 filter: hasStock
    boolQuery.filter(QueryBuilders.termQuery(&quot;hasStock&quot;, param.getHasStock() == 1));
    //1.2 filter: 价格区间
    if(!StringUtils.isEmpty(param.getSkuPrice())) {
        RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery(&quot;skuPrice&quot;);
        if (param.getSkuPrice().startsWith(&quot;_&quot;)) {
            rangeQuery.lte(param.getSkuPrice().substring(1));
        } else if (param.getSkuPrice().endsWith(&quot;_&quot;)) {
            rangeQuery.gte(param.getSkuPrice().substring(0, param.getSkuPrice().length() - 1));
        } else {
            String[] s = param.getSkuPrice().split(&quot;_&quot;);
            rangeQuery.gte(s[0]).lt(s[1]);
        }
        boolQuery.filter(rangeQuery);
    }
    //查询的语句构建完成
    sourceBuilder.query(boolQuery);

    /**
        * 排序，分页，高亮
        * sort=saleCount_asc/desc
        * sort=skuPrice_asc/desc
        * sort=hotScore_asc/desc
        */
    //2.1 排序
    if(!StringUtils.isEmpty(param.getSort())) {
        String sort = param.getSort();
        String[] s = sort.split(&quot;_&quot;);
        SortOrder order = &quot;asc&quot;.equalsIgnoreCase(s[1])? SortOrder.ASC: SortOrder.DESC;
        sourceBuilder.sort(s[0], order);
    }
    //2.2 分页
    sourceBuilder.from((param.getPageNum() - 1) * EsConstant.PRODUCT_PAGESIZE);
    sourceBuilder.size(EsConstant.PRODUCT_PAGESIZE);
    //2.3 高亮
    if(!StringUtils.isEmpty(param.getKeyword())) {
        HighlightBuilder highlightBuilder = new HighlightBuilder();
        highlightBuilder.field(&quot;skuTitle&quot;);
        highlightBuilder.preTags(&quot;&lt;b style='color:red'&gt;&quot;);
        highlightBuilder.postTags(&quot;&lt;/b&gt;&quot;);
        sourceBuilder.highlighter(highlightBuilder);
    }

    /**
        * 聚合分析
        */
    //1.聚合品牌
    TermsAggregationBuilder brand_agg = AggregationBuilders.terms(&quot;brand_agg&quot;);
    brand_agg.field(&quot;brandId&quot;).size(50);
    // 品牌子聚合（brandName, brandImg）
    brand_agg.subAggregation(AggregationBuilders.terms(&quot;brand_name_agg&quot;).field(&quot;brandName&quot;).size(1));
    brand_agg.subAggregation(AggregationBuilders.terms(&quot;brand_img_agg&quot;).field(&quot;brandImg&quot;).size(1));
    sourceBuilder.aggregation(brand_agg);

    //2.聚合分类信息
    TermsAggregationBuilder catalog_agg = AggregationBuilders.terms(&quot;catalog_agg&quot;);
    catalog_agg.field(&quot;catalogId&quot;).size(20);
    // 子聚合
    catalog_agg.subAggregation(AggregationBuilders.terms(&quot;catalog_name_agg&quot;).field(&quot;catalogName&quot;).size(1));
    sourceBuilder.aggregation(catalog_agg);

    //3. 属性聚合
    /**
        * attr_agg
        *  |_ attr_id_agg  所有属性的id
        *      |_attr_name_agg 属性名
        *      |_attr_value_agg 属性的所有可能取值
        */
    NestedAggregationBuilder attr_agg = AggregationBuilders.nested(&quot;attr_agg&quot;, &quot;attrs&quot;);
    TermsAggregationBuilder attr_id_agg = AggregationBuilders.terms(&quot;attr_id_agg&quot;).field(&quot;attrs.attrId&quot;);

    attr_id_agg.subAggregation(AggregationBuilders.terms(&quot;attr_name_agg&quot;).field(&quot;attrs.attrName&quot;).size(1));
    attr_id_agg.subAggregation(AggregationBuilders.terms(&quot;attr_value_agg&quot;).field(&quot;attrs.attrValue&quot;).size(50));

    attr_agg.subAggregation(attr_id_agg);
    sourceBuilder.aggregation(attr_agg);

    String s = sourceBuilder.toString();
    System.out.println(&quot;DSL语句：&quot; + s);
    SearchRequest searchRequest = new SearchRequest(new String[]{EsConstant.PRODUCT_INDEX}, sourceBuilder);
    return searchRequest;
}
</code></pre>
<h3 id="返回结果的封装">返回结果的封装</h3>
<p>最终封装成我们自定义的VO：SearchResult，封装属性例子如下：<br>
<img src="https://dxone1.github.io//post-images/1637314023037.png" alt="" loading="lazy"></p>
<pre><code class="language-java">/**
    * 构建结果数据
    * @param response
    * @return
    */
private SearchResult buildSearchResult(SearchResponse response, SearchParam param) {

    SearchResult result = new SearchResult();
    SearchHits hits = response.getHits();

    /******来自查询信息*******/
    ////1. 封装查询的所有商品
    List&lt;SkuEsModel&gt; products = new ArrayList&lt;&gt;();
    if(hits.getHits() != null &amp;&amp; hits.getHits().length &gt; 0) {
        for (SearchHit hit : hits.getHits()) {
            String sourceAsString = hit.getSourceAsString();
            SkuEsModel esModel = JSON.parseObject(sourceAsString, SkuEsModel.class);
            if(!StringUtils.isEmpty(param.getKeyword())) {
                HighlightField skuTitle = hit.getHighlightFields().get(&quot;skuTitle&quot;);
                String string = skuTitle.getFragments()[0].string();
                esModel.setSkuTitle(string);
            }
            products.add(esModel);
        }
    }
    result.setProducts(products);

    /******来自聚合信息*******/
    Aggregations aggregations = response.getAggregations();
    //2. 封装所有商品涉及的所有属性
    ParsedNested attr_agg = aggregations.get(&quot;attr_agg&quot;);
    // 属性id聚合
    ParsedLongTerms attr_id_agg = attr_agg.getAggregations().get(&quot;attr_id_agg&quot;);
    List&lt;SearchResult.AttrVo&gt; attrVos = new ArrayList&lt;&gt;();
    for (Terms.Bucket bucket : attr_id_agg.getBuckets()) {
        SearchResult.AttrVo attrVo = new SearchResult.AttrVo();
        // 属性id
        long attrId = bucket.getKeyAsNumber().longValue();
        // 属性名
        ParsedStringTerms attr_name_agg = bucket.getAggregations().get(&quot;attr_name_agg&quot;);
        String attrName = attr_name_agg.getBuckets().get(0).getKeyAsString();
        // 属性所有值
        ParsedStringTerms attr_value_agg = bucket.getAggregations().get(&quot;attr_value_agg&quot;);
        List&lt;String&gt; attrValues = attr_value_agg.getBuckets().stream().map(item -&gt; {
            String keyAsString = item.getKeyAsString();
            return keyAsString;
        }).collect(Collectors.toList());

        attrVo.setAttrId(attrId);
        attrVo.setAttrName(attrName);
        attrVo.setAttrValue(attrValues);

        attrVos.add(attrVo);
    }
    result.setAttrs(attrVos);

    //3. 封装所有商品涉及的所有品牌信息
    ParsedLongTerms brand_agg = aggregations.get(&quot;brand_agg&quot;);
    List&lt;SearchResult.BrandVo&gt; brandVos = new ArrayList&lt;&gt;();
    for (Terms.Bucket bucket : brand_agg.getBuckets()) {
        SearchResult.BrandVo brandVo = new SearchResult.BrandVo();
        // 品牌id
        long brandId = bucket.getKeyAsNumber().longValue();
        // 品牌名字
        ParsedStringTerms brand_name_agg = bucket.getAggregations().get(&quot;brand_name_agg&quot;);
        String brandName = brand_name_agg.getBuckets().get(0).getKeyAsString();
        // 品牌img
        ParsedStringTerms brand_img_agg = bucket.getAggregations().get(&quot;brand_img_agg&quot;);
        String brandImg = brand_img_agg.getBuckets().get(0).getKeyAsString();

        brandVo.setBrandId(brandId);
        brandVo.setBrandName(brandName);
        brandVo.setBrandImg(brandImg);

        brandVos.add(brandVo);
    }
    result.setBrands(brandVos);

    //4. 封装所有商品涉及的所有分类
    ParsedLongTerms catalog_agg = aggregations.get(&quot;catalog_agg&quot;);
    List&lt;SearchResult.CatalogVo&gt; catalogVos = new ArrayList&lt;&gt;();
    List&lt;? extends Terms.Bucket&gt; buckets = catalog_agg.getBuckets();
    for (Terms.Bucket bucket : buckets) {
        SearchResult.CatalogVo catalogVo = new SearchResult.CatalogVo();
        // 分类id
        String id = bucket.getKeyAsString();
        catalogVo.setCatalogId(Long.parseLong(id));
        // 分类名
        ParsedStringTerms catalog_name_agg = bucket.getAggregations().get(&quot;catalog_name_agg&quot;);
        String catalog_name = catalog_name_agg.getBuckets().get(0).getKeyAsString();
        catalogVo.setCatalogName(catalog_name);
        catalogVos.add(catalogVo);
    }
    result.setCatalogs(catalogVos);
    /******来自查询结果*******/
    //5. 分页信息
    // 页数
    result.setPageNum(param.getPageNum());
    // 总记录数
    long total = hits.getTotalHits().value;
    result.setTotal(total);
    //总页码
    int totalPages = (int)(total + EsConstant.PRODUCT_PAGESIZE - 1) / EsConstant.PRODUCT_PAGESIZE;
    result.setTotalPages(totalPages);
    return result;
}
</code></pre>
<p>调整动态页面的获取，可以得到这样的初步效果<br>
<img src="https://dxone1.github.io//post-images/1637324209707.png" alt="" loading="lazy"><br>
细化后可以通过点击拼串查询，查询逻辑在上方<br>
<img src="https://dxone1.github.io//post-images/1637325978007.png" alt="" loading="lazy"><br>
调整页面逻辑<br>
<img src="https://dxone1.github.io//post-images/1637328422616.png" alt="" loading="lazy"><br>
排序请求，通过在前端对应位置拼接排序的要求实现<br>
<img src="https://dxone1.github.io//post-images/1637377710787.png" alt="" loading="lazy"><br>
再实现价格区间和是否有货查询的前端逻辑<br>
<img src="https://dxone1.github.io//post-images/1637381005577.png" alt="" loading="lazy"><br>
面包屑导航<br>
<img src="https://dxone1.github.io//post-images/1637409332795.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城项目 day12：使用缓存]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day12shi-yong-huan-cun/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day12shi-yong-huan-cun/">
        </link>
        <updated>2021-11-16T08:51:04.000Z</updated>
        <content type="html"><![CDATA[<p>在业务中为了提升性能表现，mysql数据库将只负责数据的持久化，而加速访问则需要将部分数据存入缓存中。<br>
哪些数据适合放入缓存？</p>
<ul>
<li>即时性、 数据一致性要求不高的</li>
<li>访问量大且更新频率不高的数据（读多， 写少）<br>
<img src="https://dxone1.github.io//post-images/1637053007728.png" alt="" loading="lazy"><br>
本地缓存会出现数据一致性的问题，所以需要使用分布式缓存架构。单独提出一个缓存服务器即可完成<br>
<img src="https://dxone1.github.io//post-images/1637053641754.png" alt="" loading="lazy"></li>
</ul>
<h2 id="使用redis">使用Redis</h2>
<ol>
<li>在项目依赖中引入Redis</li>
</ol>
<pre><code class="language-xml">&lt;!--引入Redis作为缓存中间件--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>在yaml中配置redis的相关信息</li>
</ol>
<pre><code class="language-yaml">spring: 
    redis:
        host: 192.168.180.3
        port: 6379
</code></pre>
<p>在Redis中存储的数据往往是&lt;String, String&gt;格式，所以可以使用StringRedisTemplate自动配置。其他的使用RedisTemplate<br>
3. 测试</p>
<pre><code class="language-java">@Test
public void testStringRedisTemplate() {
    ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();
    // 保存
    ops.set(&quot;hello&quot;, &quot;world&quot; + UUID.randomUUID().toString());
    // 查询
    String hello = ops.get(&quot;hello&quot;);
    System.out.println(hello);
}
</code></pre>
<h2 id="在商城业务中加入缓存功能">在商城业务中加入缓存功能</h2>
<p>在分类控制器 CategoryService中添加缓存功能<br>
将原先的业务逻辑抽取为<code>getCatalogJsonFromDb()</code>的方法，然后重写带缓存的获取分类信息的业务代码</p>
<pre><code class="language-java">@Override
public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJson() {
    ValueOperations&lt;String, String&gt; ops = redisTemplate.opsForValue();
    String catalogJSON = ops.get(&quot;catalogJSON&quot;);
    // 缓存为空则需要查询数据库
    if(StringUtils.isEmpty(catalogJSON)) {
        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; catalogJsonFromDb = getCatalogJsonFromDb();
        // 放入缓存
        String s = JSON.toJSONString(catalogJsonFromDb);
        ops.set(&quot;catalogJSON&quot;, s);
        return catalogJsonFromDb;
    }
    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; res = JSON.parseObject(catalogJSON, new TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;(){});
    return res;
}
</code></pre>
<p><strong>堆外内存溢出</strong><br>
SpringBoot2默认使用Lettuce作为操作客户端，使用netty进行网络通信，Lettuce的bug会导致堆外内存溢出 -Xmx100m, netty没有指定下会使用与其一致的堆外内存。<br>
可以通过 -Dio.netty.maxDirectMemory设置，但是只能减缓出现溢出的时间，解决方案：1. 升级Lettuce客户端 2. 使用jedis</p>
<pre><code class="language-xml">&lt;!--引入Redis作为缓存中间件--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>大幅提高了响应效率和吞吐量<br>
<img src="https://dxone1.github.io//post-images/1637117151652.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1637117212321.png" alt="" loading="lazy"></p>
<h2 id="缓存失效问题">缓存失效问题</h2>
<ol>
<li>缓存穿透</li>
</ol>
<ul>
<li>缓存穿透是指查询一个一定不存在的数据， 由于缓存是不命中， 将去查询数据库， 但是数<br>
据库也无此记录， 我们没有将这次查询的 null 写入缓存， 这将导致这个不存在的数据每次<br>
请求都要到存储层去查询， 失去了缓存的意义。</li>
<li>在流量大时， 可能 DB 就挂掉了， 要是有人利用不存在的 key 频繁攻击我们的应用， 这就是<br>
漏洞。</li>
<li>解决：<br>
缓存空结果、 并且设置短的过期时间。</li>
</ul>
<ol start="2">
<li>缓存雪崩</li>
</ol>
<ul>
<li>缓存雪崩是指在我们设置缓存时采用了相同的过期时间， 导致缓存在某一时刻同时失<br>
效， 请求全部转发到 DB， DB 瞬时压力过重雪崩。</li>
<li>解决：<br>
原有的失效时间基础上增加一个随机值， 比如 1-5 分钟随机， 这样每一个缓存的过期时间的<br>
重复率就会降低， 就很难引发集体失效的事件。</li>
</ul>
<ol start="3">
<li>缓存击穿</li>
</ol>
<ul>
<li>对于一些设置了过期时间的 key， 如果这些 key 可能会在某些时间点被超高并发地访问，<br>
是一种非常“热点”的数据。</li>
<li>这个时候， 需要考虑一个问题： 如果这个 key 在大量请求同时进来前正好失效， 那么所<br>
有对这个 key 的数据查询都落到 db， 我们称为缓存击穿。</li>
<li>解决：<br>
加锁</li>
</ul>
<h2 id="加锁">加锁</h2>
<ol>
<li>简单的本地锁</li>
</ol>
<pre><code class="language-java">public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonFromDb() {
        /**
         * 将多次查数据库优化为一次
         */
        synchronized (this) {
            String catalogJSON = redisTemplate.opsForValue().get(&quot;catalogJSON&quot;);
            if(!StringUtils.isEmpty(catalogJSON)) {
                //缓存不为空直接返回
                //double check的逻辑
                Map&lt;String, List&lt;Catelog2Vo&gt;&gt; res = JSON.parseObject(catalogJSON, new TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;(){});
                return res;
            }
      ......

      // 将放入缓存操作也放入锁同步块中
        String s = JSON.toJSONString(map);
        redisTemplate.opsForValue().set(&quot;catalogJSON&quot;, s, 1, TimeUnit.DAYS);
        return map;
}
</code></pre>
<p>类似于Double check的机制，但是在分布式集群情况下则因为每个进程只能锁自己的，所以无法实现完全的加锁，这时候就需要分布式锁。然而实际上在一般规模集群也可以防止缓存击穿。<br>
发现只有一次的查数据库操作<br>
<img src="https://dxone1.github.io//post-images/1637126480451.png" alt="" loading="lazy"><br>
2. 分布式锁<br>
当有多个应用时测试，会有可能多个线程都查询了数据库，想要实现全局只有一次查询则需要添加分布式锁<br>
<img src="https://dxone1.github.io//post-images/1637126981627.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1637126984844.png" alt="" loading="lazy"><br>
分布式锁的机制<br>
<img src="https://dxone1.github.io//post-images/1637130836138.png" alt="" loading="lazy"><br>
使用<code>setnx()</code>命令可以尝试原子的给redeis设置锁，如果已经存在了则无法成功上锁。执行<code>set lock 1 NX</code>即同时只有一个会加上锁。<br>
在加锁时，必须原子地设置过期时间，否则因为线程崩溃会导致死锁。同时，解锁也需要原子地判断当前解锁的是否是当前线程设置的锁，必须匹配锁的value才可以解锁，这也需要时原子性操作，可以使用LUA脚本实现。保证了所有线程只查询一次数据库，但是吞吐量下降了不少：</p>
<pre><code class="language-java">public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonFromDbWithRedisLock() {
    // 占用分布式锁
    String uuid = UUID.randomUUID().toString();
    Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid, 10, TimeUnit.SECONDS);
    if (lock) {
        // 加锁成功
        System.out.println(&quot;分布式锁获取成功...&quot;);
        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb = null;
        try {
            dataFromDb = getDataFromDb();
        } finally {
            /**
                * 直接删除锁有可能
                * 因为业务时间过长，锁自动失效，删除的是别的线程的锁！
                * 解决方法是加入唯一标识。
                * 然而到redis通信也仍然可能因为非原子操作而导致错误！需要使用lua脚本实现
                */
            String script = &quot;if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end&quot;;
            Long lockSuccess = redisTemplate.execute(new DefaultRedisScript&lt;Long&gt;(script, Long.class), Arrays.asList(&quot;lock&quot;), uuid);
        }
        return dataFromDb;
    } else {
        // 加锁不成功...重试
        System.out.println(&quot;获取分布式锁不成功，等待重试...&quot;);
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return getCatalogJsonFromDbWithRedisLock(); //自旋
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1637136159650.png" alt="" loading="lazy"></figure>
<h2 id="使用redisson分布式框架">使用Redisson分布式框架</h2>
<ol>
<li>引入依赖</li>
</ol>
<pre><code class="language-xml">&lt;!--作为分布式锁/对象框架--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.redisson&lt;/groupId&gt;
    &lt;artifactId&gt;redisson&lt;/artifactId&gt;
    &lt;version&gt;3.12.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>配置</li>
</ol>
<pre><code class="language-java">@Configuration
public class MyRedissonConfig {
    @Bean(destroyMethod=&quot;shutdown&quot;)
    RedissonClient redisson() throws IOException {
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;192.168.180.3:6379&quot;);
        return Redisson.create(config);
    }
}
</code></pre>
<ol start="3">
<li>使用<br>
Redisson的分布式锁实现了JUC的Lock接口，可以直接按照JUC的思维编写，底层的分布式锁操作被封装为透明的。Redisson也可以实现锁的自动续期。即在业务期间也会续上锁的生存周期。<br>
读写锁的逻辑：<br>
读写互斥，读之间共享，写之间互斥</li>
</ol>
<pre><code class="language-java">public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonFromDbWithRedissonLock() {
    RLock lock = redisson.getLock(&quot;CatalogJson-lock&quot;);
    lock.lock(10, TimeUnit.SECONDS);
    // 加锁成功
    System.out.println(&quot;分布式锁获取成功...&quot;);
    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb = null;
    try {
        dataFromDb = getDataFromDb();
    } finally {
        lock.unlock();
    }
    return dataFromDb;
}
</code></pre>
<ol start="4">
<li>缓存一致性问题</li>
</ol>
<ul>
<li>双写：每次更新数据库都修改缓存</li>
<li>失效：每次更新只删除缓存，等查询未命中再添加<br>
可以使用Canal解决缓存一致性问题，采用订阅机制，类似于观察者模式的推送更新。本项目使用分布式读写锁解决<br>
<img src="https://dxone1.github.io//post-images/1637156753301.png" alt="" loading="lazy"></li>
</ul>
<h2 id="统一缓存技术spring-cache">统一缓存技术：Spring Cache</h2>
<p>Spring 从 3.1 开始定义了 org.springframework.cache.Cache 和org.springframework.cache.CacheManager 接口来统一不同的缓存技术；并支持使用 JCache（JSR-107） 注解简化我们开发<br>
Cache 接口为缓存的组件规范定义， 包含缓存的各种操作集合；Cache 接 口 下 Spring 提 供 了 各 种 xxxCache 的 实 现 ； 如 RedisCache ， EhCacheCache , ConcurrentMapCache 等<br>
<img src="https://dxone1.github.io//post-images/1637157410269.png" alt="" loading="lazy"></p>
<ol>
<li>引入依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>写配置<br>
会自动配置RedisCacheConfiguration，也会自动配置缓存管理器RedisCacheManager<br>
需要配置Redis的缓存策略</li>
</ol>
<pre><code class="language-txt">spring.cache.type=redis
</code></pre>
<ol start="3">
<li>开启缓存功能 @EnableCaching</li>
<li>使用注解完成缓存操作</li>
</ol>
<pre><code class="language-java">//需要指定放到哪个缓存分区中
@Cacheable({&quot;category&quot;}) //代表当前方法的结果需要缓存，如果缓存中有则不调用，没有则调用方法并添加到缓存中
@Override
public List&lt;CategoryEntity&gt; getLevel1Categorys() {
    long l = System.currentTimeMillis();
    List&lt;CategoryEntity&gt; categoryEntities = this.baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(&quot;parent_cid&quot;, 0));
    System.out.println(&quot;消耗时间: &quot; + (System.currentTimeMillis() - l));
    return categoryEntities;
}
</code></pre>
<p>配置文件中设置存活时间，使用注解的key属性定义key。将缓存数据保存为json格式可以使用自定义缓存管理器的方式。</p>
<h3 id="自定义rediscacheconfiguration">自定义redisCacheConfiguration</h3>
<p>可以在这里定义序列化配置</p>
<pre><code class="language-java">@EnableCaching
@Configuration
public class MyCacheConfig {
   @Bean
    RedisCacheConfiguration redisCacheConfiguration(CacheProperties cacheProperties) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();
        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()));
        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
        // 将配置文件中的配置配置上
        CacheProperties.Redis redisProperties = cacheProperties.getRedis();
        if (redisProperties.getTimeToLive() != null) {
            config = config.entryTtl(redisProperties.getTimeToLive());
        }
        if (redisProperties.getKeyPrefix() != null) {
            config = config.prefixKeysWith(redisProperties.getKeyPrefix());
        }
        if (!redisProperties.isCacheNullValues()) {
            config = config.disableCachingNullValues();
        }
        if (!redisProperties.isUseKeyPrefix()) {
            config = config.disableKeyPrefix();
        }
        return config;
    }
}
</code></pre>
<p>增加一些配置：</p>
<pre><code class="language-txt">spring.cache.type=redis
spring.cache.redis.time-to-live=3600000
spring.cache.redis.key-prefix=CACHE_
spring.cache.redis.use-key-prefix=true
# 缓存空值，防止缓存穿透
spring.cache.redis.cache-null-values=true
</code></pre>
<h3 id="失效模式-cacheevict">失效模式 @CacheEvict</h3>
<p>一旦更新菜单就清空缓存</p>
<pre><code class="language-java">@CacheEvict(value = &quot;category&quot;, key = &quot;'getLevel1Categorys'&quot;)
@Transactional
@Override
public void updateCascade(CategoryEntity category) {
    this.updateById(category);
    categoryBrandRelationService.updateCategory(category.getCatId(), category.getName());
}
</code></pre>
<p>@Caching可以指定多个缓存操作，这样就可以一次清楚多个缓存</p>
<pre><code class="language-java">@Caching(evict = {
        @CacheEvict(value = &quot;category&quot;, key = &quot;'getLevel1Categorys'&quot;),
        @CacheEvict(value = &quot;category&quot;, key = &quot;'getCatalogJson'&quot;)
})
</code></pre>
<p>或者按照分区全部删除</p>
<pre><code class="language-java">@CacheEvict(value = &quot;category&quot;, allEntries = true)
</code></pre>
<p>@CachePut：双写模式的接口，我们使用失效模式 @CacheEvict</p>
<h3 id="原理">原理</h3>
<ol>
<li>穿透：可以设置存储空数据</li>
<li>雪崩：可以设置过期时间</li>
<li>击穿：加锁<br>
SpringCache的会创建RedisCacheManager -&gt; RedisCache，默认是不加锁的。想解决击穿问题使用@Cacheable(sync = true)即可加本地锁。<br>
@Cacheable是读方法<br>
@CacheEvict是更新方法</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城项目 day11：反向代理和压力测试]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day11/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day11/">
        </link>
        <updated>2021-11-16T03:10:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nginx搭建域名访问环境">Nginx搭建域名访问环境</h2>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1637032446105.png" alt="" loading="lazy"></figure>
<ol>
<li>改hosts文件</li>
</ol>
<pre><code class="language-txt"># mall
192.168.180.3 mall.com
</code></pre>
<ol start="2">
<li>让nginx执行反向代理<br>
<img src="https://dxone1.github.io//post-images/1637033085703.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1637033729229.png" alt="" loading="lazy"></li>
<li>nginx搭配网关实现负载均衡<br>
<img src="https://dxone1.github.io//post-images/1637034269351.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1637034276264.png" alt="" loading="lazy"><br>
在网关添加基于域名的路由规则<br>
注意在Nginx代理给网关的时候会丢掉host信息，必须配置！<br>
<img src="https://dxone1.github.io//post-images/1637034850812.png" alt="" loading="lazy"></li>
</ol>
<pre><code class="language-yaml">- id: mall_host_route
    uri: lb://mall-product
    # 使用Host域名方式进行路由：任意mall.com旗下的全部路由给mall-product
    predicates:
    - Host=**.mall.com
</code></pre>
<p>效果<br>
<img src="https://dxone1.github.io//post-images/1637034920577.png" alt="" loading="lazy"></p>
<h2 id="压力测试">压力测试</h2>
<p>使用Apache JMeter压测工具进行<br>
访问mall.com的地址，观察一个聚合报告<br>
<img src="https://dxone1.github.io//post-images/1637036493024.png" alt="" loading="lazy"><br>
性能偏低原因在于：CPU同时在运行一个python仿真程序，且限制了每个服务的最大堆内存</p>
<h2 id="性能调优">性能调优</h2>
<p>考虑一个已有的场景： 请求 -&gt; nginx -&gt; gateway -&gt; mall-product（渲染首页）</p>
<ol>
<li>Nginx测试<br>
使用Jmeter压测，通过docker stats命令实时监控<br>
<img src="https://dxone1.github.io//post-images/1637046083726.png" alt="" loading="lazy"><br>
可以看到Nginx占用CPU很高，但是吞吐量很高<br>
<img src="https://dxone1.github.io//post-images/1637046261797.png" alt="" loading="lazy"></li>
<li>网关测试<br>
<img src="https://dxone1.github.io//post-images/1637046508893.png" alt="" loading="lazy"><br>
吞吐量也很高<br>
J VisualVM测试Eden区有点小，GC次数多<br>
<img src="https://dxone1.github.io//post-images/1637046554346.png" alt="" loading="lazy"></li>
<li>Gateway + 简单页面<br>
在增加中间件后链路吞吐量大幅下降！</li>
<li>访问mall.com 全链路<br>
<img src="https://dxone1.github.io//post-images/1637047278718.png" alt="" loading="lazy"><br>
压测发现渲染分类菜单拖慢了整个系统的速度，一级菜单的渲染主要消耗在查数据库和thymleaf的页面渲染上，三级分类则主要是查数据库耗时。此外，在页面渲染获取静态页面时耗时也是很可怕的。</li>
</ol>
<h3 id="简单优化数据库">简单优化数据库</h3>
<p>开启缓存，日志级别调低至error，优化数据库<br>
controller中的indexPage方法只查询一级分类，只涉及parent_cid字段的查询操作，可以考虑建立索引，发现吞吐量大幅提高<br>
<img src="https://dxone1.github.io//post-images/1637049151641.png" alt="" loading="lazy"></p>
<h3 id="nginx动静分离">Nginx动静分离</h3>
<p>指定 /static/下的所有请求都由Nginx处理<br>
<img src="https://dxone1.github.io//post-images/1637050290116.png" alt="" loading="lazy"><br>
这样所有的静态资源直接由Nginx返回，不需要再转发到tomcat处理了</p>
<h3 id="jvm调优">JVM调优</h3>
<p>使用如下参数进行调优<br>
<img src="https://dxone1.github.io//post-images/1637051516591.png" alt="" loading="lazy"></p>
<h3 id="优化三级分类业务">优化三级分类业务</h3>
<p>将多次查表操作优化为单次查表再筛选</p>
<pre><code class="language-java">@Override
public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJson() {
    /**
        * 将多次查数据库优化为一次
        */
    List&lt;CategoryEntity&gt; selectList = baseMapper.selectList(null);
    // 查出所有一级分类
    List&lt;CategoryEntity&gt; level1Categorys = getParent_cid(selectList, 0L);
    // 封装数据
    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; map = level1Categorys.stream().collect(Collectors.toMap(k -&gt; k.getCatId().toString(),
            v -&gt; {
                // 查询所有一级分类下的二级分类
                List&lt;CategoryEntity&gt; categoryEntities = getParent_cid(selectList, v.getCatId());
                List&lt;Catelog2Vo&gt; catelog2Vos = null;
                if (categoryEntities != null) {
                    catelog2Vos = categoryEntities.stream().map(l2 -&gt; {
                        Catelog2Vo catelog2Vo = new Catelog2Vo(v.getCatId().toString(), null, l2.getCatId().toString(), l2.getName());
                        List&lt;CategoryEntity&gt; level3Catelog = getParent_cid(selectList, l2.getCatId());
                        if (level3Catelog != null) {
                            List&lt;Catelog2Vo.Catelog3Vo&gt; collect = level3Catelog.stream().map(l3 -&gt; {
                                Catelog2Vo.Catelog3Vo catelog3Vo = new Catelog2Vo.Catelog3Vo(l2.getCatId().toString(), l3.getCatId().toString(), l3.getName());
                                return catelog3Vo;
                            }).collect(Collectors.toList());
                            catelog2Vo.setCatalog3List(collect);
                        }
                        return catelog2Vo;
                    }).collect(Collectors.toList());
                }
                return catelog2Vos;
            }));
    return map;
}

private List&lt;CategoryEntity&gt; getParent_cid(List&lt;CategoryEntity&gt; selectList, Long parent_cid) {
    List&lt;CategoryEntity&gt; collect = selectList.stream().filter(item -&gt; item.getParentCid() == parent_cid).collect(Collectors.toList());
    return collect;
}
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1637052446002.png" alt="" loading="lazy"><br>
吞吐量大幅上涨</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城项目 day10：商品商城]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day10shang-pin-shang-cheng/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day10shang-pin-shang-cheng/">
        </link>
        <updated>2021-11-15T02:51:51.000Z</updated>
        <content type="html"><![CDATA[<p>ES作用：商城全文检索、日志检索...</p>
<h2 id="商品上架">商品上架</h2>
<p>ES使用内存，代价很高，所以约定只存储必须的信息，其他的再从mysql中查找。保存以下信息：sku信息、SPU商品规格、品牌、分类...<br>
<img src="https://dxone1.github.io//post-images/1636945703755.png" alt="" loading="lazy"><br>
防冗余ES设计：</p>
<pre><code class="language-json">sku索引{
    skuId: 1,
    spuId: 11,
    xxxx
}

attr索引{
    spuId: 11,
    attrs: [
        {尺寸: 5寸},
        {CPU: 高通骁龙845},
        {分辨率: 全高清}        
    ]
}
</code></pre>
<p>观察京东商城的设计：当搜索某个选项后可以自动计算出符合该搜索项的所有属性组合。综合考量使用如下的ES索引设计</p>
<pre><code class="language-json">POST product
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;skuId&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;spuId&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;skuTitle&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_smart&quot;
      },
      &quot;skuPrice&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;skuImg&quot;: {
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false,
        &quot;doc_values&quot;: false
      },
      &quot;saleCount&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;hasStock&quot;: {
        &quot;type&quot;: &quot;boolean&quot;
      },
      &quot;hotScore&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;brandId&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;catalogId&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;brandName&quot;: {
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false,
        &quot;doc_values&quot;: false
      },
      &quot;brandImg&quot;: {
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false,
        &quot;doc_values&quot;: false
      },
      &quot;catalogName&quot;: {
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false,
        &quot;doc_values&quot;: false
      },
      &quot;attrs&quot;: {
        &quot;type&quot;: &quot;nested&quot;,
        &quot;properties&quot;: {
          &quot;attrId&quot;: {
            &quot;type&quot;: &quot;long&quot;
          },
          &quot;attrName&quot;: {
            &quot;type&quot;: &quot;keyword&quot;,
            &quot;index&quot;: false,
            &quot;doc_values&quot;: false
          },
          &quot;attrValue&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
          }
        }
      }
    }
  }
}
</code></pre>
<ol>
<li>创建一个和这个数据格式匹配的TO（领域模型）,完成product和search服务之间的数据传输</li>
<li>基本属性和品牌分类信息的sql查找和封装</li>
<li>远程调用库存服务，查看还有没有库存</li>
</ol>
<pre><code class="language-java">@Override
public List&lt;SkuHasStockVo&gt; getSkuHasStock(List&lt;Long&gt; skuIds) {
    List&lt;SkuHasStockVo&gt; collect = skuIds.stream().map(skuId -&gt; {
        SkuHasStockVo skuHasStockVo = new SkuHasStockVo();
        Long count = this.baseMapper.getSkuStock(skuId);
        skuHasStockVo.setHasStock(count &gt; 0);
        return skuHasStockVo;
    }).collect(Collectors.toList());
    return collect;
}
</code></pre>
<ol start="4">
<li>远程调用search服务，实现index给ES封装好的SkuEsModel</li>
</ol>
<pre><code class="language-java">/**
    * 保存上架商品数据到ES中
    * @param skuEsModels
    */
@Override
public boolean productStatusUp(List&lt;SkuEsModel&gt; skuEsModels) throws IOException {
    // 1. 给ES建立索引，并建立映射关系
    // 2. 给es保存数据
    BulkRequest bulkRequest = new BulkRequest();
    for (SkuEsModel model : skuEsModels) {
        IndexRequest indexRequest = new IndexRequest(EsConstant.PRODUCT_INDEX);
        // 设定indexRequest的id,内容
        indexRequest.id(model.getSkuId().toString());
        String s = JSON.toJSONString(model);
        indexRequest.source(s, XContentType.JSON);
        // 放入bulk中
        bulkRequest.add(indexRequest);
    }
    BulkResponse bulk = client.bulk(bulkRequest, MallElasticSearchConfig.COMMON_OPTIONS);
    // TODO 如果批量index操作有错误则记录log
    boolean b = bulk.hasFailures();
    List&lt;String&gt; collect = Arrays.stream(bulk.getItems()).filter(item -&gt;
            item.isFailed()
    ).map(item -&gt; {
        return item.getId();
    }).collect(Collectors.toList());
    log.error(&quot;商品上架出错,{}&quot;, collect);

    return b;
}
</code></pre>
<pre><code class="language-java">/**
* feign调用流程：
* 1. 构造请求数据，将对象转为json
* 2. 发送请求进行执行，执行成功会解码响应数据
* 3. 执行请求会有重试机制
*/
</code></pre>
<p>总体的javaService如下，流程还是有复杂度的</p>
<pre><code class="language-java">/**
    * 商品上架功能
    * @param spuId
    */
@Override
public void up(Long spuId) {
    //1. 组装需要的数据
    // 查询当前SpuId对应的SKU信息
    List&lt;SkuInfoEntity&gt; skus = skuInfoService.getSkusBySpuId(spuId);
    List&lt;Long&gt; skuIdList = skus.stream().map(SkuInfoEntity::getSkuId).collect(Collectors.toList());

    // TODO 查询当前Sku的所有可以被检索的规格属性 attrs
    List&lt;ProductAttrValueEntity&gt; baseAttrs = productAttrValueService.baseAttrListForSpu(spuId);
    List&lt;Long&gt; attrIds = baseAttrs.stream().map(attr -&gt; {
        return attr.getAttrId();
    }).collect(Collectors.toList());
    // 查询可检索属性的id
    List&lt;Long&gt; searchAttrIds = attrService.selectSearchAttrs(attrIds);
    Set&lt;Long&gt; idSet = new HashSet&lt;&gt;(searchAttrIds);
    // 筛选可检索的属性并封装
    // 先过滤掉不可检索的属性，再封装成SkuEsModel.Attrs的格式，方便后续保存
    List&lt;SkuEsModel.Attrs&gt; attrsList = baseAttrs.stream().filter(item -&gt; {
        return idSet.contains(item.getAttrId());
    }).map(item -&gt; {
        SkuEsModel.Attrs attrs1 = new SkuEsModel.Attrs();
        BeanUtils.copyProperties(item, attrs1);
        return attrs1;
    }).collect(Collectors.toList());

    // hasStock 发送远程查看有无库存
    Map&lt;Long, Boolean&gt; stockMap = null;
    try {
        R skuHasStock = wareFeignService.getSkuHasStock(skuIdList);
        TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt; typeReference = new TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt;() {};
        stockMap = skuHasStock.getData(typeReference).stream().collect(Collectors.toMap(SkuHasStockVo::getSkuId, item -&gt; item.getHasStock()));
    } catch (Exception e) {
        log.error(&quot;库存服务异常,原因{}&quot;,e);
    }

    // 封装SkuEsModel
    Map&lt;Long, Boolean&gt; finalStockMap = stockMap;
    List&lt;SkuEsModel&gt; upProducts = skus.stream().map(sku -&gt; {
        SkuEsModel esModel = new SkuEsModel();
        BeanUtils.copyProperties(sku, esModel);
        esModel.setSkuPrice(sku.getPrice());
        esModel.setSkuImg(sku.getSkuDefaultImg());

        // 设置库存，没有查询成功就认为有库存返回
        if(finalStockMap == null) {
            esModel.setHasStock(true);
        } else {
            esModel.setHasStock(finalStockMap.get(sku.getSkuId()));
        }

        // hotStock 热度评分默认置0
        esModel.setHotScore(0L);

        // 品牌信息
        BrandEntity brandEntity = brandService.getById(esModel.getBrandId());
        esModel.setBrandName(brandEntity.getName());
        esModel.setBrandImg(brandEntity.getLogo());
        // 分类信息
        CategoryEntity categoryEntity = categoryService.getById(esModel.getCatalogId());
        esModel.setCatalogName(categoryEntity.getName());
        // 设置SPU的可检索规格属性
        esModel.setAttrs(attrsList);
        return esModel;
    }).collect(Collectors.toList());

    // 发送给ES：提出search的远程调用
    R r = searchFeignService.productStatusUp(upProducts);
    if(r.getCode() == 0) {
        // 远程调用成功
        // 需要修改SPU的 publish_status 发布状态为已上架
        this.baseMapper.updateSpuStatus(spuId, ProductConstant.StatusEnum.SPU_UP.getCode());

    } else {
        // 远程调用失败
        // TODO 重复调用，接口幂等性问题，重试机制

    }
}
</code></pre>
<p>结果：<br>
<img src="https://dxone1.github.io//post-images/1636969745665.png" alt="" loading="lazy"></p>
<h2 id="搭建商城首页">搭建商城首页</h2>
<h3 id="使用thymeleaf渲染页面">使用thymeleaf渲染页面</h3>
<p>架构如下：<br>
<img src="https://dxone1.github.io//post-images/1636970274115.png" alt="" loading="lazy"></p>
<ol>
<li>导入thymeleaf的依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>将页面资源放入对应的微服务的项目文件夹：</p>
<pre><code class="language-txt">静态资源 -&gt; static
动态页面 -&gt; templates
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1636975188211.png" alt="" loading="lazy"></figure>
<h3 id="首页渲染分类功能">首页渲染分类功能</h3>
<ol>
<li>先设定欢迎页的路径映射，使用Thymeleaf解析</li>
<li>编写返回渲染分类信息的数据</li>
</ol>
<pre><code class="language-java">@GetMapping({&quot;/&quot;, &quot;/index.html&quot;})
public String indexPage(Model model) {
    // TODO 查出所有的一级分类
    List&lt;CategoryEntity&gt; categoryEntities = categoryService.getLevel1Categorys();
    // 使用model传数据
    model.addAttribute(&quot;categorys&quot;, categoryEntities);
    return &quot;index&quot;;
}
</code></pre>
<ol start="3">
<li>页面取出相关数据并渲染<br>
一级菜单</li>
</ol>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li th:each=&quot;category : ${categorys}&quot;&gt;
        &lt;a href=&quot;#&quot; class=&quot;header_main_left_a&quot; th:attr=&quot;ctg-data=${category.catId}&quot;&gt;&lt;b th:text=&quot;${category.name}&quot;&gt;家用电器111&lt;/b&gt;&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>二三级菜单<br>
根据需要返回的数据，构建一个vo</p>
<pre><code class="language-java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Catelog2Vo {
    private String catalog1Id; //一级父分类的id
    private List&lt;Object&gt; catalog3List; // 三级子分类
    private String id;
    private String name;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Catelog3Vo {
        private String catalog2Id; //二级父分类的id
        private String id;
        private String name;
    }
}
</code></pre>
<p>给出的js文件会发出请求，编写对应的控制器返回json数据</p>
<pre><code class="language-java">/**
    * 返回封装成json格式的二三级分类
    * @return
    */
@Override
public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJson() {
    // 查出所有一级分类
    List&lt;CategoryEntity&gt; level1Categorys = this.getLevel1Categorys();
    // 封装数据
    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; map = level1Categorys.stream().collect(Collectors.toMap(k -&gt; k.getCatId().toString(),
            v -&gt; {
                // 查询所有一级分类下的二级分类
                List&lt;CategoryEntity&gt; categoryEntities = baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(&quot;parent_cid&quot;, v.getCatId()));
                List&lt;Catelog2Vo&gt; catelog2Vos = null;
                if (categoryEntities != null) {
                    catelog2Vos = categoryEntities.stream().map(l2 -&gt; {
                        Catelog2Vo catelog2Vo = new Catelog2Vo(v.getCatId().toString(), null, l2.getCatId().toString(), l2.getName());
                        List&lt;CategoryEntity&gt; level3Catelog = baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(&quot;parent_cid&quot;, l2.getCatId()));
                        if(level3Catelog != null) {
                            List&lt;Catelog2Vo.Catelog3Vo&gt; collect = level3Catelog.stream().map(l3 -&gt; {
                                Catelog2Vo.Catelog3Vo catelog3Vo = new Catelog2Vo.Catelog3Vo(l2.getCatId().toString(), l3.getCatId().toString(), l3.getName());
                                return catelog3Vo;
                            }).collect(Collectors.toList());
                            catelog2Vo.setCatalog3List(collect);
                        }
                        return catelog2Vo;
                    }).collect(Collectors.toList());
                }
                return catelog2Vos;
            }));
    return map;
}
</code></pre>
<p>此时分类的渲染是实时从数据库更新的<br>
<img src="https://dxone1.github.io//post-images/1636978683545.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>