<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dxone1.github.io/</id>
    <title>Gridea</title>
    <updated>2021-11-16T08:50:05.558Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dxone1.github.io/"/>
    <link rel="self" href="https://dxone1.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://dxone1.github.io/images/avatar.png</logo>
    <icon>https://dxone1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[商城项目 day11：反向代理和压力测试]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day11/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day11/">
        </link>
        <updated>2021-11-16T03:10:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nginx搭建域名访问环境">Nginx搭建域名访问环境</h2>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1637032446105.png" alt="" loading="lazy"></figure>
<ol>
<li>改hosts文件</li>
</ol>
<pre><code class="language-txt"># mall
192.168.180.3 mall.com
</code></pre>
<ol start="2">
<li>让nginx执行反向代理<br>
<img src="https://dxone1.github.io//post-images/1637033085703.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1637033729229.png" alt="" loading="lazy"></li>
<li>nginx搭配网关实现负载均衡<br>
<img src="https://dxone1.github.io//post-images/1637034269351.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1637034276264.png" alt="" loading="lazy"><br>
在网关添加基于域名的路由规则<br>
注意在Nginx代理给网关的时候会丢掉host信息，必须配置！<br>
<img src="https://dxone1.github.io//post-images/1637034850812.png" alt="" loading="lazy"></li>
</ol>
<pre><code class="language-yaml">- id: mall_host_route
    uri: lb://mall-product
    # 使用Host域名方式进行路由：任意mall.com旗下的全部路由给mall-product
    predicates:
    - Host=**.mall.com
</code></pre>
<p>效果<br>
<img src="https://dxone1.github.io//post-images/1637034920577.png" alt="" loading="lazy"></p>
<h2 id="压力测试">压力测试</h2>
<p>使用Apache JMeter压测工具进行<br>
访问mall.com的地址，观察一个聚合报告<br>
<img src="https://dxone1.github.io//post-images/1637036493024.png" alt="" loading="lazy"><br>
性能偏低原因在于：CPU同时在运行一个python仿真程序，且限制了每个服务的最大堆内存</p>
<h2 id="性能调优">性能调优</h2>
<p>考虑一个已有的场景： 请求 -&gt; nginx -&gt; gateway -&gt; mall-product（渲染首页）</p>
<ol>
<li>Nginx测试<br>
使用Jmeter压测，通过docker stats命令实时监控<br>
<img src="https://dxone1.github.io//post-images/1637046083726.png" alt="" loading="lazy"><br>
可以看到Nginx占用CPU很高，但是吞吐量很高<br>
<img src="https://dxone1.github.io//post-images/1637046261797.png" alt="" loading="lazy"></li>
<li>网关测试<br>
<img src="https://dxone1.github.io//post-images/1637046508893.png" alt="" loading="lazy"><br>
吞吐量也很高<br>
J VisualVM测试Eden区有点小，GC次数多<br>
<img src="https://dxone1.github.io//post-images/1637046554346.png" alt="" loading="lazy"></li>
<li>Gateway + 简单页面<br>
在增加中间件后链路吞吐量大幅下降！</li>
<li>访问mall.com 全链路<br>
<img src="https://dxone1.github.io//post-images/1637047278718.png" alt="" loading="lazy"><br>
压测发现渲染分类菜单拖慢了整个系统的速度，一级菜单的渲染主要消耗在查数据库和thymleaf的页面渲染上，三级分类则主要是查数据库耗时。此外，在页面渲染获取静态页面时耗时也是很可怕的。</li>
</ol>
<h3 id="简单优化数据库">简单优化数据库</h3>
<p>开启缓存，日志级别调低至error，优化数据库<br>
controller中的indexPage方法只查询一级分类，只涉及parent_cid字段的查询操作，可以考虑建立索引，发现吞吐量大幅提高<br>
<img src="https://dxone1.github.io//post-images/1637049151641.png" alt="" loading="lazy"></p>
<h3 id="nginx动静分离">Nginx动静分离</h3>
<p>指定 /static/下的所有请求都由Nginx处理<br>
<img src="https://dxone1.github.io//post-images/1637050290116.png" alt="" loading="lazy"><br>
这样所有的静态资源直接由Nginx返回，不需要再转发到tomcat处理了</p>
<h3 id="jvm调优">JVM调优</h3>
<p>使用如下参数进行调优<br>
<img src="https://dxone1.github.io//post-images/1637051516591.png" alt="" loading="lazy"></p>
<h3 id="优化三级分类业务">优化三级分类业务</h3>
<p>将多次查表操作优化为单次查表再筛选</p>
<pre><code class="language-java">@Override
public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJson() {
    /**
        * 将多次查数据库优化为一次
        */
    List&lt;CategoryEntity&gt; selectList = baseMapper.selectList(null);
    // 查出所有一级分类
    List&lt;CategoryEntity&gt; level1Categorys = getParent_cid(selectList, 0L);
    // 封装数据
    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; map = level1Categorys.stream().collect(Collectors.toMap(k -&gt; k.getCatId().toString(),
            v -&gt; {
                // 查询所有一级分类下的二级分类
                List&lt;CategoryEntity&gt; categoryEntities = getParent_cid(selectList, v.getCatId());
                List&lt;Catelog2Vo&gt; catelog2Vos = null;
                if (categoryEntities != null) {
                    catelog2Vos = categoryEntities.stream().map(l2 -&gt; {
                        Catelog2Vo catelog2Vo = new Catelog2Vo(v.getCatId().toString(), null, l2.getCatId().toString(), l2.getName());
                        List&lt;CategoryEntity&gt; level3Catelog = getParent_cid(selectList, l2.getCatId());
                        if (level3Catelog != null) {
                            List&lt;Catelog2Vo.Catelog3Vo&gt; collect = level3Catelog.stream().map(l3 -&gt; {
                                Catelog2Vo.Catelog3Vo catelog3Vo = new Catelog2Vo.Catelog3Vo(l2.getCatId().toString(), l3.getCatId().toString(), l3.getName());
                                return catelog3Vo;
                            }).collect(Collectors.toList());
                            catelog2Vo.setCatalog3List(collect);
                        }
                        return catelog2Vo;
                    }).collect(Collectors.toList());
                }
                return catelog2Vos;
            }));
    return map;
}

private List&lt;CategoryEntity&gt; getParent_cid(List&lt;CategoryEntity&gt; selectList, Long parent_cid) {
    List&lt;CategoryEntity&gt; collect = selectList.stream().filter(item -&gt; item.getParentCid() == parent_cid).collect(Collectors.toList());
    return collect;
}
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1637052446002.png" alt="" loading="lazy"><br>
吞吐量大幅上涨</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城项目 day10：商品商城]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day10shang-pin-shang-cheng/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day10shang-pin-shang-cheng/">
        </link>
        <updated>2021-11-15T02:51:51.000Z</updated>
        <content type="html"><![CDATA[<p>ES作用：商城全文检索、日志检索...</p>
<h2 id="商品上架">商品上架</h2>
<p>ES使用内存，代价很高，所以约定只存储必须的信息，其他的再从mysql中查找。保存以下信息：sku信息、SPU商品规格、品牌、分类...<br>
<img src="https://dxone1.github.io//post-images/1636945703755.png" alt="" loading="lazy"><br>
防冗余ES设计：</p>
<pre><code class="language-json">sku索引{
    skuId: 1,
    spuId: 11,
    xxxx
}

attr索引{
    spuId: 11,
    attrs: [
        {尺寸: 5寸},
        {CPU: 高通骁龙845},
        {分辨率: 全高清}        
    ]
}
</code></pre>
<p>观察京东商城的设计：当搜索某个选项后可以自动计算出符合该搜索项的所有属性组合。综合考量使用如下的ES索引设计</p>
<pre><code class="language-json">POST product
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;skuId&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;spuId&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;skuTitle&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_smart&quot;
      },
      &quot;skuPrice&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;skuImg&quot;: {
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false,
        &quot;doc_values&quot;: false
      },
      &quot;saleCount&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;hasStock&quot;: {
        &quot;type&quot;: &quot;boolean&quot;
      },
      &quot;hotScore&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;brandId&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;catalogId&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;brandName&quot;: {
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false,
        &quot;doc_values&quot;: false
      },
      &quot;brandImg&quot;: {
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false,
        &quot;doc_values&quot;: false
      },
      &quot;catalogName&quot;: {
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false,
        &quot;doc_values&quot;: false
      },
      &quot;attrs&quot;: {
        &quot;type&quot;: &quot;nested&quot;,
        &quot;properties&quot;: {
          &quot;attrId&quot;: {
            &quot;type&quot;: &quot;long&quot;
          },
          &quot;attrName&quot;: {
            &quot;type&quot;: &quot;keyword&quot;,
            &quot;index&quot;: false,
            &quot;doc_values&quot;: false
          },
          &quot;attrValue&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
          }
        }
      }
    }
  }
}
</code></pre>
<ol>
<li>创建一个和这个数据格式匹配的TO（领域模型）,完成product和search服务之间的数据传输</li>
<li>基本属性和品牌分类信息的sql查找和封装</li>
<li>远程调用库存服务，查看还有没有库存</li>
</ol>
<pre><code class="language-java">@Override
public List&lt;SkuHasStockVo&gt; getSkuHasStock(List&lt;Long&gt; skuIds) {
    List&lt;SkuHasStockVo&gt; collect = skuIds.stream().map(skuId -&gt; {
        SkuHasStockVo skuHasStockVo = new SkuHasStockVo();
        Long count = this.baseMapper.getSkuStock(skuId);
        skuHasStockVo.setHasStock(count &gt; 0);
        return skuHasStockVo;
    }).collect(Collectors.toList());
    return collect;
}
</code></pre>
<ol start="4">
<li>远程调用search服务，实现index给ES封装好的SkuEsModel</li>
</ol>
<pre><code class="language-java">/**
    * 保存上架商品数据到ES中
    * @param skuEsModels
    */
@Override
public boolean productStatusUp(List&lt;SkuEsModel&gt; skuEsModels) throws IOException {
    // 1. 给ES建立索引，并建立映射关系
    // 2. 给es保存数据
    BulkRequest bulkRequest = new BulkRequest();
    for (SkuEsModel model : skuEsModels) {
        IndexRequest indexRequest = new IndexRequest(EsConstant.PRODUCT_INDEX);
        // 设定indexRequest的id,内容
        indexRequest.id(model.getSkuId().toString());
        String s = JSON.toJSONString(model);
        indexRequest.source(s, XContentType.JSON);
        // 放入bulk中
        bulkRequest.add(indexRequest);
    }
    BulkResponse bulk = client.bulk(bulkRequest, MallElasticSearchConfig.COMMON_OPTIONS);
    // TODO 如果批量index操作有错误则记录log
    boolean b = bulk.hasFailures();
    List&lt;String&gt; collect = Arrays.stream(bulk.getItems()).filter(item -&gt;
            item.isFailed()
    ).map(item -&gt; {
        return item.getId();
    }).collect(Collectors.toList());
    log.error(&quot;商品上架出错,{}&quot;, collect);

    return b;
}
</code></pre>
<pre><code class="language-java">/**
* feign调用流程：
* 1. 构造请求数据，将对象转为json
* 2. 发送请求进行执行，执行成功会解码响应数据
* 3. 执行请求会有重试机制
*/
</code></pre>
<p>总体的javaService如下，流程还是有复杂度的</p>
<pre><code class="language-java">/**
    * 商品上架功能
    * @param spuId
    */
@Override
public void up(Long spuId) {
    //1. 组装需要的数据
    // 查询当前SpuId对应的SKU信息
    List&lt;SkuInfoEntity&gt; skus = skuInfoService.getSkusBySpuId(spuId);
    List&lt;Long&gt; skuIdList = skus.stream().map(SkuInfoEntity::getSkuId).collect(Collectors.toList());

    // TODO 查询当前Sku的所有可以被检索的规格属性 attrs
    List&lt;ProductAttrValueEntity&gt; baseAttrs = productAttrValueService.baseAttrListForSpu(spuId);
    List&lt;Long&gt; attrIds = baseAttrs.stream().map(attr -&gt; {
        return attr.getAttrId();
    }).collect(Collectors.toList());
    // 查询可检索属性的id
    List&lt;Long&gt; searchAttrIds = attrService.selectSearchAttrs(attrIds);
    Set&lt;Long&gt; idSet = new HashSet&lt;&gt;(searchAttrIds);
    // 筛选可检索的属性并封装
    // 先过滤掉不可检索的属性，再封装成SkuEsModel.Attrs的格式，方便后续保存
    List&lt;SkuEsModel.Attrs&gt; attrsList = baseAttrs.stream().filter(item -&gt; {
        return idSet.contains(item.getAttrId());
    }).map(item -&gt; {
        SkuEsModel.Attrs attrs1 = new SkuEsModel.Attrs();
        BeanUtils.copyProperties(item, attrs1);
        return attrs1;
    }).collect(Collectors.toList());

    // hasStock 发送远程查看有无库存
    Map&lt;Long, Boolean&gt; stockMap = null;
    try {
        R skuHasStock = wareFeignService.getSkuHasStock(skuIdList);
        TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt; typeReference = new TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt;() {};
        stockMap = skuHasStock.getData(typeReference).stream().collect(Collectors.toMap(SkuHasStockVo::getSkuId, item -&gt; item.getHasStock()));
    } catch (Exception e) {
        log.error(&quot;库存服务异常,原因{}&quot;,e);
    }

    // 封装SkuEsModel
    Map&lt;Long, Boolean&gt; finalStockMap = stockMap;
    List&lt;SkuEsModel&gt; upProducts = skus.stream().map(sku -&gt; {
        SkuEsModel esModel = new SkuEsModel();
        BeanUtils.copyProperties(sku, esModel);
        esModel.setSkuPrice(sku.getPrice());
        esModel.setSkuImg(sku.getSkuDefaultImg());

        // 设置库存，没有查询成功就认为有库存返回
        if(finalStockMap == null) {
            esModel.setHasStock(true);
        } else {
            esModel.setHasStock(finalStockMap.get(sku.getSkuId()));
        }

        // hotStock 热度评分默认置0
        esModel.setHotScore(0L);

        // 品牌信息
        BrandEntity brandEntity = brandService.getById(esModel.getBrandId());
        esModel.setBrandName(brandEntity.getName());
        esModel.setBrandImg(brandEntity.getLogo());
        // 分类信息
        CategoryEntity categoryEntity = categoryService.getById(esModel.getCatalogId());
        esModel.setCatalogName(categoryEntity.getName());
        // 设置SPU的可检索规格属性
        esModel.setAttrs(attrsList);
        return esModel;
    }).collect(Collectors.toList());

    // 发送给ES：提出search的远程调用
    R r = searchFeignService.productStatusUp(upProducts);
    if(r.getCode() == 0) {
        // 远程调用成功
        // 需要修改SPU的 publish_status 发布状态为已上架
        this.baseMapper.updateSpuStatus(spuId, ProductConstant.StatusEnum.SPU_UP.getCode());

    } else {
        // 远程调用失败
        // TODO 重复调用，接口幂等性问题，重试机制

    }
}
</code></pre>
<p>结果：<br>
<img src="https://dxone1.github.io//post-images/1636969745665.png" alt="" loading="lazy"></p>
<h2 id="搭建商城首页">搭建商城首页</h2>
<h3 id="使用thymeleaf渲染页面">使用thymeleaf渲染页面</h3>
<p>架构如下：<br>
<img src="https://dxone1.github.io//post-images/1636970274115.png" alt="" loading="lazy"></p>
<ol>
<li>导入thymeleaf的依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>将页面资源放入对应的微服务的项目文件夹：</p>
<pre><code class="language-txt">静态资源 -&gt; static
动态页面 -&gt; templates
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1636975188211.png" alt="" loading="lazy"></figure>
<h3 id="首页渲染分类功能">首页渲染分类功能</h3>
<ol>
<li>先设定欢迎页的路径映射，使用Thymeleaf解析</li>
<li>编写返回渲染分类信息的数据</li>
</ol>
<pre><code class="language-java">@GetMapping({&quot;/&quot;, &quot;/index.html&quot;})
public String indexPage(Model model) {
    // TODO 查出所有的一级分类
    List&lt;CategoryEntity&gt; categoryEntities = categoryService.getLevel1Categorys();
    // 使用model传数据
    model.addAttribute(&quot;categorys&quot;, categoryEntities);
    return &quot;index&quot;;
}
</code></pre>
<ol start="3">
<li>页面取出相关数据并渲染<br>
一级菜单</li>
</ol>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li th:each=&quot;category : ${categorys}&quot;&gt;
        &lt;a href=&quot;#&quot; class=&quot;header_main_left_a&quot; th:attr=&quot;ctg-data=${category.catId}&quot;&gt;&lt;b th:text=&quot;${category.name}&quot;&gt;家用电器111&lt;/b&gt;&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>二三级菜单<br>
根据需要返回的数据，构建一个vo</p>
<pre><code class="language-java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Catelog2Vo {
    private String catalog1Id; //一级父分类的id
    private List&lt;Object&gt; catalog3List; // 三级子分类
    private String id;
    private String name;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Catelog3Vo {
        private String catalog2Id; //二级父分类的id
        private String id;
        private String name;
    }
}
</code></pre>
<p>给出的js文件会发出请求，编写对应的控制器返回json数据</p>
<pre><code class="language-java">/**
    * 返回封装成json格式的二三级分类
    * @return
    */
@Override
public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJson() {
    // 查出所有一级分类
    List&lt;CategoryEntity&gt; level1Categorys = this.getLevel1Categorys();
    // 封装数据
    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; map = level1Categorys.stream().collect(Collectors.toMap(k -&gt; k.getCatId().toString(),
            v -&gt; {
                // 查询所有一级分类下的二级分类
                List&lt;CategoryEntity&gt; categoryEntities = baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(&quot;parent_cid&quot;, v.getCatId()));
                List&lt;Catelog2Vo&gt; catelog2Vos = null;
                if (categoryEntities != null) {
                    catelog2Vos = categoryEntities.stream().map(l2 -&gt; {
                        Catelog2Vo catelog2Vo = new Catelog2Vo(v.getCatId().toString(), null, l2.getCatId().toString(), l2.getName());
                        List&lt;CategoryEntity&gt; level3Catelog = baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(&quot;parent_cid&quot;, l2.getCatId()));
                        if(level3Catelog != null) {
                            List&lt;Catelog2Vo.Catelog3Vo&gt; collect = level3Catelog.stream().map(l3 -&gt; {
                                Catelog2Vo.Catelog3Vo catelog3Vo = new Catelog2Vo.Catelog3Vo(l2.getCatId().toString(), l3.getCatId().toString(), l3.getName());
                                return catelog3Vo;
                            }).collect(Collectors.toList());
                            catelog2Vo.setCatalog3List(collect);
                        }
                        return catelog2Vo;
                    }).collect(Collectors.toList());
                }
                return catelog2Vos;
            }));
    return map;
}
</code></pre>
<p>此时分类的渲染是实时从数据库更新的<br>
<img src="https://dxone1.github.io//post-images/1636978683545.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城项目 day9：elasticSearch入门和整合]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day9elasticsearch-ru-men-he-zheng-he/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day9elasticsearch-ru-men-he-zheng-he/">
        </link>
        <updated>2021-11-12T09:23:59.000Z</updated>
        <content type="html"><![CDATA[<p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。<br>
特点：</p>
<ul>
<li>分布式的实时文件存储，每个字段都被索引并可被搜索</li>
<li>分布式的实时分析搜索引擎--做不规则查询</li>
<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据<br>
Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。<br>
ES能做什么？<br>
全文检索（全部字段）、模糊查询（搜索）、数据分析（提供分析语法，例如聚合）</li>
</ul>
<h2 id="概念-以mysql为对照">概念-以mysql为对照</h2>
<p>index ：插入（动词）/database（名词）<br>
type：表<br>
document：记录 json格式<br>
属性<br>
<img src="https://dxone1.github.io//post-images/1636709631846.png" alt="" loading="lazy"><br>
倒排索引全文检索<br>
<img src="https://dxone1.github.io//post-images/1636710374484.png" alt="" loading="lazy"><br>
es默认存储在内存中，需要将mysql数据放入es中进行全文检索</p>
<h2 id="docker安装es">Docker安装ES</h2>
<p>ES可视化界面<br>
<img src="https://dxone1.github.io//post-images/1636712465525.png" alt="" loading="lazy"></p>
<h2 id="使用">使用</h2>
<p>GET /_cat/nodes： 查看所有节点<br>
GET /_cat/health： 查看 es 健康状况<br>
GET /_cat/master： 查看主节点<br>
GET /_cat/indices： 查看所有索引 show databases;<br>
增删改查使用不同类型的Http请求完成。也可以使用_bulk实现批量操作。<br>
高级：<br>
bool<br>
must/must not<br>
term<br>
match<br>
聚合 aggregations：均值，分类，最大最小值......<br>
映射 mapping：定义一个文档及其所包含的属性如何存储和索引<br>
ES7及以后已经移除了Type，即索引之下就是文档<br>
索引新建和迁移索引<br>
分词：在ES中安装ik分词器支持中文分词，支持自定义词库。通过安装Nginx返回词库信息：nginx作为分词的存储服务器，ik通过远程获取该分词器中的词库信息：存储在Nginx -&gt; /mydata/nginx/html/es/dict.txt中</p>
<h2 id="整合java后端">整合Java后端</h2>
<p>1） 、 9300： TCP</p>
<ul>
<li>spring-data-elasticsearch:transport-api.jar；
<ul>
<li>springboot 版本不同， transport-api.jar 不同， 不能适配 es 版本</li>
<li>7.x 已经不建议使用， 8 以后就要废弃</li>
</ul>
</li>
</ul>
<p>2） 、 9200： HTTP，发送请求获取</p>
<ul>
<li>JestClient： 非官方， 更新慢</li>
<li>RestTemplate： 模拟发 HTTP 请求， ES 很多操作需要自己封装， 麻烦</li>
<li>HttpClient： 同上</li>
<li>Elasticsearch-Rest-Client： 官方 RestClient， 封装了 ES 操作， API 层次分明， 上手简单</li>
</ul>
<p>选择Elasticsearch subproject :client:rest-high-level来进行，创建一个新的项目作为检索服务。</p>
<ol>
<li>引入依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;
    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;
    &lt;version&gt;7.4.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>编写配置</li>
</ol>
<pre><code class="language-java">@Bean
RestHighLevelClient client() {
    RestClientBuilder builder = RestClient.builder(new HttpHost(&quot;192.168.180.3&quot;, 9200,
&quot;http&quot;));
    return new RestHighLevelClient(builder);
}
</code></pre>
<ol start="3">
<li>requestOptions：请求的安全访问信息，index操作</li>
</ol>
<pre><code class="language-java">/**
    * 测试使用REST_Client进行elastic_search的index操作
    * @throws IOException
    */
@Test
public void indexData() throws IOException {
    IndexRequest indexRequest = new IndexRequest(&quot;users&quot;);
    indexRequest.id(&quot;1&quot;);
    //indexRequest.source(&quot;userName&quot;,&quot;zhangsan&quot;,&quot;age&quot;,18,&quot;gender&quot;,&quot;男&quot;);
    User user = new User();
    user.setUserName(&quot;张三&quot;);
    user.setAge(18);
    user.setGender(&quot;男&quot;);
    // 转为json
    String jsonString = JSON.toJSONString(user);
    indexRequest.source(jsonString, XContentType.JSON);
    // 发送请求执行index操作，带上Options
    IndexResponse index = client.index(indexRequest, MallElasticSearchConfig.COMMON_OPTIONS);
    System.out.println(index);
}
</code></pre>
<ol start="4">
<li>复杂的检索</li>
</ol>
<pre><code class="language-java">@Test
public void searchData() throws IOException {
    SearchRequest searchRequest = new SearchRequest();
    // 指定index
    searchRequest.indices(&quot;bank&quot;);
    // 条件
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    // match
    sourceBuilder.query(QueryBuilders.matchQuery(&quot;address&quot;,&quot;mill&quot;));
    sourceBuilder.aggregation(AggregationBuilders.terms(&quot;ageAgg&quot;).field(&quot;age&quot;).size(10));
    sourceBuilder.aggregation(AggregationBuilders.avg(&quot;avgBalance&quot;).field(&quot;balance&quot;));
    System.out.println(sourceBuilder.toString());
    //sourceBuilder.from();
    //sourceBuilder.size();
    //sourceBuilder.aggregation();
    searchRequest.source(sourceBuilder);
    // 查询
    SearchResponse response = client.search(searchRequest, MallElasticSearchConfig.COMMON_OPTIONS);
    // 结果
    //System.out.println(response.toString());
    //Map map = JSON.parseObject(searchRequest.toString(), Map.class);
    // 获取查到的数据
    SearchHits hits = response.getHits();
    SearchHit[] searchHits = hits.getHits();
    for (SearchHit searchHit : searchHits) {
        String hitSource = searchHit.getSourceAsString();
        Account account = JSON.parseObject(hitSource, Account.class);
        System.out.println(&quot;账号信息: &quot; + account);
    }
    // 获取聚合信息
    Aggregations aggregations = response.getAggregations();
    Terms ageAgg = aggregations.get(&quot;ageAgg&quot;);
    for (Terms.Bucket bucket : ageAgg.getBuckets()) {
        Number keyAsNumber = bucket.getKeyAsNumber();
        System.out.println(&quot;年龄&quot; + keyAsNumber + &quot;, 人数: &quot; + bucket.getDocCount());
    }

    Avg avgBalance = aggregations.get(&quot;avgBalance&quot;);
    System.out.println(&quot;平均薪资: &quot; + avgBalance.getValue());
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商城项目 day9：elasticSearch入门]]></title>
        <id>https://dxone1.github.io/post/shang-cheng-xiang-mu-day9elasticsearch-ru-men/</id>
        <link href="https://dxone1.github.io/post/shang-cheng-xiang-mu-day9elasticsearch-ru-men/">
        </link>
        <updated>2021-11-12T09:23:59.000Z</updated>
        <content type="html"><![CDATA[<p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。<br>
特点：</p>
<ul>
<li>分布式的实时文件存储，每个字段都被索引并可被搜索</li>
<li>分布式的实时分析搜索引擎--做不规则查询</li>
<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据<br>
Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。<br>
ES能做什么？<br>
全文检索（全部字段）、模糊查询（搜索）、数据分析（提供分析语法，例如聚合）</li>
</ul>
<h2 id="概念-以mysql为对照">概念-以mysql为对照</h2>
<p>index ：插入（动词）/database（名词）<br>
type：表<br>
document：记录 json格式<br>
属性<br>
<img src="https://dxone1.github.io//post-images/1636709631846.png" alt="" loading="lazy"><br>
倒排索引全文检索<br>
<img src="https://dxone1.github.io//post-images/1636710374484.png" alt="" loading="lazy"><br>
es默认存储在内存中，需要将mysql数据放入es中进行全文检索</p>
<h2 id="docker安装es">Docker安装ES</h2>
<p>ES可视化界面<br>
<img src="https://dxone1.github.io//post-images/1636712465525.png" alt="" loading="lazy"></p>
<h2 id="使用">使用</h2>
<p>GET /_cat/nodes： 查看所有节点<br>
GET /_cat/health： 查看 es 健康状况<br>
GET /_cat/master： 查看主节点<br>
GET /_cat/indices： 查看所有索引 show databases;<br>
增删改查使用不同类型的Http请求完成。也可以使用_bulk实现批量操作。<br>
高级：<br>
bool<br>
must/must not<br>
term<br>
match<br>
聚合 aggregations：均值，分类，最大最小值......<br>
映射 mapping：定义一个文档及其所包含的属性如何存储和索引<br>
ES7及以后已经移除了Type，即索引之下就是文档<br>
索引新建和迁移索引<br>
分词</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 番外：管理平台基础功能梳理]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-fan-wai-guan-li-ping-tai-ji-chu-gong-neng-shu-li/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-fan-wai-guan-li-ping-tai-ji-chu-gong-neng-shu-li/">
        </link>
        <updated>2021-11-12T06:43:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="业务实现">业务实现</h2>
<p>本部分主要实现了管理平台的商品和库存模块两个板块的内容，具体的业务树形图如下<br>
<img src="https://dxone1.github.io//post-images/1636699503943.png" alt="" loading="lazy"><br>
以下分别梳理各项业务功能</p>
<h3 id="1-分类维护功能">1 分类维护功能</h3>
<p>此部分使用element-ui搭建前端系统，实现了可以拖拽、修改、删除、添加的三级分类逻辑和后端持久化。在一般状态下可以展开、修改和添加分类。最后一级菜单不可以再添加。<br>
<img src="https://dxone1.github.io//post-images/1636699759831.png" alt="" loading="lazy"><br>
当开启拖拽功能后，可以通过直觉地拖拽完成分类的级别调整<br>
<img src="https://dxone1.github.io//post-images/1636699862828.png" alt="" loading="lazy"></p>
<h3 id="2-品牌管理功能">2 品牌管理功能</h3>
<p>该页面允许添加品牌，并将其关联到一些分类中。例如华为可以关联手机、平板电脑、电视等<br>
<img src="https://dxone1.github.io//post-images/1636699983562.png" alt="" loading="lazy"></p>
<h3 id="3-平台属性功能">3 平台属性功能</h3>
<p>首先需要梳理SKU和SPU两个概念，SPU是某型产品的规格，而SKU是该型产品提供的高中低搭配的销售属性，往往以商品颜色、手机的内存规格等区分。我们将它们都关联到一个具体的分类中，SPU属性都归为一个属性分组以方便显示，例如如下的京东商城页面<br>
<img src="https://dxone1.github.io//post-images/1636700297498.png" alt="" loading="lazy"></p>
<ol>
<li>属性分组<br>
可以修改、删除、新增分组。每个属性分组都归属于某个分类中。查询部分支持按照id严格搜索或是分组名模糊搜索<br>
<img src="https://dxone1.github.io//post-images/1636700811510.png" alt="" loading="lazy"><br>
关联部分则会查找回显当前分组关联的规格参数（SPU属性），新建关联会回显当前分类未被归属到某个分组的属性<br>
<img src="https://dxone1.github.io//post-images/1636701017773.png" alt="" loading="lazy"></li>
<li>规格参数（SPU属性）<br>
<img src="https://dxone1.github.io//post-images/1636700733543.png" alt="" loading="lazy"></li>
<li>销售属性<br>
销售属性也是跟分类关联的，但是不属于某个分组<br>
<img src="https://dxone1.github.io//post-images/1636701102280.png" alt="" loading="lazy"></li>
</ol>
<h3 id="4-商品维护功能">4 商品维护功能</h3>
<p>该部分可以实现SPU管理、发布商品、商品管理的功能，功能的前端页面如图<br>
<img src="https://dxone1.github.io//post-images/1636701197594.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636701217115.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636701242694.png" alt="" loading="lazy"><br>
商品发布部分可以添加商品介绍页和商品图集，这部分是通过阿里云的OOS文件服务器实现的，因为本项目目标是分布式部署，为了文件系统的一致性使用本服务器签名后保存到阿里云服务器的方式。</p>
<h3 id="5-仓库维护">5 仓库维护</h3>
<p>库存维护功能可以直接修改和新增仓库<br>
<img src="https://dxone1.github.io//post-images/1636701482557.png" alt="" loading="lazy"></p>
<h3 id="6-商品库存">6 商品库存</h3>
<p>该功能可以直接新增库存项和修改库存内容，也支持检索。一个库存项的典型表格如下<br>
<img src="https://dxone1.github.io//post-images/1636701565873.png" alt="" loading="lazy"></p>
<h3 id="7-采购单部分">7 采购单部分</h3>
<p>采购逻辑是提出采购需求 -&gt; 合并整单（创建新单或给某个采购单）-&gt; 采购接单 -&gt; 采购完成 -&gt; 更新采购单和采购需求状态<br>
<img src="https://dxone1.github.io//post-images/1636701718971.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636701736919.png" alt="" loading="lazy"></p>
<h2 id="技术和开发trick">技术和开发trick</h2>
<p>分布式相关：nacos服务发现，OpenFeign远程调用，gateWay服务网关<br>
前端：vue组件和element-ui模板<br>
Linux：centOS7 + docker<br>
新技术规范：全局统一异常处理ExceptionHandler，JSR303后端数据校验，使用枚举类型定义业务状态码，VO视图实体和PO远程调用实体</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day 8：商品和仓库管理]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day-8shang-pin-he-cang-ku-guan-li/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day-8shang-pin-he-cang-ku-guan-li/">
        </link>
        <updated>2021-11-11T06:48:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="spu组合搜索功能">SPU组合搜索功能</h2>
<p><img src="https://dxone1.github.io//post-images/1636614407614.png" alt="" loading="lazy"><br>
看到其中不仅有商品ID商品名等信息还有分类等组合查询</p>
<pre><code class="language-java">@Override
public PageUtils queryPageByCondition(Map&lt;String, Object&gt; params) {
    QueryWrapper&lt;SpuInfoEntity&gt; wrapper = new QueryWrapper&lt;&gt;();
    /**
        * 根据以下信息组合查询
        * status:
        * key:
        * brandId: 0
        * catelogId: 0
        */
    String key = (String) params.get(&quot;key&quot;);
    if(!StringUtils.isEmpty(key)) {
        wrapper.and(w -&gt; {
            w.eq(&quot;id&quot;, key).or().like(&quot;spu_name&quot;, key);
        });
    }
    String status = (String) params.get(&quot;status&quot;);
    if(!StringUtils.isEmpty(status)) {
        wrapper.eq(&quot;publish_status&quot;, status);

    }
    String brandId = (String) params.get(&quot;brandId&quot;);
    if(!StringUtils.isEmpty(brandId)) {
        wrapper.eq(&quot;brand_id&quot;, brandId);
    }
    String catelogId = (String) params.get(&quot;catelogId&quot;);
    if(!StringUtils.isEmpty(catelogId)) {
        wrapper.eq(&quot;catalog_id&quot;, catelogId);
    }
    IPage&lt;SpuInfoEntity&gt; page = this.page(new Query&lt;SpuInfoEntity&gt;().getPage(params),
            wrapper);
    return new PageUtils(page);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1636615251501.png" alt="" loading="lazy"></figure>
<h2 id="sku检索功能">SKU检索功能</h2>
<p>一样的内容，组合检索<br>
<img src="https://dxone1.github.io//post-images/1636617236425.png" alt="" loading="lazy"></p>
<h2 id="仓库维护">仓库维护</h2>
<figure data-type="image" tabindex="2"><img src="https://dxone1.github.io//post-images/1636618921114.png" alt="" loading="lazy"></figure>
<h2 id="商品库存">商品库存</h2>
<p>请求 URL: http://localhost:88/api/ware/waresku/list?t=1636618949796&amp;page=1&amp;limit=10&amp;skuId=&amp;wareId=</p>
<pre><code class="language-txt">t: 1636618949796
page: 1
limit: 10
skuId: 
wareId: 
</code></pre>
<h2 id="库存管理">库存管理</h2>
<p>注意，生产环境中不能直接而在商品库存添加库存，而是通过采购单来进行维护添加。流程是：<br>
采购需求(合并整单) -&gt; 采购单 -&gt; 库存添加<br>
<img src="https://dxone1.github.io//post-images/1636619627154.png" alt="" loading="lazy"></p>
<ol>
<li>采购需求整单的逻辑<br>
<img src="https://dxone1.github.io//post-images/1636620152697.png" alt="" loading="lazy"><br>
在采购单页面可以创建新增的采购单，在采购需求合并整单的时候需要将其合并到该单中。需要能够查询采购单。<br>
<img src="https://dxone1.github.io//post-images/1636620313865.png" alt="" loading="lazy"><br>
接口：http://localhost:88/api/ware/purchase/unreceive/list?t=1636620326054<br>
定义如下：<br>
<img src="https://dxone1.github.io//post-images/1636620731059.png" alt="" loading="lazy"><br>
所以查询所有新建/已分配的采购单（都还没有出发采购）<br>
合并采购需求发送一个POST请求：<br>
请求 URL: http://localhost:88/api/ware/purchase/merge<br>
<img src="https://dxone1.github.io//post-images/1636620991832.png" alt="" loading="lazy"><br>
也有可能不提交采购单而快速创建新单，则请求体中没有purchaseId，必须自动创建。<br>
编写功能</li>
</ol>
<pre><code class="language-java">@Transactional
@Override
public void mergePurchase(MerageVo merageVo) {
    Long purchaseId = merageVo.getPurchaseId();
    // 没有采购单ID要新建一个采购单
    if(purchaseId == null) {
        PurchaseEntity purchaseEntity = new PurchaseEntity();
        purchaseEntity.setStatus(WareConstant.PurchaseStatusEnum.CREATED.getCode());
        purchaseEntity.setCreateTime(new Date());
        purchaseEntity.setUpdateTime(new Date());
        this.save(purchaseEntity);
        // 新建的采购单的ID
        purchaseId = purchaseEntity.getId();
    }
    // 把采购单信息保存到采购需求中
    List&lt;Long&gt; items = merageVo.getItems();
    Long finalPurchaseId = purchaseId;
    List&lt;PurchaseDetailEntity&gt; collect = items.stream().map(i -&gt; {
        PurchaseDetailEntity detailEntity = new PurchaseDetailEntity();
        detailEntity.setId(i);
        detailEntity.setPurchaseId(finalPurchaseId);
        detailEntity.setStatus(WareConstant.PurchaseDetailEnum.ASSIGNED.getCode());
        return detailEntity;
    }).collect(Collectors.toList());
    purchaseDetailService.updateBatchById(collect);
}
</code></pre>
<ol start="2">
<li>领取采购单<br>
在采购单被分配后需要人员领取，领取之后状态需要变化<br>
当采购完成后也需要结束采购<br>
这两个功能的发出使用postMan进行模拟，本项目不涉及其页面和业务的开发，领取采购单的APP模拟如下：<br>
<img src="https://dxone1.github.io//post-images/1636623430355.png" alt="" loading="lazy"></li>
</ol>
<pre><code class="language-java">@Override
public void received(List&lt;Long&gt; ids) {
    //1. 确认当前采购单是新建/已分配
    List&lt;PurchaseEntity&gt; collect = ids.stream().map(id -&gt; {
        PurchaseEntity purchaseEntity = this.getById(id);
        return purchaseEntity;
    }).filter(item -&gt; {
        // 必须是新建/已分配的采购单
        return item.getStatus() == WareConstant.PurchaseStatusEnum.CREATED.getCode() ||
                item.getStatus() == WareConstant.PurchaseStatusEnum.ASSIGNED.getCode();
    }).map(item -&gt; {
        //2. 改变采购单的状态
        item.setStatus(WareConstant.PurchaseStatusEnum.RECEIVED.getCode());
        item.setUpdateTime(new Date());
        return item;
    }).collect(Collectors.toList());

    // 实际更新采购单状态
    this.updateBatchById(collect);

    //3. 改变采购单采购项的状态
    collect.forEach(item -&gt; {
        Long purchaseId = item.getId();
        List&lt;PurchaseDetailEntity&gt; purchaseDetailEntities = purchaseDetailService.listDetailByPurchaseId(purchaseId);
        List&lt;PurchaseDetailEntity&gt; detailEntities = purchaseDetailEntities.stream().map(entity -&gt; {
            PurchaseDetailEntity purchaseDetailEntity = new PurchaseDetailEntity();
            purchaseDetailEntity.setId(entity.getId());
            purchaseDetailEntity.setStatus(WareConstant.PurchaseDetailEnum.BUYING.getCode());
            return purchaseDetailEntity;
        }).collect(Collectors.toList());
        purchaseDetailService.updateBatchById(detailEntities);
    });
}
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1636624822561.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636624825855.png" alt="" loading="lazy"></p>
<h2 id="完成采购">完成采购</h2>
<p>完成采购后会发出一个请求，必须进行商品库存的服务调用。<br>
<img src="https://dxone1.github.io//post-images/1636633148544.png" alt="" loading="lazy"></p>
<pre><code class="language-java">@Override
public void addStock(Long skuId, Long wareId, Integer skuNum) {
    // 1. 如果还没有库存记录则新增
    List&lt;WareSkuEntity&gt; entities = wareSkuDao.selectList(new QueryWrapper&lt;WareSkuEntity&gt;().eq(&quot;sku_id&quot;, skuId).eq(&quot;ware_id&quot;, wareId));
    if(entities == null || entities.size() == 0) {
        WareSkuEntity skuEntity = new WareSkuEntity();
        skuEntity.setSkuId(skuId);
        skuEntity.setStock(skuNum);
        skuEntity.setWareId(wareId);
        skuEntity.setStockLocked(0);
        //远程调用查询skuName冗余备份
        // TODO 还有什么办法不回滚处理异常
        try {
            R info = productFeignService.info(skuId);
            Map&lt;String, Object&gt; data = (Map&lt;String, Object&gt;) info.get(&quot;skuInfo&quot;);
            if(info.getCode() == 0) {
                skuEntity.setSkuName((String) data.get(&quot;skuName&quot;));
            }
        } catch (Exception e) {

        }
        wareSkuDao.insert(skuEntity);
    } else {
        // 否则增加库存
        wareSkuDao.addStock(skuId, wareId, skuNum);
    }
}
</code></pre>
<p>测试实例：<br>
<img src="https://dxone1.github.io//post-images/1636638183522.png" alt="" loading="lazy"></p>
<h2 id="spu管理">Spu管理</h2>
<p>也是分为展示、修改两个功能模块</p>
<pre><code class="language-java">/**
    * 展示SPU属性
    * @param spuId
    * @return
    */
@Override
public List&lt;ProductAttrValueEntity&gt; baseAttrListForSpu(Long spuId) {
    List&lt;ProductAttrValueEntity&gt; entities = this.baseMapper.selectList(new QueryWrapper&lt;ProductAttrValueEntity&gt;().eq(&quot;spu_id&quot;, spuId));
    return entities;
}

/**
    * 修改SPU属性
    * @param spuId
    * @param entities
    */
@Transactional
@Override
public void updateSpuAttr(Long spuId, List&lt;ProductAttrValueEntity&gt; entities) {
    //1. 删除原有属性
    this.baseMapper.delete(new QueryWrapper&lt;ProductAttrValueEntity&gt;().eq(&quot;spu_id&quot;, spuId));
    //2. 插入新属性
    List&lt;ProductAttrValueEntity&gt; collect = entities.stream().map(item -&gt; {
        item.setSpuId(spuId);
        return item;
    }).collect(Collectors.toList());
    this.saveBatch(collect);
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://dxone1.github.io//post-images/1636694892686.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day7：发布商品功能]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day7/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day7/">
        </link>
        <updated>2021-11-10T02:19:53.000Z</updated>
        <content type="html"><![CDATA[<p>继续完善后台管理系统的各种功能，首先编写商品维护系统中的发布商品功能</p>
<h2 id="发布商品">发布商品</h2>
<p>前端页面如下<br>
<img src="https://dxone1.github.io//post-images/1636510989235.png" alt="" loading="lazy"><br>
首先会发出请求会员等级，请求方式为Get，地址为http://localhost:88/api/member/memberlevel/list?t=1636511786443&amp;page=1&amp;limit=500，返回分页数据<br>
在后端写逻辑，其实不用在这里写，写在用户系统中，调整即可。<br>
会员等级页面：<br>
<img src="https://dxone1.github.io//post-images/1636513825943.png" alt="" loading="lazy"></p>
<ol>
<li>获取分类关联的品牌<br>
在发布商品页面如果选择分类会发送一个请求关联品牌，编写相关的后端逻辑<br>
GET：http://localhost:88/api/product/categorybrandrelation/brands/list?t=1636514532755&amp;catId=225</li>
</ol>
<pre><code class="language-java">@Override
public List&lt;BrandEntity&gt; getBrandsByCatId(Long catId) {
    List&lt;CategoryBrandRelationEntity&gt; relationEntities = relationDao.selectList(new QueryWrapper&lt;CategoryBrandRelationEntity&gt;().eq(&quot;catelog_id&quot;, catId));
    List&lt;BrandEntity&gt; collect = relationEntities.stream().map(item -&gt; {
        Long brandId = item.getBrandId();
        BrandEntity brandEntity = brandService.getById(brandId);
        return brandEntity;
    }).collect(Collectors.toList());
    return collect;
}
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1636515964281.png" alt="" loading="lazy"><br>
2. 获取分类下所有分组和基本属性<br>
<img src="https://dxone1.github.io//post-images/1636516276038.png" alt="" loading="lazy"><br>
这个页面要求获取所选分类下所有分组和基本属性</p>
<pre><code class="language-java">/**
    * 根据分类id查询所有的group以及其中的属性
    * @param catelogId
    * @return
    */
@Override
public List&lt;AttrGroupWithAttrsVo&gt; getAttrGroupWithAttrsByCatelogId(Long catelogId) {
    // 查出所有分组
    List&lt;AttrGroupEntity&gt; groupEntities = this.list(new QueryWrapper&lt;AttrGroupEntity&gt;().eq(&quot;catelog_id&quot;, catelogId));
    // 查询所有属性
    List&lt;AttrGroupWithAttrsVo&gt; collect = groupEntities.stream().map(group -&gt; {
        AttrGroupWithAttrsVo attrGroupWithAttrsVo = new AttrGroupWithAttrsVo();
        // 封装
        BeanUtils.copyProperties(group, attrGroupWithAttrsVo);
        // 查询属性
        Long attrGroupId = group.getAttrGroupId();
        List&lt;AttrEntity&gt; attrEntities = attrService.getRelationAttr(attrGroupId);
        attrGroupWithAttrsVo.setAttrs(attrEntities);

        return attrGroupWithAttrsVo;
    }).collect(Collectors.toList());

    return collect;
}
</code></pre>
<p>效果<br>
<img src="https://dxone1.github.io//post-images/1636519102576.png" alt="" loading="lazy"><br>
3. 返回的是一个很大的Json串，为了合理的封装使用一个SpuSaveVo封装。使用在线的生成工具即可生成，然后编写保存逻辑，以下是业务逻辑</p>
<pre><code class="language-txt">//1. 保存SPU基本信息 pms_spu_info
//2. 保存SPU的描述图片 pms_spu_info_desc
//3. 保存SPU的图片集 pms_spu_images
//4. 保存SPU的规格参数 pms_product_attr_value
//5. 保存SPU的积分信息 跨库：mall_sms -&gt; sms_spu_bounds
//6. 保存当前SPU对应的所有SKU信息
    //6.1. SKU的基本信息 pms_sku_info
    //6.2. SKU的图片 pms_sku_images
    //6.3. SKU的销售属性 pms_sku_sale_attr_value
    //6.4. SKU的优惠信息 跨库：mall_sms -&gt; sms_sku_ladder, sms_sku_full_reduction, sms_member_price
</code></pre>
<p>注意有两个跨服务逻辑：使用mall-coupon提供的远程调用，使用openFeign。服务间调用使用TO封装数据，都是传递json</p>
<pre><code class="language-java">@Transactional
@Override
public void saveSpuInfo(SpuSaveVo vo) {
    //1. 保存SPU基本信息 pms_spu_info
    SpuInfoEntity infoEntity = new SpuInfoEntity();
    BeanUtils.copyProperties(vo, infoEntity);
    infoEntity.setCreateTime(new Date());
    infoEntity.setUpdateTime(new Date());
    this.saveBaseSpuInfo(infoEntity);

    //2. 保存SPU的描述图片 pms_spu_info_desc
    List&lt;String&gt; decript = vo.getDecript();
    SpuInfoDescEntity descEntity = new SpuInfoDescEntity();
    descEntity.setSpuId(infoEntity.getId());
    descEntity.setDecript(String.join(&quot;,&quot;, decript));
    spuInfoDescService.saveSpuInfoDesc(descEntity);

    //3. 保存SPU的图片集 pms_spu_images
    List&lt;String&gt; images = vo.getImages();
    spuImagesService.saveImages(infoEntity.getId(), images);

    //4. 保存SPU的规格参数 pms_product_attr_value
    List&lt;BaseAttrs&gt; baseAttrs = vo.getBaseAttrs();
    List&lt;ProductAttrValueEntity&gt; collect = baseAttrs.stream().map(attr -&gt; {
        ProductAttrValueEntity valueEntity = new ProductAttrValueEntity();
        valueEntity.setAttrId(attr.getAttrId());
        // 查属性entity
        AttrEntity attrEntity = attrService.getById(attr.getAttrId());
        valueEntity.setAttrName(attrEntity.getAttrName());
        valueEntity.setAttrValue(attr.getAttrValues());
        valueEntity.setQuickShow(attr.getShowDesc());
        valueEntity.setSpuId(infoEntity.getId());
        return valueEntity;
    }).collect(Collectors.toList());
    productAttrValueService.saveProductAttr(collect);

    //5. 保存SPU的积分信息 跨库：mall_sms -&gt; sms_spu_bounds
    // 封装远程调用数据
    Bounds bounds = vo.getBounds();
    SpuBoundTo spuBoundTo = new SpuBoundTo();
    BeanUtils.copyProperties(bounds, spuBoundTo);
    spuBoundTo.setSpuId(infoEntity.getId());
    // 远程调用
    R r = couponFeignService.saveSpuBounds(spuBoundTo);
    if(r.getCode() != 0) {
        log.error(&quot;远程保存spu积分信息失败&quot;);
    }

    //6. 保存当前SPU对应的所有SKU信息
    List&lt;Skus&gt; skus = vo.getSkus();
    if(skus != null &amp;&amp; skus.size() &gt; 0) {
        skus.forEach(item -&gt; {
            // 获取默认图片
            String defaultImg = &quot;&quot;;
            for(Images image: item.getImages()) {
                if(image.getDefaultImg() == 1) {
                    defaultImg = image.getImgUrl();
                }
            }
            ///基本信息
            //6.1. SKU的基本信息 pms_sku_info
            SkuInfoEntity skuInfoEntity = new SkuInfoEntity();
            BeanUtils.copyProperties(item, skuInfoEntity);
            // 手动注入剩下的属性
            skuInfoEntity.setBrandId(infoEntity.getBrandId());
            skuInfoEntity.setCatalogId(infoEntity.getCatalogId());
            skuInfoEntity.setSaleCount(0L);
            skuInfoEntity.setSpuId(infoEntity.getId());
            skuInfoEntity.setSkuDefaultImg(defaultImg);
            skuInfoService.saveSkuInfo(skuInfoEntity);

            // sku自增主键
            Long skuId = skuInfoEntity.getSkuId();

            //6.2. 保存SKU的图片 pms_sku_images
            List&lt;SkuImagesEntity&gt; imagesEntities = item.getImages().stream().map(img -&gt; {
                SkuImagesEntity skuImagesEntity = new SkuImagesEntity();
                skuImagesEntity.setSkuId(skuId);
                skuImagesEntity.setImgUrl(img.getImgUrl());
                skuImagesEntity.setDefaultImg(img.getDefaultImg());
                return skuImagesEntity;
            }).filter(entity -&gt; {
                // 返回true需要，否则抛弃
                return !StringUtils.isEmpty(entity.getImgUrl());
            }).collect(Collectors.toList());
            skuImagesService.saveBatch(imagesEntities);

            //6.3. SKU的销售属性 pms_sku_sale_attr_value
            List&lt;Attr&gt; attr = item.getAttr();
            List&lt;SkuSaleAttrValueEntity&gt; skuSaleAttrValueEntities = attr.stream().map(a -&gt; {
                SkuSaleAttrValueEntity skuSaleAttrValueEntity = new SkuSaleAttrValueEntity();
                BeanUtils.copyProperties(a, skuSaleAttrValueEntity);
                skuSaleAttrValueEntity.setSkuId(skuInfoEntity.getSkuId());
                return skuSaleAttrValueEntity;
            }).collect(Collectors.toList());
            skuSaleAttrValueService.saveBatch(skuSaleAttrValueEntities);

            //6.4. SKU的优惠信息 跨库：mall_sms -&gt; sms_sku_ladder, sms_sku_full_reduction, sms_member_price
            SkuReductionTo skuReductionTo = new SkuReductionTo();
            BeanUtils.copyProperties(item, skuReductionTo);
            skuReductionTo.setSkuId(skuId);
            if(skuReductionTo.getFullCount() &gt;0 || (skuReductionTo.getFullPrice() != null &amp;&amp; skuReductionTo.getFullPrice().compareTo(new BigDecimal(&quot;0&quot;)) == 1)){
                R r1 = couponFeignService.saveSkuReduction(skuReductionTo);
                if(r1.getCode() != 0) {
                    log.error(&quot;远程保存sku积分信息失败&quot;);
                }
            }
        });
    }
</code></pre>
<p>调试需要花费很大的心思，而且并不足够健壮。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day6：平台参数]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day6ping-tai-can-shu/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day6ping-tai-can-shu/">
        </link>
        <updated>2021-11-09T03:33:51.000Z</updated>
        <content type="html"><![CDATA[<p>在平台属性功能，属性和分组需要相互关联。每个分组可能关联多个属性。规格参数功能模块会录入各种基础的属性。本日的项目目标是完成平台属性和属性的分组的相关的功能。属性分为规格参数和销售属性两类。分类和分组相互关联，每个属性会属于某个属性分组</p>
<h2 id="规格参数分组">规格参数分组</h2>
<p>规格参数是一种属性，属性属于某个分组。<br>
<img src="https://dxone1.github.io//post-images/1636429846172.png" alt="" loading="lazy"><br>
之前的工作中，品牌和分类已经通过中间表进行了多对多的相互关联。这里的参数属于某个属性分组，也通过一个中间表记录了关系。<br>
<img src="https://dxone1.github.io//post-images/1636429973290.png" alt="" loading="lazy"></p>
<ol>
<li>新增规格参数（需要指定其属性分组和分类）<br>
通过代码生成器生成的项目，如果调用属性的save功能则只会在pms_attr中保存，而不会在pms_attr_attrgroup_relation中保存关联关系，需要重写该方法。<br>
在项目包下写一个vo包，将值对象（视图对象）封装起来<br>
用处：接收页面传递来的数据，封装对象。将业务处理完成的对象，封装成页面要用的数据。<br>
编写一个attrvo的实体类，封装属性拥有的所有内容<br>
逻辑就是实体类的分层，vo只负责和页面交互，entity只负责和dao打交道。</li>
</ol>
<pre><code class="language-java">// AttrService
@Transactional
@Override
public void saveAttr(AttrVo attr) {
    // 保存基本数据
    // 先使用Entity将页面中的属性抽取出需要保存到数据库中的部分保存
    AttrEntity attrEntity = new AttrEntity();
    // 将attr中的属性拷贝到attrEntity中
    BeanUtils.copyProperties(attr, attrEntity);
    this.save(attrEntity);

    // 保存到关联关系中
    AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity();
    // 两个需要提交
    // 1. 属性分组id
    // 2. 属性id
    // 也是都从页面中拿
    relationEntity.setAttrGroupId(attr.getAttrGroupId());
    relationEntity.setAttrId(attrEntity.getAttrId());
    // 保存之后attrId也有了
    attrAttrgroupRelationDao.insert(relationEntity);
}
</code></pre>
<ol start="2">
<li>查询规格参数<br>
通过接口<code>/product/attr/base/list/225</code>访问。一样编写查询规格参数的特殊方法，原理和之前的属性分组一致，严格匹配属性id或者模糊匹配属性名。</li>
</ol>
<pre><code class="language-java">@Override
public PageUtils queryBaseAttrPage(Map&lt;String, Object&gt; params, Long catelogId) {
    QueryWrapper&lt;AttrEntity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    //if(StringUtils)

    if(catelogId != 0) {
        queryWrapper.eq(&quot;catelog_id&quot;, catelogId);
    }

    String key = (String) params.get(&quot;key&quot;);
    if(!StringUtils.isEmpty(key)) {
        queryWrapper.and((wrapper) -&gt; {
            wrapper.eq(&quot;attr_id&quot;, key).or().like(&quot;attr_name&quot;, key);
        });
    }

    IPage&lt;AttrEntity&gt; page = this.page(
            new Query&lt;AttrEntity&gt;().getPage(params),
            queryWrapper
    );
    return null;
}
</code></pre>
<p>注意返回需要有所属分类和分组的名字，也需要通过vo返回。重新编写查询逻辑</p>
<pre><code class="language-java">@Override
public PageUtils queryBaseAttrPage(Map&lt;String, Object&gt; params, Long catelogId) {
    QueryWrapper&lt;AttrEntity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    //if(StringUtils)

    if(catelogId != 0) {
        queryWrapper.eq(&quot;catelog_id&quot;, catelogId);
    }

    String key = (String) params.get(&quot;key&quot;);
    if(!StringUtils.isEmpty(key)) {
        queryWrapper.and((wrapper) -&gt; {
            wrapper.eq(&quot;attr_id&quot;, key).or().like(&quot;attr_name&quot;, key);
        });
    }

    IPage&lt;AttrEntity&gt; page = this.page(
            new Query&lt;AttrEntity&gt;().getPage(params),
            queryWrapper
    );
    List&lt;AttrEntity&gt; records = page.getRecords();
    List&lt;AttrRespVo&gt; respVos = records.stream().map(attrEntity -&gt; {
        AttrRespVo attrRespVo = new AttrRespVo();
        BeanUtils.copyProperties(attrEntity, attrRespVo);
        // 设置分类分组名
        AttrAttrgroupRelationEntity relationEntity = attrAttrgroupRelationDao.selectOne(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;()
                .eq(&quot;attr_id&quot;, attrEntity.getAttrId()));
        if (relationEntity != null) {
            AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(relationEntity.getAttrGroupId());
            attrRespVo.setGroupName(attrGroupEntity.getAttrGroupName());
        }
        CategoryEntity categoryEntity = categoryDao.selectById(attrEntity.getCatelogId());
        if (categoryEntity != null) {
            attrRespVo.setCatelogName(categoryEntity.getName());
        }

        return attrRespVo;
    }).collect(Collectors.toList());

    PageUtils pageUtils = new PageUtils(page);
    pageUtils.setList(respVos);
    
    return pageUtils;
}
</code></pre>
<ol start="3">
<li>修改属性需要提供分类路径和分组的回显</li>
</ol>
<pre><code class="language-java">@Override
public AttrRespVo getAttrInfo(Long attrId) {
    AttrRespVo attrRespVo = new AttrRespVo();

    AttrEntity attrEntity = this.getById(attrId);
    BeanUtils.copyProperties(attrEntity, attrRespVo);
    // 设置分组id
    AttrAttrgroupRelationEntity relationEntity = attrAttrgroupRelationDao.selectOne(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_id&quot;, attrId));
    if(relationEntity != null) {
        attrRespVo.setAttrGroupId(relationEntity.getAttrGroupId());
        // 设置分组信息
        AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(relationEntity.getAttrGroupId());
        if(attrGroupEntity != null) {
            attrRespVo.setGroupName(attrGroupEntity.getAttrGroupName());
        }
    }
    // 设置分类信息:属性创建必须有名字
    Long catelogId = attrEntity.getCatelogId();
    Long[] catelogPath = categoryService.findCatelogPath(catelogId);
    attrRespVo.setCatelogPath(catelogPath);
    CategoryEntity categoryEntity = categoryDao.selectById(catelogId);
    if(categoryEntity != null) {
        attrRespVo.setCatelogName(categoryEntity.getName());
    }
    return attrRespVo;
}
</code></pre>
<ol start="4">
<li>因为有关联操作，所以必须使用vo提供更多的值进行关联修改</li>
</ol>
<pre><code class="language-java">@Transactional
@Override
public void updateAttr(AttrVo attr) {
    AttrEntity attrEntity = new AttrEntity();
    BeanUtils.copyProperties(attr, attrEntity);
    this.updateById(attrEntity);

    AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity();
    relationEntity.setAttrGroupId(attr.getAttrGroupId());
    relationEntity.setAttrId(attr.getAttrId());

    Integer cnt = attrAttrgroupRelationDao.selectCount(new UpdateWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_id&quot;, attr.getAttrId()));
    if(cnt &gt; 0) {
        // 1. 修改分组关联
        attrAttrgroupRelationDao.update(relationEntity,
                new UpdateWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_id&quot;, attr.getAttrId()));
    } else {
        // 没有则创建关联的分组
        attrAttrgroupRelationDao.insert(relationEntity);
    }
}
</code></pre>
<h2 id="销售属性和规格参数非常相似的业务逻辑">销售属性：和规格参数非常相似的业务逻辑</h2>
<p><code>/product/attr/sale/list/0</code><br>
可以在之前的controller和service上直接拓展，使得sql要求attr_type相同（销售属性或规格参数）。注意销售属性没有属性分组，不需要保存关联关系。<br>
效果如下：<br>
<img src="https://dxone1.github.io//post-images/1636457666897.png" alt="" loading="lazy"></p>
<h2 id="分组关联规格参数">分组关联规格参数</h2>
<p>规格参数属于基本信息，是SPU的部分，会和属性分组相互关联。本部分完成属性分组关联规格参数的功能。<br>
<img src="https://dxone1.github.io//post-images/1636457883839.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636457934335.png" alt="" loading="lazy"></p>
<ol>
<li>分组关联属性查询展示<br>
接口： http://localhost:88/api/product/attrgroup/{attrgroupId}/attr/relation?t=1636457954138</li>
</ol>
<pre><code class="language-java">/**
    * 根据分组id查关联属性的属性名和可选值
    * @param attrgroupId
    * @return
    */
@Override
public List&lt;AttrEntity&gt; getRelationAttr(Long attrgroupId) {
    List&lt;AttrAttrgroupRelationEntity&gt; relationEntities = attrAttrgroupRelationDao.selectList(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_group_id&quot;, attrgroupId));
    List&lt;Long&gt; attrIds = relationEntities.stream().map(attr -&gt; {
        return attr.getAttrId();
    }).collect(Collectors.toList());

    Collection&lt;AttrEntity&gt; attrEntities = this.listByIds(attrIds);
    return (List&lt;AttrEntity&gt;) attrEntities;
}
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1636458651627.png" alt="" loading="lazy"><br>
2. 移除关联属性<br>
接口：http://localhost:88/api/product/attrgroup/attr/relation/delete<br>
POST: attrId和attrGroupId构造为请求参数<br>
3. 也需要提供通过属性分组页面快速添加关联的属性的功能：<br>
<strong>首先是显示出合理的可添加属性</strong><br>
<img src="https://dxone1.github.io//post-images/1636460844427.png" alt="" loading="lazy"><br>
已经关联过的不能显示了，需要查询哪些属性还可以添加到当前关联分组中。即本分类下的，还没有被其他属性分组关联过的属性<br>
接口：http://localhost:88/api/product/attrgroup/1/noattr/relation?t=1636460932886&amp;page=1&amp;limit=10&amp;key=</p>
<pre><code class="language-java">/**
    * 获取当前分组中没有关联的所有属性
    * 1.必须属于自己所属的分类
    * 2.别的分组不能引用过
    * @param params
    * @param attrgroupId
    * @return
    */
@Override
public PageUtils getNoRelationAttr(Map&lt;String, Object&gt; params, Long attrgroupId) {
    AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(attrgroupId);
    // 分类id
    Long catelogId = attrGroupEntity.getCatelogId();
    // 查当前分类下的其他分组
    List&lt;AttrGroupEntity&gt; groupEntities = attrGroupDao.selectList(new QueryWrapper&lt;AttrGroupEntity&gt;().eq(&quot;catelog_id&quot;, catelogId));
    List&lt;Long&gt; collect = groupEntities.stream().map(item -&gt; {
        return item.getAttrGroupId();
    }).collect(Collectors.toList());
    // 查这些分组关联的属性
    List&lt;AttrAttrgroupRelationEntity&gt; groupId = attrAttrgroupRelationDao.selectList(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().in(&quot;attr_group_id&quot;, collect));
    List&lt;Long&gt; attrIds = groupId.stream().map(item -&gt; {
        return item.getAttrId();
    }).collect(Collectors.toList());
    // 从当前分类所有属性中移除这些属性
    // 首先必须是当前分类下的
    // 其次排除当前分类下其他属性分组关联的属性
    QueryWrapper&lt;AttrEntity&gt; queryWrapper = new QueryWrapper&lt;AttrEntity&gt;().eq(&quot;catelog_id&quot;, catelogId).eq(&quot;attr_type&quot;, ProductConstant.AttrEnum.ATTR_TYPE_BASE.getCode());
    if(attrIds != null &amp;&amp; attrIds.size() &gt; 0) {
        queryWrapper.notIn(&quot;attr_id&quot;, attrIds);
    }

    // 如果有key的话仍然按照id匹配，名字模糊查询
    String key = (String) params.get(&quot;key&quot;);
    if(!StringUtils.isEmpty(key)) {
        queryWrapper.and((wrapper) -&gt; {
            wrapper.eq(&quot;attr_id&quot;, key).or().like(&quot;attr_name&quot;, key);
        });
    }
    // 返回按照分页查询
    IPage&lt;AttrEntity&gt; page = this.page(new Query&lt;AttrEntity&gt;().getPage(params), queryWrapper);
    PageUtils pageUtils = new PageUtils(page);

    return pageUtils;
}
</code></pre>
<p><strong>然后是添加关联的功能</strong><br>
接口为：http://localhost:88/api/product/attrgroup/attr/relation<br>
通过POST请求发送attrId和attrGroupId<br>
<img src="https://dxone1.github.io//post-images/1636464956389.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day5：商品属性分组和关联同步]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day5/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day5/">
        </link>
        <updated>2021-11-08T03:13:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="spu与sku">SPU与SKU</h2>
<ol>
<li>SPU： Standard Product Unit（标准化产品单元）<br>
是商品信息聚合的最小单位， 是一组可复用、 易检索的标准化信息的集合， 该集合描述了一个产品的特性。</li>
<li>SKU： Stock Keeping Unit（库存量单位）<br>
即库存进出计量的基本单元， 可以是以件， 盒， 托盘等为单位。 SKU 是对于大型连锁超市DC（配送中心） 物流管理的一个必要的方法。 现在已经被引申为产品统一编号的简称， 每种产品均对应有唯一的 SKU 号。</li>
</ol>
<p>【例子】<br>
iphoneX 是 SPU、 MI 8 是 SPU<br>
iphoneX 64G 黑曜石 是 SKU<br>
MI8 8+64G+黑色 是 SKU</p>
<p><strong>开发相关</strong><br>
基本属性【 规格参数】 与销售属性<br>
每个分类下的商品共享规格参数， 与销售属性。 只是有些商品不一定要用这个分类下全部的属性；</p>
<ul>
<li>属性是以三级分类组织起来的</li>
<li>规格参数中有些是可以提供检索的</li>
<li>规格参数也是基本属性， 他们具有自己的分组</li>
<li>属性的分组也是以三级分类组织起来的</li>
<li>属性名确定的， 但是值是每一个商品不同来决定的</li>
</ul>
<p>即：规格参数 ==&gt; SPU   ||   销售属性（颜色、RAM等...） ==&gt; SKU</p>
<p>属性表的设计：<br>
<img src="https://dxone1.github.io//post-images/1636341899050.png" alt="" loading="lazy"><br>
属性分组表：<br>
<img src="https://dxone1.github.io//post-images/1636341955079.png" alt="" loading="lazy"><br>
属性和分组的关联表：<br>
<img src="https://dxone1.github.io//post-images/1636342006208.png" alt="" loading="lazy"><br>
商品属性值表：<br>
<img src="https://dxone1.github.io//post-images/1636342058067.png" alt="" loading="lazy"><br>
spu和sku都有不同的表设计，总体的表如下：<br>
<img src="https://dxone1.github.io//post-images/1636342149155.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636342329921.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636342581115.png" alt="" loading="lazy"></p>
<h2 id="商品属性分组">商品属性分组</h2>
<p>三级分类树在以后的项目中都有用处，所以先抽取出三级分类树展示模块<br>
至于右边的表格直接使用代码生成器快速生成的模板即可<br>
页面效果如下：<br>
<img src="https://dxone1.github.io//post-images/1636356452967.png" alt="" loading="lazy"><br>
抽取的公共三级分类树是子组件，我们希望当点击子组件时父组件可以感知，使用vue的事件机制可以达成。子组件给父组件发送一个事件，携带数据。element-ui定义的Tree有这样一个组件<br>
<img src="https://dxone1.github.io//post-images/1636356664260.png" alt="" loading="lazy"></p>
<ol>
<li>在子组件中绑定node-click事件</li>
</ol>
<pre><code class="language-js">&lt;el-tree
    ...
    @node-click=&quot;nodeclick&quot;
&gt;
&lt;/el-tree&gt;

nodeclick(data, node, component) {
    console.log(&quot;子组件category被点击,&quot;,data, node, component);
    // 向父组件发送事件
    this.$emit(&quot;tree-node-click&quot;, data, node, component );
}
</code></pre>
<ol start="2">
<li>父组件标记感知的事件并绑定方法</li>
</ol>
<pre><code class="language-js">&lt;category @tree-node-click=&quot;treenodeClick&quot;&gt;&lt;/category&gt;
</code></pre>
<ol start="3">
<li>后端逻辑<br>
发送给后端获取该category的表，后端写相关的controller。本项目使用脚手架工程提供了一个sql封装，后端的Service层的实现如下。作用，传入一个params表和一个catelogId，后者必须匹配，前者的key字段和&quot;attr_group_id&quot;严格匹配，与&quot;attr_group_name&quot;模糊匹配</li>
</ol>
<pre><code class="language-java"> @Override
public PageUtils queryPage(Map&lt;String, Object&gt; params, Long catelogId) {
    if (catelogId == 0) {
        IPage&lt;AttrGroupEntity&gt; page = this.page(new Query&lt;AttrGroupEntity&gt;().getPage(params),
                new QueryWrapper&lt;AttrGroupEntity&gt;());
        return new PageUtils(page);
    } else {
        String key = (String) params.get(&quot;key&quot;);
        // select * from attr_group where catelog_id = ? and (attr_group = key or attr_name like %key%)
        QueryWrapper&lt;AttrGroupEntity&gt; wrapper = new QueryWrapper&lt;AttrGroupEntity&gt;().eq(&quot;catelog_id&quot;, catelogId);
        if(!StringUtils.isEmpty(key)) {
            wrapper.and((obj) -&gt; {
                obj.eq(&quot;attr_group_id&quot;, key).or().like(&quot;attr_group_name&quot;, key);
            });
        }
        IPage&lt;AttrGroupEntity&gt; page = this.page(new Query&lt;AttrGroupEntity&gt;().getPage(params),
                wrapper);
        return new PageUtils(page);
    }
}
</code></pre>
<ol start="4">
<li>前端请求方法</li>
</ol>
<pre><code class="language-js">// 感知树节点被点击
treenodeClick(data, node, component) {
    console.log(&quot;attrgroup感知到category的节点被点击&quot;, data, node, component);
    console.log(&quot;点击的菜单id为&quot;, data.catId);
    // 只有第三级分类才查询
    if (node.level == 3) {
        this.catId = data.catId;
        this.getDataList();
    }
},
</code></pre>
<h2 id="属性分组新增修改功能">属性分组新增/修改功能</h2>
<p>只需为 Cascader 的options属性指定选项数组即可渲染出一个级联选择器。通过props.expandTrigger可以定义展开子级菜单的触发方式。<br>
给后端的children属性添加一个注解，使得其不为空时才通过json返回</p>
<pre><code class="language-java">/**
* 子分类
*/
@JsonInclude(JsonInclude.Include.NON_EMPTY)
@TableField(exist = false)
private List&lt;CategoryEntity&gt; children;
</code></pre>
<p>前端请求添加即可<br>
修改功能涉及到回显，需要在后端回显添加一个数组属性</p>
<pre><code class="language-java">@TableField(exist = false)
private Long[] catelogPath;
</code></pre>
<p>查找Path的方法：</p>
<pre><code class="language-java">@Override
public Long[] findCatelogPath(Long catelogId) {
    List&lt;Long&gt; paths = new ArrayList&lt;&gt;();
    findParentPath(catelogId, paths);
    return paths.toArray(new Long[paths.size()]);
}

private void findParentPath(Long catelogId, List&lt;Long&gt; paths) {
    CategoryEntity byId = this.getById(catelogId);
    if(byId.getParentCid() != 0) {
        findParentPath(byId.getParentCid(), paths);
    }
    // 后序遍历
    paths.add(catelogId);
}
</code></pre>
<p>效果如图：<br>
<img src="https://dxone1.github.io//post-images/1636364145316.png" alt="" loading="lazy"><br>
前端回显之后注意需要在对话框关闭后回调重置路径</p>
<pre><code class="language-js">// 关闭对话框，回调清除diaglogPath
dialogClosed(){
    this.dataForm.catelogPath = [];
}
</code></pre>
<p>对话框的写法：</p>
<pre><code class="language-js">&lt;el-dialog
    :title=&quot;!dataForm.attrGroupId ? '新增' : '修改'&quot;
    :close-on-click-modal=&quot;false&quot;
    :visible.sync=&quot;visible&quot;
    @closed=&quot;dialogClosed&quot;
&gt;
    &lt;el-form
      :model=&quot;dataForm&quot;
      :rules=&quot;dataRule&quot;
      ref=&quot;dataForm&quot;
      @keyup.enter.native=&quot;dataFormSubmit()&quot;
      label-width=&quot;80px&quot;
    &gt;
      &lt;el-form-item label=&quot;组名&quot; prop=&quot;attrGroupName&quot;&gt;
        &lt;el-input
          v-model=&quot;dataForm.attrGroupName&quot;
          placeholder=&quot;组名&quot;
        &gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;排序&quot; prop=&quot;sort&quot;&gt;
        &lt;el-input v-model=&quot;dataForm.sort&quot; placeholder=&quot;排序&quot;&gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;描述&quot; prop=&quot;descript&quot;&gt;
        &lt;el-input v-model=&quot;dataForm.descript&quot; placeholder=&quot;描述&quot;&gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;组图标&quot; prop=&quot;icon&quot;&gt;
        &lt;el-input v-model=&quot;dataForm.icon&quot; placeholder=&quot;组图标&quot;&gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;所属分类id&quot; prop=&quot;catelogId&quot;&gt;
        &lt;!-- &lt;el-input v-model=&quot;dataForm.catelogId&quot; placeholder=&quot;所属分类id&quot;&gt;&lt;/el-input&gt; --&gt;
        &lt;el-cascader
          v-model=&quot;dataForm.catelogPath&quot;
          :options=&quot;categorys&quot;
          :props=&quot;props&quot;
          filterable
        &gt;&lt;/el-cascader&gt;
      &lt;/el-form-item&gt;
    &lt;/el-form&gt;
    &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;
      &lt;el-button @click=&quot;visible = false&quot;&gt;取消&lt;/el-button&gt;
      &lt;el-button type=&quot;primary&quot; @click=&quot;dataFormSubmit()&quot;&gt;确定&lt;/el-button&gt;
    &lt;/span&gt;
&lt;/el-dialog&gt;
</code></pre>
<h2 id="品牌管理功能细化">品牌管理功能细化</h2>
<p>希望能够正确显示分页并提供品牌管理的查询功能<br>
<img src="https://dxone1.github.io//post-images/1636371869531.png" alt="" loading="lazy"><br>
根据Mybatis-plus的文档，只需要在IOC容器中添加一个PaginationInterceptor即可</p>
<pre><code class="language-java">@Configuration
@EnableTransactionManagement
@MapperScan(&quot;com.dong.mall.product.dao&quot;)
public class MyBatisConfig {
    // 引入分页插件
    // 旧版
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();
        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false
         paginationInterceptor.setOverflow(true);
        // 设置最大单页限制数量，默认 500 条，-1 不受限制
         paginationInterceptor.setLimit(100);
        // 开启 count 的 join 优化,只针对部分 left join
        paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));
        return paginationInterceptor;
    }
}
</code></pre>
<p><strong>自行编写了商品系统的：分类维护、品牌管理和属性分组功能，之后的前端代码不再重复写</strong><br>
考虑品牌和商品分类的对应：是一种多对多的关系，所以使用一张中间表处理业务。给品牌管理添加关联分类功能，是一种多对多的关系。<br>
<img src="https://dxone1.github.io//post-images/1636373493726.png" alt="" loading="lazy"><br>
需要编写如下接口：</p>
<ul>
<li>查询所有当前品牌关联的分类</li>
<li>添加新的关联分类</li>
<li>删除关联分类<br>
在CategoryBrandRelationController这里写业务</li>
</ul>
<pre><code class="language-java">/**
    * 获取当前品牌关联的所有的分类的列表
    */
@RequestMapping(&quot;/catelog/list&quot;)
public R cateloglist(@RequestParam(&quot;brandId&quot;) Long brandId) {
    List&lt;CategoryBrandRelationEntity&gt; data = categoryBrandRelationService.list(
            new QueryWrapper&lt;CategoryBrandRelationEntity&gt;().eq(&quot;brand_id&quot;, brandId)
    );
    return R.ok().put(&quot;data&quot;, data);
}

// 重写了能保存品牌和分类名的service方法
@Override
public void saveDetail(CategoryBrandRelationEntity categoryBrandRelation) {
    Long brandId = categoryBrandRelation.getBrandId();
    Long catelogId = categoryBrandRelation.getCatelogId();
    // 先查询品牌名字和分类名
    BrandEntity brandEntity = brandDao.selectById(brandId);
    CategoryEntity categoryEntity = categoryDao.selectById(catelogId);
    // 设置字段再返回
    categoryBrandRelation.setBrandName(brandEntity.getName());
    categoryBrandRelation.setCatelogName(categoryEntity.getName());
    this.save(categoryBrandRelation);
}
</code></pre>
<p>效果如图：<br>
<img src="https://dxone1.github.io//post-images/1636374659495.png" alt="" loading="lazy"><br>
然而，之前的品牌更新代码代码只是在品牌表中进行增删改查，如果实际业务表格修改就会有很大的问题，因为关联表是有冗余条目存在的，必须同步，于是采用如下操作：重写品牌的update的逻辑。而新增则在关联发生之前不需要修改。</p>
<pre><code class="language-java">// brandServiceImpl.java
@Override
public void updateDetail(BrandEntity brand) {
    // 保证冗余字段的数据一致
    this.updateById(brand);
    // 品牌名发生修改，需要修改关联表中的数据
    if(!StringUtils.isEmpty(brand.getName())) {
        // 品牌和类别关联表
        categoryBrandRelationService.updateBrand(brand.getBrandId(), brand.getName());
        //TODO 更新其他关联
    }
}
// categoryBrandRelationService.updateBrand()
@Override
public void updateBrand(Long brandId, String name) {
    CategoryBrandRelationEntity relationEntity = new CategoryBrandRelationEntity();
    relationEntity.setBrandId(brandId);
    relationEntity.setBrandName(name);
    this.update(relationEntity, new UpdateWrapper&lt;CategoryBrandRelationEntity&gt;().eq(&quot;brand_id&quot;, brandId));
}
</code></pre>
<p>测试：将品牌改为华为2，关联分类中的也变化<br>
<img src="https://dxone1.github.io//post-images/1636375664862.png" alt="" loading="lazy"><br>
同理，分类的修改也要修改关联表项目<br>
最后，注意到同时修改两张表，要么同时成功，要么同时失败，需要使用事务保证一致性。在MybatisConfig配置类已经使用@EnableTransactionManagement开启了事务管理，只需要在方法上使用@Transactiona添加事务即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day4：品牌管理]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day4pin-pai-guan-li/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day4pin-pai-guan-li/">
        </link>
        <updated>2021-11-06T11:45:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用逆向工程的前后端代码">使用逆向工程的前后端代码</h2>
<p>renren-fast的代码生成器也可以生成前端代码，首先看sql表<br>
<img src="https://dxone1.github.io//post-images/1636199377250.png" alt="" loading="lazy"><br>
添加一个品牌管理的页面，直接使用逆向生成的前端代码即可。<br>
<img src="https://dxone1.github.io//post-images/1636200595120.png" alt="" loading="lazy"></p>
<h2 id="优化前端体验">优化前端体验</h2>
<p>首先将显示状态一栏变为开关按钮，更加的人性化</p>
<ul>
<li>显示状态一栏应该改为开关</li>
<li>新增的对话框中显示状态一栏也应为开关</li>
<li>品牌地址应该为文件上传（下一节）</li>
</ul>
<pre><code class="language-js">&lt;el-table-column
    prop=&quot;showStatus&quot;
    header-align=&quot;center&quot;
    align=&quot;center&quot;
    label=&quot;显示状态&quot;
&gt;
    &lt;!-- 插入一个template --&gt;
    &lt;template slot-scope=&quot;scope&quot;&gt;
        &lt;el-switch
            v-model=&quot;scope.row.showStatus&quot;
            active-color=&quot;#13ce66&quot;
            inactive-color=&quot;#ff4949&quot;
            // 修改为1显示，0关闭
            :active-value=&quot;1&quot;
            :inactive-value=&quot;0&quot;
            @change=&quot;updateBrandStatus(scope.row)&quot;
        &gt;
        &lt;/el-switch&gt;
    &lt;/template&gt;
&lt;/el-table-column&gt;

// 回调函数
// 更新显示状态
updateBrandStatus(data) {
    console.log(&quot;状态&quot;, data);
    let { brandId, showStatus } = data;
    this.$http({
        url: this.$http.adornUrl(&quot;/product/brand/update&quot;),
        method: &quot;post&quot;,
        data: this.$http.adornData({ brandId, showStatus }, false),
    }).then(({ data }) =&gt; {
        this.$message({
            type: &quot;success&quot;,
            message: &quot;状态更新成功&quot;,
        });
    });
},
</code></pre>
<p>效果：<br>
<img src="https://dxone1.github.io//post-images/1636202534702.png" alt="" loading="lazy"></p>
<h2 id="开通云存储和使用文件上传">开通云存储和使用：文件上传</h2>
<p><img src="https://dxone1.github.io//post-images/1636257477896.png" alt="" loading="lazy"><br>
在分布式系统中，如果文件保存在服务器本地则因为负载均衡而无法确保访问，所以需要使用统一的文件存储服务器。自建服务器的效率不高，这里使用阿里云的云存储服务功能。<br>
<img src="https://dxone1.github.io//post-images/1636257725534.png" alt="" loading="lazy"><br>
为了避免直接暴露阿里云服务器的账号密码，同时减少上传文件过服务器带来的性能压力，使用如下的架构<br>
<img src="https://dxone1.github.io//post-images/1636258870146.png" alt="" loading="lazy"></p>
<ol>
<li>先导入阿里云oss依赖</li>
<li>在阿里云上开通一个子账户，配置用户和密码(AccessKeyId AccessKeySecret)<br>
<img src="https://dxone1.github.io//post-images/1636260427009.png" alt="" loading="lazy"></li>
</ol>
<pre><code class="language-java">@Test
public void testUpload() throws FileNotFoundException {
    // yourEndpoint填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。
    String endpoint = &quot;oss-cn-shanghai.aliyuncs.com&quot;;
    // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。
    String accessKeyId = &quot;（隐藏）&quot;;
    String accessKeySecret = &quot;[KeySecret]（隐藏）&quot;;

    // 创建OSSClient实例。
    OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

    // 填写本地文件的完整路径。如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件流。
    InputStream inputStream = new FileInputStream(&quot;C:\\Users\\user\\Desktop\\惠2.jpg&quot;);
    // 依次填写Bucket名称（例如examplebucket）和Object完整路径（例如exampledir/exampleobject.txt）。Object完整路径中不能包含Bucket名称。
    ossClient.putObject(&quot;dxone-mall&quot;, &quot;惠2.jpg&quot;, inputStream);

    // 关闭OSSClient。
    ossClient.shutdown();
    System.out.println(&quot;上传成功...&quot;);
}
</code></pre>
<p>效果<br>
<img src="https://dxone1.github.io//post-images/1636260852130.png" alt="" loading="lazy"><br>
也可以使用SpringCloudAlibaba的功能</p>
<pre><code class="language-xml">&lt;!--Alibaba OSS--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alicloud-oss&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>只需要在aplication.yaml中配置即可</p>
<pre><code class="language-yaml"># 文件oos服务的配置
alicloud:
    access-key: 隐藏
    secret-key: 隐藏
    oss:
        endpoint: oss-cn-shanghai.aliyuncs.com
</code></pre>
<p>也成功了<br>
<img src="https://dxone1.github.io//post-images/1636261615240.png" alt="" loading="lazy"></p>
<p><strong>服务端签名后直传服务</strong><br>
mall-third-party<br>
将oss的部分全部迁移到这个服务里，测试成功<br>
<img src="https://dxone1.github.io//post-images/1636265327134.png" alt="" loading="lazy"><br>
参考官方文档：https://help.aliyun.com/document_detail/31926.html 是服务端签名直传的最佳实践。</p>
<ol>
<li>先编写一个OssController，用于获取阿里云的policy</li>
</ol>
<pre><code class="language-java">@RestController
public class OssController {

    @Autowired
    OSS ossClient;

    @Value(&quot;${spring.cloud.alicloud.oss.endpoint}&quot;)
    private String endpoint;

    @Value(&quot;${spring.cloud.alicloud.oss.bucket}&quot;)
    private String bucket;

    @Value(&quot;${spring.cloud.alicloud.access-key}&quot;)
    private String accessId;

    @RequestMapping(&quot;/oss/policy&quot;)
    public Map&lt;String, String&gt; policy() {

        String host = &quot;https://&quot; + bucket + &quot;.&quot; + endpoint; // host的格式为 bucketname.endpoint
        // callbackUrl为上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。
        //String callbackUrl = &quot;http://88.88.88.88:8888&quot;;
        String format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date());
        String dir = format + &quot;/&quot;; // 用户上传文件时指定的前缀。
        Map&lt;String, String&gt; respMap = null;
        try {
            long expireTime = 30;
            long expireEndTime = System.currentTimeMillis() + expireTime * 1000;
            Date expiration = new Date(expireEndTime);
            // PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。
            PolicyConditions policyConds = new PolicyConditions();
            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);
            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);

            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);
            byte[] binaryData = postPolicy.getBytes(StandardCharsets.UTF_8);
            String encodedPolicy = BinaryUtil.toBase64String(binaryData);
            String postSignature = ossClient.calculatePostSignature(postPolicy);

            respMap = new LinkedHashMap&lt;String, String&gt;();
            respMap.put(&quot;accessid&quot;, accessId);
            respMap.put(&quot;policy&quot;, encodedPolicy);
            respMap.put(&quot;signature&quot;, postSignature);
            respMap.put(&quot;dir&quot;, dir);
            respMap.put(&quot;host&quot;, host);
            respMap.put(&quot;expire&quot;, String.valueOf(expireEndTime / 1000));
            // respMap.put(&quot;expire&quot;, formatISO8601Date(expiration));

        } catch (Exception e) {
            // Assert.fail(e.getMessage());
            System.out.println(e.getMessage());
        } finally {
            ossClient.shutdown();
        }
        return respMap;
    }
}
</code></pre>
<ol start="2">
<li>在gateway中配置路由</li>
</ol>
<pre><code class="language-yaml">- id: third_party_route
    uri: lb://mall-third-party
    predicates:
        - Path=/api/thirdparty/**
    # 路径重写
    filters:
        - RewritePath=/api/thirdparty/(?&lt;segment&gt;.*),/$\{segment}
    # localhost:88/api/thirdparty/** -&gt; localhost:30000/**
</code></pre>
<ol start="3">
<li>前端联调<br>
先记下bucket域名：dxone-mall.oss-cn-shanghai.aliyuncs.com<br>
将其写入单文件/多文件上传的组件中（太长了省略，也是el-ui的组件）<br>
将组件导入品牌vue中</li>
</ol>
<pre><code class="language-js">import SingleUpload from &quot;@/components/upload/singleUpload&quot;

// 使用
&lt;single-upload v-model=&quot;dataForm.logo&quot;&gt;&lt;/single-upload&gt;

// vue中声明一个component
components: { SingleUpload },
</code></pre>
<p>调整：因为之前写的Controller返回的是一个map，需要返回成R对象。<br>
<strong>在提交给OSS时存在跨域问题，在阿里云中开放跨域即可</strong><br>
效果<br>
<img src="https://dxone1.github.io//post-images/1636268792634.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636268809062.png" alt="" loading="lazy"><br>
最终能拿到该图片：图片地址也能拿到<br>
<img src="https://dxone1.github.io//post-images/1636269250814.png" alt="" loading="lazy"><br>
4. 写品牌新增功能<br>
注意需要将展示的地址换为图片显示，一样使用element-ui<br>
<img src="https://dxone1.github.io//post-images/1636270562321.png" alt="" loading="lazy"><br>
5. 表单校验功能：例如首字母只能有一个字母等<br>
Form 组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。校验规则参见 async-validator<br>
在校验规则中可以用validator指定一个方法进行校验<br>
<strong>前端校验</strong></p>
<pre><code class="language-js">firstLetter: [
    {
        validator: (rule, value, callback) =&gt; {
            if (value == &quot;&quot;) {
                callback(new Error(&quot;首字母必须填写&quot;));
            } else if (!/^[a-zA-Z]$/.test(value)) {
                callback(new Error(&quot;首字母必须在a-z或A-Z之间&quot;));
            } else {
                callback();
            }
        },
        trigger: &quot;blur&quot;,
    },
],
sort: [
    {
        validator: (rule, value, callback) =&gt; {
            if (value == &quot;&quot;) {
                callback(new Error(&quot;排序字段必须填写&quot;));
            } else if (!Number.isInteger(value) ||  value &lt; 0) {
                callback(new Error(&quot;排序必须是一个非负整数&quot;));
            } else {
                callback();
            }
        },
        trigger: &quot;blur&quot;,
    },
],
</code></pre>
<p>注意：后端做保存更新等操作时也要进行校验，保证数据的可靠性！<br>
6. 后端校验：使用JSR303</p>
<ul>
<li>给需要校验的Bean添加校验注解（见javax.validation.constraints）</li>
</ul>
<pre><code class="language-java">/**
* 品牌名
*/
@NotBlank(message = &quot;品牌名必须提交&quot;)
private String name;
</code></pre>
<ul>
<li>在Controller标注对于校验传入值标注@Valid</li>
</ul>
<pre><code class="language-java">/**
* 保存
*/
@RequestMapping(&quot;/save&quot;)
    public R save(@Valid @RequestBody BrandEntity brand){
    brandService.save(brand);

    return R.ok();
}
</code></pre>
<p>简单测试下效果：400校验不通过<br>
<img src="https://dxone1.github.io//post-images/1636271891671.png" alt="" loading="lazy"><br>
业务上需要封装错误提示<br>
紧跟校验bean后加上BindingResult，就可以自己封装</p>
<pre><code class="language-java">/**
* 保存
*/
@RequestMapping(&quot;/save&quot;)
public R save(@Valid @RequestBody BrandEntity brand, BindingResult result) {
    if (result.hasErrors()) {
        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
        result.getFieldErrors().forEach((item) -&gt; {
            // 错误提示
            String message = item.getDefaultMessage();
            // 错误字段名
            String field = item.getField();
            map.put(field, message);
        });
        return R.error(400,&quot;提交数据不合法&quot;).put(&quot;data&quot;, map);
    } else {
        brandService.save(brand);
    }
    return R.ok();
}
</code></pre>
<p>效果<br>
<img src="https://dxone1.github.io//post-images/1636272559187.png" alt="" loading="lazy"><br>
@URL可以校验URL地址<br>
@Pattern注解自定义校验规则，传正则表达式<br>
完成一个基础的校验如下：<br>
<img src="https://dxone1.github.io//post-images/1636272938144.png" alt="" loading="lazy"></p>
<h3 id="高级主题统一异常处理">高级主题：统一异常处理</h3>
<p>提取出一个ControllerAdvice类，处理所有的异常，这样原Controller只需要把异常抛出即可</p>
<pre><code class="language-java">/**
 * 集中处理所有的异常
 */
@Slf4j
@RestControllerAdvice(basePackages = &quot;com.dong.mall.product.controller&quot;)
public class MallExceptionControllerAdvice {

    /**
     * 专职处理数据校验的异常
     * @param e 异常实例
     * @return 返回json的错误信息
     */
    @ExceptionHandler(value = MethodArgumentNotValidException.class)
    public R handleValidException(MethodArgumentNotValidException e) {
        log.error(&quot;数据校验问题{},异常类型{}&quot;,e.getMessage(), e.getClass());
        BindingResult result = e.getBindingResult();
        HashMap&lt;String, String&gt; errorMap = new HashMap&lt;&gt;();
        result.getFieldErrors().forEach((item) -&gt; {
            // 错误提示
            String message = item.getDefaultMessage();
            // 错误字段名
            String field = item.getField();
            errorMap.put(field, message);
        });
        return R.error(400,&quot;提交数据不合法&quot;).put(&quot;data&quot;, errorMap);
    }

    /**
     * 兜底异常处理
     * @param throwable
     * @return
     */
    @ExceptionHandler(value = Throwable.class)
    public R handleException(Throwable throwable) {
        return R.error();
    }
}
</code></pre>
<p>规范：采用这种状态码规格</p>
<pre><code class="language-txt">* 错误码和错误信息定义类
* 1. 错误码定义规则为 5 为数字
* 2. 前两位表示业务场景， 最后三位表示错误码。 例如： 100001。 10:通用 001:系统未知
异常
* 3. 维护错误码后需要维护错误描述， 将他们定义为枚举形式
* 错误码列表：
* 10: 通用
* 001： 参数格式校验
* 11: 商品
* 12: 订单
* 13: 购物车
* 14: 物流
</code></pre>
<p>添加一个enum定义状态码</p>
<pre><code class="language-java">public enum BizCodeEnum {
    UNKNOWN_EXCEPTION(10000, &quot;系统未知异常&quot;),
    VALID_EXCEPTION(10001, &quot;参数格式校验失败&quot;);

    private int code;
    private String msg;

    BizCodeEnum(int code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public int getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }
}
</code></pre>
<p>于是输出变为</p>
<pre><code class="language-java">return R.error(BizCodeEnum.VALID_EXCEPTION.getCode(),BizCodeEnum.VALID_EXCEPTION.getMsg()).put(&quot;data&quot;, errorMap);
/*********************************/
return R.error(BizCodeEnum.UNKNOWN_EXCEPTION.getCode(), BizCodeEnum.UNKNOWN_EXCEPTION.getMsg());
</code></pre>
<h3 id="高级主题分组校验">高级主题：分组校验</h3>
<p>新增规则和修改规则很有可能不同：例如id等部分<br>
使用方法：</p>
<ol>
<li>在校验注解上标注groups属性<br>
在common中再添加用于分组校验的接口<br>
<img src="https://dxone1.github.io//post-images/1636274707620.png" alt="" loading="lazy"><br>
校验注解标注上这些接口即可</li>
</ol>
<pre><code class="language-java">/**
* 品牌id
*/
// 修改时不允许为空
@NotNull(message = &quot;修改必须指定品牌id&quot;,groups = {UpdateGroup.class})
// 新增时必须为空
@Null(message = &quot;新增不能指定品牌id&quot;, groups = {AddGroup.class})
@TableId
private Long brandId;
</code></pre>
<ol start="2">
<li>在Controller上标注@Validated()指定该controller进行哪些group的校验</li>
</ol>
<pre><code class="language-java">@RequestMapping(&quot;/save&quot;)
public R save(@Validated(AddGroup.class) @RequestBody BrandEntity brand/*, BindingResult result*/) {
</code></pre>
<p><strong>在这种情况下，没有标注分组的注解是默认不起作用的。必须指定</strong><br>
每一个都按照上述分组进行处理即可完成多场景的复杂校验。</p>
<h3 id="高级主题自定义校验">高级主题：自定义校验</h3>
<ol>
<li>编写一个自定义的校验注解<br>
考虑指定showStatus必须为指定的几种可能性</li>
</ol>
<pre><code class="language-java">/**
* 显示状态[0-不显示；1-显示]
*/
@ListValue(vals={0,1})
private Integer showStatus;
</code></pre>
<p>注解编写：</p>
<pre><code class="language-java">@Documented
// 指定用哪个校验器
@Constraint(validatedBy = {ListValueConstraintValidator.class})
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface ListValue {
    // 抄已有的校验注解
    String message() default &quot;{com.dong.common.valid.ListValue.message}&quot;;

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    int[] vals() default {};
}
</code></pre>
<p>编写配置文件</p>
<pre><code class="language-properties">com.dong.common.valid.ListValue.message=必须提交指定的值
</code></pre>
<ol start="2">
<li>编写一个自定义校验器</li>
</ol>
<pre><code class="language-java">/**
 * 自定义一个校验器
 */
public class ListValueConstraintValidator implements ConstraintValidator&lt;ListValue, Integer&gt; {
    private Set&lt;Integer&gt; set = new HashSet&lt;&gt;();

    /**
     * 初始化方法
     * @param constraintAnnotation 能从中获得校验注解标注的信息
     */
    @Override
    public void initialize(ListValue constraintAnnotation) {
        int[] vals = constraintAnnotation.vals();
        for (int val : vals) {
            set.add(val);
        }
    }

    /**
     * 判断是否校验成功
     * @param value 需要校验的值
     * @param context 校验的上下文环境
     * @return
     */
    @Override
    public boolean isValid(Integer value, ConstraintValidatorContext context) {
        return set.contains(value);
    }
}
</code></pre>
<ol start="3">
<li>关联注解和校验器<br>
测试：<br>
<img src="https://dxone1.github.io//post-images/1636277405746.png" alt="" loading="lazy"><br>
前端效果<br>
<img src="https://dxone1.github.io//post-images/1636278646366.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636278585870.jpg" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
</feed>