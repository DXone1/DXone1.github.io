<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dxone1.github.io/</id>
    <title>Gridea</title>
    <updated>2021-11-12T05:28:30.856Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dxone1.github.io/"/>
    <link rel="self" href="https://dxone1.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://dxone1.github.io/images/avatar.png</logo>
    <icon>https://dxone1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[电商项目 day 8：商品和仓库管理]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day-8shang-pin-he-cang-ku-guan-li/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day-8shang-pin-he-cang-ku-guan-li/">
        </link>
        <updated>2021-11-11T06:48:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="spu组合搜索功能">SPU组合搜索功能</h2>
<p><img src="https://dxone1.github.io//post-images/1636614407614.png" alt="" loading="lazy"><br>
看到其中不仅有商品ID商品名等信息还有分类等组合查询</p>
<pre><code class="language-java">@Override
public PageUtils queryPageByCondition(Map&lt;String, Object&gt; params) {
    QueryWrapper&lt;SpuInfoEntity&gt; wrapper = new QueryWrapper&lt;&gt;();
    /**
        * 根据以下信息组合查询
        * status:
        * key:
        * brandId: 0
        * catelogId: 0
        */
    String key = (String) params.get(&quot;key&quot;);
    if(!StringUtils.isEmpty(key)) {
        wrapper.and(w -&gt; {
            w.eq(&quot;id&quot;, key).or().like(&quot;spu_name&quot;, key);
        });
    }
    String status = (String) params.get(&quot;status&quot;);
    if(!StringUtils.isEmpty(status)) {
        wrapper.eq(&quot;publish_status&quot;, status);

    }
    String brandId = (String) params.get(&quot;brandId&quot;);
    if(!StringUtils.isEmpty(brandId)) {
        wrapper.eq(&quot;brand_id&quot;, brandId);
    }
    String catelogId = (String) params.get(&quot;catelogId&quot;);
    if(!StringUtils.isEmpty(catelogId)) {
        wrapper.eq(&quot;catalog_id&quot;, catelogId);
    }
    IPage&lt;SpuInfoEntity&gt; page = this.page(new Query&lt;SpuInfoEntity&gt;().getPage(params),
            wrapper);
    return new PageUtils(page);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1636615251501.png" alt="" loading="lazy"></figure>
<h2 id="sku检索功能">SKU检索功能</h2>
<p>一样的内容，组合检索<br>
<img src="https://dxone1.github.io//post-images/1636617236425.png" alt="" loading="lazy"></p>
<h2 id="仓库维护">仓库维护</h2>
<figure data-type="image" tabindex="2"><img src="https://dxone1.github.io//post-images/1636618921114.png" alt="" loading="lazy"></figure>
<h2 id="商品库存">商品库存</h2>
<p>请求 URL: http://localhost:88/api/ware/waresku/list?t=1636618949796&amp;page=1&amp;limit=10&amp;skuId=&amp;wareId=</p>
<pre><code class="language-txt">t: 1636618949796
page: 1
limit: 10
skuId: 
wareId: 
</code></pre>
<h2 id="库存管理">库存管理</h2>
<p>注意，生产环境中不能直接而在商品库存添加库存，而是通过采购单来进行维护添加。流程是：<br>
采购需求(合并整单) -&gt; 采购单 -&gt; 库存添加<br>
<img src="https://dxone1.github.io//post-images/1636619627154.png" alt="" loading="lazy"></p>
<ol>
<li>采购需求整单的逻辑<br>
<img src="https://dxone1.github.io//post-images/1636620152697.png" alt="" loading="lazy"><br>
在采购单页面可以创建新增的采购单，在采购需求合并整单的时候需要将其合并到该单中。需要能够查询采购单。<br>
<img src="https://dxone1.github.io//post-images/1636620313865.png" alt="" loading="lazy"><br>
接口：http://localhost:88/api/ware/purchase/unreceive/list?t=1636620326054<br>
定义如下：<br>
<img src="https://dxone1.github.io//post-images/1636620731059.png" alt="" loading="lazy"><br>
所以查询所有新建/已分配的采购单（都还没有出发采购）<br>
合并采购需求发送一个POST请求：<br>
请求 URL: http://localhost:88/api/ware/purchase/merge<br>
<img src="https://dxone1.github.io//post-images/1636620991832.png" alt="" loading="lazy"><br>
也有可能不提交采购单而快速创建新单，则请求体中没有purchaseId，必须自动创建。<br>
编写功能</li>
</ol>
<pre><code class="language-java">@Transactional
@Override
public void mergePurchase(MerageVo merageVo) {
    Long purchaseId = merageVo.getPurchaseId();
    // 没有采购单ID要新建一个采购单
    if(purchaseId == null) {
        PurchaseEntity purchaseEntity = new PurchaseEntity();
        purchaseEntity.setStatus(WareConstant.PurchaseStatusEnum.CREATED.getCode());
        purchaseEntity.setCreateTime(new Date());
        purchaseEntity.setUpdateTime(new Date());
        this.save(purchaseEntity);
        // 新建的采购单的ID
        purchaseId = purchaseEntity.getId();
    }
    // 把采购单信息保存到采购需求中
    List&lt;Long&gt; items = merageVo.getItems();
    Long finalPurchaseId = purchaseId;
    List&lt;PurchaseDetailEntity&gt; collect = items.stream().map(i -&gt; {
        PurchaseDetailEntity detailEntity = new PurchaseDetailEntity();
        detailEntity.setId(i);
        detailEntity.setPurchaseId(finalPurchaseId);
        detailEntity.setStatus(WareConstant.PurchaseDetailEnum.ASSIGNED.getCode());
        return detailEntity;
    }).collect(Collectors.toList());
    purchaseDetailService.updateBatchById(collect);
}
</code></pre>
<ol start="2">
<li>领取采购单<br>
在采购单被分配后需要人员领取，领取之后状态需要变化<br>
当采购完成后也需要结束采购<br>
这两个功能的发出使用postMan进行模拟，本项目不涉及其页面和业务的开发，领取采购单的APP模拟如下：<br>
<img src="https://dxone1.github.io//post-images/1636623430355.png" alt="" loading="lazy"></li>
</ol>
<pre><code class="language-java">@Override
public void received(List&lt;Long&gt; ids) {
    //1. 确认当前采购单是新建/已分配
    List&lt;PurchaseEntity&gt; collect = ids.stream().map(id -&gt; {
        PurchaseEntity purchaseEntity = this.getById(id);
        return purchaseEntity;
    }).filter(item -&gt; {
        // 必须是新建/已分配的采购单
        return item.getStatus() == WareConstant.PurchaseStatusEnum.CREATED.getCode() ||
                item.getStatus() == WareConstant.PurchaseStatusEnum.ASSIGNED.getCode();
    }).map(item -&gt; {
        //2. 改变采购单的状态
        item.setStatus(WareConstant.PurchaseStatusEnum.RECEIVED.getCode());
        item.setUpdateTime(new Date());
        return item;
    }).collect(Collectors.toList());

    // 实际更新采购单状态
    this.updateBatchById(collect);

    //3. 改变采购单采购项的状态
    collect.forEach(item -&gt; {
        Long purchaseId = item.getId();
        List&lt;PurchaseDetailEntity&gt; purchaseDetailEntities = purchaseDetailService.listDetailByPurchaseId(purchaseId);
        List&lt;PurchaseDetailEntity&gt; detailEntities = purchaseDetailEntities.stream().map(entity -&gt; {
            PurchaseDetailEntity purchaseDetailEntity = new PurchaseDetailEntity();
            purchaseDetailEntity.setId(entity.getId());
            purchaseDetailEntity.setStatus(WareConstant.PurchaseDetailEnum.BUYING.getCode());
            return purchaseDetailEntity;
        }).collect(Collectors.toList());
        purchaseDetailService.updateBatchById(detailEntities);
    });
}
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1636624822561.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636624825855.png" alt="" loading="lazy"></p>
<h2 id="完成采购">完成采购</h2>
<p>完成采购后会发出一个请求，必须进行商品库存的服务调用。<br>
<img src="https://dxone1.github.io//post-images/1636633148544.png" alt="" loading="lazy"></p>
<pre><code class="language-java">@Override
public void addStock(Long skuId, Long wareId, Integer skuNum) {
    // 1. 如果还没有库存记录则新增
    List&lt;WareSkuEntity&gt; entities = wareSkuDao.selectList(new QueryWrapper&lt;WareSkuEntity&gt;().eq(&quot;sku_id&quot;, skuId).eq(&quot;ware_id&quot;, wareId));
    if(entities == null || entities.size() == 0) {
        WareSkuEntity skuEntity = new WareSkuEntity();
        skuEntity.setSkuId(skuId);
        skuEntity.setStock(skuNum);
        skuEntity.setWareId(wareId);
        skuEntity.setStockLocked(0);
        //远程调用查询skuName冗余备份
        // TODO 还有什么办法不回滚处理异常
        try {
            R info = productFeignService.info(skuId);
            Map&lt;String, Object&gt; data = (Map&lt;String, Object&gt;) info.get(&quot;skuInfo&quot;);
            if(info.getCode() == 0) {
                skuEntity.setSkuName((String) data.get(&quot;skuName&quot;));
            }
        } catch (Exception e) {

        }
        wareSkuDao.insert(skuEntity);
    } else {
        // 否则增加库存
        wareSkuDao.addStock(skuId, wareId, skuNum);
    }
}
</code></pre>
<p>测试实例：<br>
<img src="https://dxone1.github.io//post-images/1636638183522.png" alt="" loading="lazy"></p>
<h2 id="spu管理">Spu管理</h2>
<p>也是分为展示、修改两个功能模块</p>
<pre><code class="language-java">/**
    * 展示SPU属性
    * @param spuId
    * @return
    */
@Override
public List&lt;ProductAttrValueEntity&gt; baseAttrListForSpu(Long spuId) {
    List&lt;ProductAttrValueEntity&gt; entities = this.baseMapper.selectList(new QueryWrapper&lt;ProductAttrValueEntity&gt;().eq(&quot;spu_id&quot;, spuId));
    return entities;
}

/**
    * 修改SPU属性
    * @param spuId
    * @param entities
    */
@Transactional
@Override
public void updateSpuAttr(Long spuId, List&lt;ProductAttrValueEntity&gt; entities) {
    //1. 删除原有属性
    this.baseMapper.delete(new QueryWrapper&lt;ProductAttrValueEntity&gt;().eq(&quot;spu_id&quot;, spuId));
    //2. 插入新属性
    List&lt;ProductAttrValueEntity&gt; collect = entities.stream().map(item -&gt; {
        item.setSpuId(spuId);
        return item;
    }).collect(Collectors.toList());
    this.saveBatch(collect);
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://dxone1.github.io//post-images/1636694892686.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day7：发布商品功能]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day7/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day7/">
        </link>
        <updated>2021-11-10T02:19:53.000Z</updated>
        <content type="html"><![CDATA[<p>继续完善后台管理系统的各种功能，首先编写商品维护系统中的发布商品功能</p>
<h2 id="发布商品">发布商品</h2>
<p>前端页面如下<br>
<img src="https://dxone1.github.io//post-images/1636510989235.png" alt="" loading="lazy"><br>
首先会发出请求会员等级，请求方式为Get，地址为http://localhost:88/api/member/memberlevel/list?t=1636511786443&amp;page=1&amp;limit=500，返回分页数据<br>
在后端写逻辑，其实不用在这里写，写在用户系统中，调整即可。<br>
会员等级页面：<br>
<img src="https://dxone1.github.io//post-images/1636513825943.png" alt="" loading="lazy"></p>
<ol>
<li>获取分类关联的品牌<br>
在发布商品页面如果选择分类会发送一个请求关联品牌，编写相关的后端逻辑<br>
GET：http://localhost:88/api/product/categorybrandrelation/brands/list?t=1636514532755&amp;catId=225</li>
</ol>
<pre><code class="language-java">@Override
public List&lt;BrandEntity&gt; getBrandsByCatId(Long catId) {
    List&lt;CategoryBrandRelationEntity&gt; relationEntities = relationDao.selectList(new QueryWrapper&lt;CategoryBrandRelationEntity&gt;().eq(&quot;catelog_id&quot;, catId));
    List&lt;BrandEntity&gt; collect = relationEntities.stream().map(item -&gt; {
        Long brandId = item.getBrandId();
        BrandEntity brandEntity = brandService.getById(brandId);
        return brandEntity;
    }).collect(Collectors.toList());
    return collect;
}
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1636515964281.png" alt="" loading="lazy"><br>
2. 获取分类下所有分组和基本属性<br>
<img src="https://dxone1.github.io//post-images/1636516276038.png" alt="" loading="lazy"><br>
这个页面要求获取所选分类下所有分组和基本属性</p>
<pre><code class="language-java">/**
    * 根据分类id查询所有的group以及其中的属性
    * @param catelogId
    * @return
    */
@Override
public List&lt;AttrGroupWithAttrsVo&gt; getAttrGroupWithAttrsByCatelogId(Long catelogId) {
    // 查出所有分组
    List&lt;AttrGroupEntity&gt; groupEntities = this.list(new QueryWrapper&lt;AttrGroupEntity&gt;().eq(&quot;catelog_id&quot;, catelogId));
    // 查询所有属性
    List&lt;AttrGroupWithAttrsVo&gt; collect = groupEntities.stream().map(group -&gt; {
        AttrGroupWithAttrsVo attrGroupWithAttrsVo = new AttrGroupWithAttrsVo();
        // 封装
        BeanUtils.copyProperties(group, attrGroupWithAttrsVo);
        // 查询属性
        Long attrGroupId = group.getAttrGroupId();
        List&lt;AttrEntity&gt; attrEntities = attrService.getRelationAttr(attrGroupId);
        attrGroupWithAttrsVo.setAttrs(attrEntities);

        return attrGroupWithAttrsVo;
    }).collect(Collectors.toList());

    return collect;
}
</code></pre>
<p>效果<br>
<img src="https://dxone1.github.io//post-images/1636519102576.png" alt="" loading="lazy"><br>
3. 返回的是一个很大的Json串，为了合理的封装使用一个SpuSaveVo封装。使用在线的生成工具即可生成，然后编写保存逻辑，以下是业务逻辑</p>
<pre><code class="language-txt">//1. 保存SPU基本信息 pms_spu_info
//2. 保存SPU的描述图片 pms_spu_info_desc
//3. 保存SPU的图片集 pms_spu_images
//4. 保存SPU的规格参数 pms_product_attr_value
//5. 保存SPU的积分信息 跨库：mall_sms -&gt; sms_spu_bounds
//6. 保存当前SPU对应的所有SKU信息
    //6.1. SKU的基本信息 pms_sku_info
    //6.2. SKU的图片 pms_sku_images
    //6.3. SKU的销售属性 pms_sku_sale_attr_value
    //6.4. SKU的优惠信息 跨库：mall_sms -&gt; sms_sku_ladder, sms_sku_full_reduction, sms_member_price
</code></pre>
<p>注意有两个跨服务逻辑：使用mall-coupon提供的远程调用，使用openFeign。服务间调用使用TO封装数据，都是传递json</p>
<pre><code class="language-java">@Transactional
@Override
public void saveSpuInfo(SpuSaveVo vo) {
    //1. 保存SPU基本信息 pms_spu_info
    SpuInfoEntity infoEntity = new SpuInfoEntity();
    BeanUtils.copyProperties(vo, infoEntity);
    infoEntity.setCreateTime(new Date());
    infoEntity.setUpdateTime(new Date());
    this.saveBaseSpuInfo(infoEntity);

    //2. 保存SPU的描述图片 pms_spu_info_desc
    List&lt;String&gt; decript = vo.getDecript();
    SpuInfoDescEntity descEntity = new SpuInfoDescEntity();
    descEntity.setSpuId(infoEntity.getId());
    descEntity.setDecript(String.join(&quot;,&quot;, decript));
    spuInfoDescService.saveSpuInfoDesc(descEntity);

    //3. 保存SPU的图片集 pms_spu_images
    List&lt;String&gt; images = vo.getImages();
    spuImagesService.saveImages(infoEntity.getId(), images);

    //4. 保存SPU的规格参数 pms_product_attr_value
    List&lt;BaseAttrs&gt; baseAttrs = vo.getBaseAttrs();
    List&lt;ProductAttrValueEntity&gt; collect = baseAttrs.stream().map(attr -&gt; {
        ProductAttrValueEntity valueEntity = new ProductAttrValueEntity();
        valueEntity.setAttrId(attr.getAttrId());
        // 查属性entity
        AttrEntity attrEntity = attrService.getById(attr.getAttrId());
        valueEntity.setAttrName(attrEntity.getAttrName());
        valueEntity.setAttrValue(attr.getAttrValues());
        valueEntity.setQuickShow(attr.getShowDesc());
        valueEntity.setSpuId(infoEntity.getId());
        return valueEntity;
    }).collect(Collectors.toList());
    productAttrValueService.saveProductAttr(collect);

    //5. 保存SPU的积分信息 跨库：mall_sms -&gt; sms_spu_bounds
    // 封装远程调用数据
    Bounds bounds = vo.getBounds();
    SpuBoundTo spuBoundTo = new SpuBoundTo();
    BeanUtils.copyProperties(bounds, spuBoundTo);
    spuBoundTo.setSpuId(infoEntity.getId());
    // 远程调用
    R r = couponFeignService.saveSpuBounds(spuBoundTo);
    if(r.getCode() != 0) {
        log.error(&quot;远程保存spu积分信息失败&quot;);
    }

    //6. 保存当前SPU对应的所有SKU信息
    List&lt;Skus&gt; skus = vo.getSkus();
    if(skus != null &amp;&amp; skus.size() &gt; 0) {
        skus.forEach(item -&gt; {
            // 获取默认图片
            String defaultImg = &quot;&quot;;
            for(Images image: item.getImages()) {
                if(image.getDefaultImg() == 1) {
                    defaultImg = image.getImgUrl();
                }
            }
            ///基本信息
            //6.1. SKU的基本信息 pms_sku_info
            SkuInfoEntity skuInfoEntity = new SkuInfoEntity();
            BeanUtils.copyProperties(item, skuInfoEntity);
            // 手动注入剩下的属性
            skuInfoEntity.setBrandId(infoEntity.getBrandId());
            skuInfoEntity.setCatalogId(infoEntity.getCatalogId());
            skuInfoEntity.setSaleCount(0L);
            skuInfoEntity.setSpuId(infoEntity.getId());
            skuInfoEntity.setSkuDefaultImg(defaultImg);
            skuInfoService.saveSkuInfo(skuInfoEntity);

            // sku自增主键
            Long skuId = skuInfoEntity.getSkuId();

            //6.2. 保存SKU的图片 pms_sku_images
            List&lt;SkuImagesEntity&gt; imagesEntities = item.getImages().stream().map(img -&gt; {
                SkuImagesEntity skuImagesEntity = new SkuImagesEntity();
                skuImagesEntity.setSkuId(skuId);
                skuImagesEntity.setImgUrl(img.getImgUrl());
                skuImagesEntity.setDefaultImg(img.getDefaultImg());
                return skuImagesEntity;
            }).filter(entity -&gt; {
                // 返回true需要，否则抛弃
                return !StringUtils.isEmpty(entity.getImgUrl());
            }).collect(Collectors.toList());
            skuImagesService.saveBatch(imagesEntities);

            //6.3. SKU的销售属性 pms_sku_sale_attr_value
            List&lt;Attr&gt; attr = item.getAttr();
            List&lt;SkuSaleAttrValueEntity&gt; skuSaleAttrValueEntities = attr.stream().map(a -&gt; {
                SkuSaleAttrValueEntity skuSaleAttrValueEntity = new SkuSaleAttrValueEntity();
                BeanUtils.copyProperties(a, skuSaleAttrValueEntity);
                skuSaleAttrValueEntity.setSkuId(skuInfoEntity.getSkuId());
                return skuSaleAttrValueEntity;
            }).collect(Collectors.toList());
            skuSaleAttrValueService.saveBatch(skuSaleAttrValueEntities);

            //6.4. SKU的优惠信息 跨库：mall_sms -&gt; sms_sku_ladder, sms_sku_full_reduction, sms_member_price
            SkuReductionTo skuReductionTo = new SkuReductionTo();
            BeanUtils.copyProperties(item, skuReductionTo);
            skuReductionTo.setSkuId(skuId);
            if(skuReductionTo.getFullCount() &gt;0 || (skuReductionTo.getFullPrice() != null &amp;&amp; skuReductionTo.getFullPrice().compareTo(new BigDecimal(&quot;0&quot;)) == 1)){
                R r1 = couponFeignService.saveSkuReduction(skuReductionTo);
                if(r1.getCode() != 0) {
                    log.error(&quot;远程保存sku积分信息失败&quot;);
                }
            }
        });
    }
</code></pre>
<p>调试需要花费很大的心思，而且并不足够健壮。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day6：平台参数]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day6ping-tai-can-shu/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day6ping-tai-can-shu/">
        </link>
        <updated>2021-11-09T03:33:51.000Z</updated>
        <content type="html"><![CDATA[<p>在平台属性功能，属性和分组需要相互关联。每个分组可能关联多个属性。规格参数功能模块会录入各种基础的属性。本日的项目目标是完成平台属性和属性的分组的相关的功能。属性分为规格参数和销售属性两类。分类和分组相互关联，每个属性会属于某个属性分组</p>
<h2 id="规格参数分组">规格参数分组</h2>
<p>规格参数是一种属性，属性属于某个分组。<br>
<img src="https://dxone1.github.io//post-images/1636429846172.png" alt="" loading="lazy"><br>
之前的工作中，品牌和分类已经通过中间表进行了多对多的相互关联。这里的参数属于某个属性分组，也通过一个中间表记录了关系。<br>
<img src="https://dxone1.github.io//post-images/1636429973290.png" alt="" loading="lazy"></p>
<ol>
<li>新增规格参数（需要指定其属性分组和分类）<br>
通过代码生成器生成的项目，如果调用属性的save功能则只会在pms_attr中保存，而不会在pms_attr_attrgroup_relation中保存关联关系，需要重写该方法。<br>
在项目包下写一个vo包，将值对象（视图对象）封装起来<br>
用处：接收页面传递来的数据，封装对象。将业务处理完成的对象，封装成页面要用的数据。<br>
编写一个attrvo的实体类，封装属性拥有的所有内容<br>
逻辑就是实体类的分层，vo只负责和页面交互，entity只负责和dao打交道。</li>
</ol>
<pre><code class="language-java">// AttrService
@Transactional
@Override
public void saveAttr(AttrVo attr) {
    // 保存基本数据
    // 先使用Entity将页面中的属性抽取出需要保存到数据库中的部分保存
    AttrEntity attrEntity = new AttrEntity();
    // 将attr中的属性拷贝到attrEntity中
    BeanUtils.copyProperties(attr, attrEntity);
    this.save(attrEntity);

    // 保存到关联关系中
    AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity();
    // 两个需要提交
    // 1. 属性分组id
    // 2. 属性id
    // 也是都从页面中拿
    relationEntity.setAttrGroupId(attr.getAttrGroupId());
    relationEntity.setAttrId(attrEntity.getAttrId());
    // 保存之后attrId也有了
    attrAttrgroupRelationDao.insert(relationEntity);
}
</code></pre>
<ol start="2">
<li>查询规格参数<br>
通过接口<code>/product/attr/base/list/225</code>访问。一样编写查询规格参数的特殊方法，原理和之前的属性分组一致，严格匹配属性id或者模糊匹配属性名。</li>
</ol>
<pre><code class="language-java">@Override
public PageUtils queryBaseAttrPage(Map&lt;String, Object&gt; params, Long catelogId) {
    QueryWrapper&lt;AttrEntity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    //if(StringUtils)

    if(catelogId != 0) {
        queryWrapper.eq(&quot;catelog_id&quot;, catelogId);
    }

    String key = (String) params.get(&quot;key&quot;);
    if(!StringUtils.isEmpty(key)) {
        queryWrapper.and((wrapper) -&gt; {
            wrapper.eq(&quot;attr_id&quot;, key).or().like(&quot;attr_name&quot;, key);
        });
    }

    IPage&lt;AttrEntity&gt; page = this.page(
            new Query&lt;AttrEntity&gt;().getPage(params),
            queryWrapper
    );
    return null;
}
</code></pre>
<p>注意返回需要有所属分类和分组的名字，也需要通过vo返回。重新编写查询逻辑</p>
<pre><code class="language-java">@Override
public PageUtils queryBaseAttrPage(Map&lt;String, Object&gt; params, Long catelogId) {
    QueryWrapper&lt;AttrEntity&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    //if(StringUtils)

    if(catelogId != 0) {
        queryWrapper.eq(&quot;catelog_id&quot;, catelogId);
    }

    String key = (String) params.get(&quot;key&quot;);
    if(!StringUtils.isEmpty(key)) {
        queryWrapper.and((wrapper) -&gt; {
            wrapper.eq(&quot;attr_id&quot;, key).or().like(&quot;attr_name&quot;, key);
        });
    }

    IPage&lt;AttrEntity&gt; page = this.page(
            new Query&lt;AttrEntity&gt;().getPage(params),
            queryWrapper
    );
    List&lt;AttrEntity&gt; records = page.getRecords();
    List&lt;AttrRespVo&gt; respVos = records.stream().map(attrEntity -&gt; {
        AttrRespVo attrRespVo = new AttrRespVo();
        BeanUtils.copyProperties(attrEntity, attrRespVo);
        // 设置分类分组名
        AttrAttrgroupRelationEntity relationEntity = attrAttrgroupRelationDao.selectOne(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;()
                .eq(&quot;attr_id&quot;, attrEntity.getAttrId()));
        if (relationEntity != null) {
            AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(relationEntity.getAttrGroupId());
            attrRespVo.setGroupName(attrGroupEntity.getAttrGroupName());
        }
        CategoryEntity categoryEntity = categoryDao.selectById(attrEntity.getCatelogId());
        if (categoryEntity != null) {
            attrRespVo.setCatelogName(categoryEntity.getName());
        }

        return attrRespVo;
    }).collect(Collectors.toList());

    PageUtils pageUtils = new PageUtils(page);
    pageUtils.setList(respVos);
    
    return pageUtils;
}
</code></pre>
<ol start="3">
<li>修改属性需要提供分类路径和分组的回显</li>
</ol>
<pre><code class="language-java">@Override
public AttrRespVo getAttrInfo(Long attrId) {
    AttrRespVo attrRespVo = new AttrRespVo();

    AttrEntity attrEntity = this.getById(attrId);
    BeanUtils.copyProperties(attrEntity, attrRespVo);
    // 设置分组id
    AttrAttrgroupRelationEntity relationEntity = attrAttrgroupRelationDao.selectOne(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_id&quot;, attrId));
    if(relationEntity != null) {
        attrRespVo.setAttrGroupId(relationEntity.getAttrGroupId());
        // 设置分组信息
        AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(relationEntity.getAttrGroupId());
        if(attrGroupEntity != null) {
            attrRespVo.setGroupName(attrGroupEntity.getAttrGroupName());
        }
    }
    // 设置分类信息:属性创建必须有名字
    Long catelogId = attrEntity.getCatelogId();
    Long[] catelogPath = categoryService.findCatelogPath(catelogId);
    attrRespVo.setCatelogPath(catelogPath);
    CategoryEntity categoryEntity = categoryDao.selectById(catelogId);
    if(categoryEntity != null) {
        attrRespVo.setCatelogName(categoryEntity.getName());
    }
    return attrRespVo;
}
</code></pre>
<ol start="4">
<li>因为有关联操作，所以必须使用vo提供更多的值进行关联修改</li>
</ol>
<pre><code class="language-java">@Transactional
@Override
public void updateAttr(AttrVo attr) {
    AttrEntity attrEntity = new AttrEntity();
    BeanUtils.copyProperties(attr, attrEntity);
    this.updateById(attrEntity);

    AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity();
    relationEntity.setAttrGroupId(attr.getAttrGroupId());
    relationEntity.setAttrId(attr.getAttrId());

    Integer cnt = attrAttrgroupRelationDao.selectCount(new UpdateWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_id&quot;, attr.getAttrId()));
    if(cnt &gt; 0) {
        // 1. 修改分组关联
        attrAttrgroupRelationDao.update(relationEntity,
                new UpdateWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_id&quot;, attr.getAttrId()));
    } else {
        // 没有则创建关联的分组
        attrAttrgroupRelationDao.insert(relationEntity);
    }
}
</code></pre>
<h2 id="销售属性和规格参数非常相似的业务逻辑">销售属性：和规格参数非常相似的业务逻辑</h2>
<p><code>/product/attr/sale/list/0</code><br>
可以在之前的controller和service上直接拓展，使得sql要求attr_type相同（销售属性或规格参数）。注意销售属性没有属性分组，不需要保存关联关系。<br>
效果如下：<br>
<img src="https://dxone1.github.io//post-images/1636457666897.png" alt="" loading="lazy"></p>
<h2 id="分组关联规格参数">分组关联规格参数</h2>
<p>规格参数属于基本信息，是SPU的部分，会和属性分组相互关联。本部分完成属性分组关联规格参数的功能。<br>
<img src="https://dxone1.github.io//post-images/1636457883839.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636457934335.png" alt="" loading="lazy"></p>
<ol>
<li>分组关联属性查询展示<br>
接口： http://localhost:88/api/product/attrgroup/{attrgroupId}/attr/relation?t=1636457954138</li>
</ol>
<pre><code class="language-java">/**
    * 根据分组id查关联属性的属性名和可选值
    * @param attrgroupId
    * @return
    */
@Override
public List&lt;AttrEntity&gt; getRelationAttr(Long attrgroupId) {
    List&lt;AttrAttrgroupRelationEntity&gt; relationEntities = attrAttrgroupRelationDao.selectList(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(&quot;attr_group_id&quot;, attrgroupId));
    List&lt;Long&gt; attrIds = relationEntities.stream().map(attr -&gt; {
        return attr.getAttrId();
    }).collect(Collectors.toList());

    Collection&lt;AttrEntity&gt; attrEntities = this.listByIds(attrIds);
    return (List&lt;AttrEntity&gt;) attrEntities;
}
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1636458651627.png" alt="" loading="lazy"><br>
2. 移除关联属性<br>
接口：http://localhost:88/api/product/attrgroup/attr/relation/delete<br>
POST: attrId和attrGroupId构造为请求参数<br>
3. 也需要提供通过属性分组页面快速添加关联的属性的功能：<br>
<strong>首先是显示出合理的可添加属性</strong><br>
<img src="https://dxone1.github.io//post-images/1636460844427.png" alt="" loading="lazy"><br>
已经关联过的不能显示了，需要查询哪些属性还可以添加到当前关联分组中。即本分类下的，还没有被其他属性分组关联过的属性<br>
接口：http://localhost:88/api/product/attrgroup/1/noattr/relation?t=1636460932886&amp;page=1&amp;limit=10&amp;key=</p>
<pre><code class="language-java">/**
    * 获取当前分组中没有关联的所有属性
    * 1.必须属于自己所属的分类
    * 2.别的分组不能引用过
    * @param params
    * @param attrgroupId
    * @return
    */
@Override
public PageUtils getNoRelationAttr(Map&lt;String, Object&gt; params, Long attrgroupId) {
    AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(attrgroupId);
    // 分类id
    Long catelogId = attrGroupEntity.getCatelogId();
    // 查当前分类下的其他分组
    List&lt;AttrGroupEntity&gt; groupEntities = attrGroupDao.selectList(new QueryWrapper&lt;AttrGroupEntity&gt;().eq(&quot;catelog_id&quot;, catelogId));
    List&lt;Long&gt; collect = groupEntities.stream().map(item -&gt; {
        return item.getAttrGroupId();
    }).collect(Collectors.toList());
    // 查这些分组关联的属性
    List&lt;AttrAttrgroupRelationEntity&gt; groupId = attrAttrgroupRelationDao.selectList(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().in(&quot;attr_group_id&quot;, collect));
    List&lt;Long&gt; attrIds = groupId.stream().map(item -&gt; {
        return item.getAttrId();
    }).collect(Collectors.toList());
    // 从当前分类所有属性中移除这些属性
    // 首先必须是当前分类下的
    // 其次排除当前分类下其他属性分组关联的属性
    QueryWrapper&lt;AttrEntity&gt; queryWrapper = new QueryWrapper&lt;AttrEntity&gt;().eq(&quot;catelog_id&quot;, catelogId).eq(&quot;attr_type&quot;, ProductConstant.AttrEnum.ATTR_TYPE_BASE.getCode());
    if(attrIds != null &amp;&amp; attrIds.size() &gt; 0) {
        queryWrapper.notIn(&quot;attr_id&quot;, attrIds);
    }

    // 如果有key的话仍然按照id匹配，名字模糊查询
    String key = (String) params.get(&quot;key&quot;);
    if(!StringUtils.isEmpty(key)) {
        queryWrapper.and((wrapper) -&gt; {
            wrapper.eq(&quot;attr_id&quot;, key).or().like(&quot;attr_name&quot;, key);
        });
    }
    // 返回按照分页查询
    IPage&lt;AttrEntity&gt; page = this.page(new Query&lt;AttrEntity&gt;().getPage(params), queryWrapper);
    PageUtils pageUtils = new PageUtils(page);

    return pageUtils;
}
</code></pre>
<p><strong>然后是添加关联的功能</strong><br>
接口为：http://localhost:88/api/product/attrgroup/attr/relation<br>
通过POST请求发送attrId和attrGroupId<br>
<img src="https://dxone1.github.io//post-images/1636464956389.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day5：商品属性分组和关联同步]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day5/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day5/">
        </link>
        <updated>2021-11-08T03:13:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="spu与sku">SPU与SKU</h2>
<ol>
<li>SPU： Standard Product Unit（标准化产品单元）<br>
是商品信息聚合的最小单位， 是一组可复用、 易检索的标准化信息的集合， 该集合描述了一个产品的特性。</li>
<li>SKU： Stock Keeping Unit（库存量单位）<br>
即库存进出计量的基本单元， 可以是以件， 盒， 托盘等为单位。 SKU 是对于大型连锁超市DC（配送中心） 物流管理的一个必要的方法。 现在已经被引申为产品统一编号的简称， 每种产品均对应有唯一的 SKU 号。</li>
</ol>
<p>【例子】<br>
iphoneX 是 SPU、 MI 8 是 SPU<br>
iphoneX 64G 黑曜石 是 SKU<br>
MI8 8+64G+黑色 是 SKU</p>
<p><strong>开发相关</strong><br>
基本属性【 规格参数】 与销售属性<br>
每个分类下的商品共享规格参数， 与销售属性。 只是有些商品不一定要用这个分类下全部的属性；</p>
<ul>
<li>属性是以三级分类组织起来的</li>
<li>规格参数中有些是可以提供检索的</li>
<li>规格参数也是基本属性， 他们具有自己的分组</li>
<li>属性的分组也是以三级分类组织起来的</li>
<li>属性名确定的， 但是值是每一个商品不同来决定的</li>
</ul>
<p>即：规格参数 ==&gt; SPU   ||   销售属性（颜色、RAM等...） ==&gt; SKU</p>
<p>属性表的设计：<br>
<img src="https://dxone1.github.io//post-images/1636341899050.png" alt="" loading="lazy"><br>
属性分组表：<br>
<img src="https://dxone1.github.io//post-images/1636341955079.png" alt="" loading="lazy"><br>
属性和分组的关联表：<br>
<img src="https://dxone1.github.io//post-images/1636342006208.png" alt="" loading="lazy"><br>
商品属性值表：<br>
<img src="https://dxone1.github.io//post-images/1636342058067.png" alt="" loading="lazy"><br>
spu和sku都有不同的表设计，总体的表如下：<br>
<img src="https://dxone1.github.io//post-images/1636342149155.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636342329921.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636342581115.png" alt="" loading="lazy"></p>
<h2 id="商品属性分组">商品属性分组</h2>
<p>三级分类树在以后的项目中都有用处，所以先抽取出三级分类树展示模块<br>
至于右边的表格直接使用代码生成器快速生成的模板即可<br>
页面效果如下：<br>
<img src="https://dxone1.github.io//post-images/1636356452967.png" alt="" loading="lazy"><br>
抽取的公共三级分类树是子组件，我们希望当点击子组件时父组件可以感知，使用vue的事件机制可以达成。子组件给父组件发送一个事件，携带数据。element-ui定义的Tree有这样一个组件<br>
<img src="https://dxone1.github.io//post-images/1636356664260.png" alt="" loading="lazy"></p>
<ol>
<li>在子组件中绑定node-click事件</li>
</ol>
<pre><code class="language-js">&lt;el-tree
    ...
    @node-click=&quot;nodeclick&quot;
&gt;
&lt;/el-tree&gt;

nodeclick(data, node, component) {
    console.log(&quot;子组件category被点击,&quot;,data, node, component);
    // 向父组件发送事件
    this.$emit(&quot;tree-node-click&quot;, data, node, component );
}
</code></pre>
<ol start="2">
<li>父组件标记感知的事件并绑定方法</li>
</ol>
<pre><code class="language-js">&lt;category @tree-node-click=&quot;treenodeClick&quot;&gt;&lt;/category&gt;
</code></pre>
<ol start="3">
<li>后端逻辑<br>
发送给后端获取该category的表，后端写相关的controller。本项目使用脚手架工程提供了一个sql封装，后端的Service层的实现如下。作用，传入一个params表和一个catelogId，后者必须匹配，前者的key字段和&quot;attr_group_id&quot;严格匹配，与&quot;attr_group_name&quot;模糊匹配</li>
</ol>
<pre><code class="language-java"> @Override
public PageUtils queryPage(Map&lt;String, Object&gt; params, Long catelogId) {
    if (catelogId == 0) {
        IPage&lt;AttrGroupEntity&gt; page = this.page(new Query&lt;AttrGroupEntity&gt;().getPage(params),
                new QueryWrapper&lt;AttrGroupEntity&gt;());
        return new PageUtils(page);
    } else {
        String key = (String) params.get(&quot;key&quot;);
        // select * from attr_group where catelog_id = ? and (attr_group = key or attr_name like %key%)
        QueryWrapper&lt;AttrGroupEntity&gt; wrapper = new QueryWrapper&lt;AttrGroupEntity&gt;().eq(&quot;catelog_id&quot;, catelogId);
        if(!StringUtils.isEmpty(key)) {
            wrapper.and((obj) -&gt; {
                obj.eq(&quot;attr_group_id&quot;, key).or().like(&quot;attr_group_name&quot;, key);
            });
        }
        IPage&lt;AttrGroupEntity&gt; page = this.page(new Query&lt;AttrGroupEntity&gt;().getPage(params),
                wrapper);
        return new PageUtils(page);
    }
}
</code></pre>
<ol start="4">
<li>前端请求方法</li>
</ol>
<pre><code class="language-js">// 感知树节点被点击
treenodeClick(data, node, component) {
    console.log(&quot;attrgroup感知到category的节点被点击&quot;, data, node, component);
    console.log(&quot;点击的菜单id为&quot;, data.catId);
    // 只有第三级分类才查询
    if (node.level == 3) {
        this.catId = data.catId;
        this.getDataList();
    }
},
</code></pre>
<h2 id="属性分组新增修改功能">属性分组新增/修改功能</h2>
<p>只需为 Cascader 的options属性指定选项数组即可渲染出一个级联选择器。通过props.expandTrigger可以定义展开子级菜单的触发方式。<br>
给后端的children属性添加一个注解，使得其不为空时才通过json返回</p>
<pre><code class="language-java">/**
* 子分类
*/
@JsonInclude(JsonInclude.Include.NON_EMPTY)
@TableField(exist = false)
private List&lt;CategoryEntity&gt; children;
</code></pre>
<p>前端请求添加即可<br>
修改功能涉及到回显，需要在后端回显添加一个数组属性</p>
<pre><code class="language-java">@TableField(exist = false)
private Long[] catelogPath;
</code></pre>
<p>查找Path的方法：</p>
<pre><code class="language-java">@Override
public Long[] findCatelogPath(Long catelogId) {
    List&lt;Long&gt; paths = new ArrayList&lt;&gt;();
    findParentPath(catelogId, paths);
    return paths.toArray(new Long[paths.size()]);
}

private void findParentPath(Long catelogId, List&lt;Long&gt; paths) {
    CategoryEntity byId = this.getById(catelogId);
    if(byId.getParentCid() != 0) {
        findParentPath(byId.getParentCid(), paths);
    }
    // 后序遍历
    paths.add(catelogId);
}
</code></pre>
<p>效果如图：<br>
<img src="https://dxone1.github.io//post-images/1636364145316.png" alt="" loading="lazy"><br>
前端回显之后注意需要在对话框关闭后回调重置路径</p>
<pre><code class="language-js">// 关闭对话框，回调清除diaglogPath
dialogClosed(){
    this.dataForm.catelogPath = [];
}
</code></pre>
<p>对话框的写法：</p>
<pre><code class="language-js">&lt;el-dialog
    :title=&quot;!dataForm.attrGroupId ? '新增' : '修改'&quot;
    :close-on-click-modal=&quot;false&quot;
    :visible.sync=&quot;visible&quot;
    @closed=&quot;dialogClosed&quot;
&gt;
    &lt;el-form
      :model=&quot;dataForm&quot;
      :rules=&quot;dataRule&quot;
      ref=&quot;dataForm&quot;
      @keyup.enter.native=&quot;dataFormSubmit()&quot;
      label-width=&quot;80px&quot;
    &gt;
      &lt;el-form-item label=&quot;组名&quot; prop=&quot;attrGroupName&quot;&gt;
        &lt;el-input
          v-model=&quot;dataForm.attrGroupName&quot;
          placeholder=&quot;组名&quot;
        &gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;排序&quot; prop=&quot;sort&quot;&gt;
        &lt;el-input v-model=&quot;dataForm.sort&quot; placeholder=&quot;排序&quot;&gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;描述&quot; prop=&quot;descript&quot;&gt;
        &lt;el-input v-model=&quot;dataForm.descript&quot; placeholder=&quot;描述&quot;&gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;组图标&quot; prop=&quot;icon&quot;&gt;
        &lt;el-input v-model=&quot;dataForm.icon&quot; placeholder=&quot;组图标&quot;&gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;所属分类id&quot; prop=&quot;catelogId&quot;&gt;
        &lt;!-- &lt;el-input v-model=&quot;dataForm.catelogId&quot; placeholder=&quot;所属分类id&quot;&gt;&lt;/el-input&gt; --&gt;
        &lt;el-cascader
          v-model=&quot;dataForm.catelogPath&quot;
          :options=&quot;categorys&quot;
          :props=&quot;props&quot;
          filterable
        &gt;&lt;/el-cascader&gt;
      &lt;/el-form-item&gt;
    &lt;/el-form&gt;
    &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;
      &lt;el-button @click=&quot;visible = false&quot;&gt;取消&lt;/el-button&gt;
      &lt;el-button type=&quot;primary&quot; @click=&quot;dataFormSubmit()&quot;&gt;确定&lt;/el-button&gt;
    &lt;/span&gt;
&lt;/el-dialog&gt;
</code></pre>
<h2 id="品牌管理功能细化">品牌管理功能细化</h2>
<p>希望能够正确显示分页并提供品牌管理的查询功能<br>
<img src="https://dxone1.github.io//post-images/1636371869531.png" alt="" loading="lazy"><br>
根据Mybatis-plus的文档，只需要在IOC容器中添加一个PaginationInterceptor即可</p>
<pre><code class="language-java">@Configuration
@EnableTransactionManagement
@MapperScan(&quot;com.dong.mall.product.dao&quot;)
public class MyBatisConfig {
    // 引入分页插件
    // 旧版
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();
        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false
         paginationInterceptor.setOverflow(true);
        // 设置最大单页限制数量，默认 500 条，-1 不受限制
         paginationInterceptor.setLimit(100);
        // 开启 count 的 join 优化,只针对部分 left join
        paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));
        return paginationInterceptor;
    }
}
</code></pre>
<p><strong>自行编写了商品系统的：分类维护、品牌管理和属性分组功能，之后的前端代码不再重复写</strong><br>
考虑品牌和商品分类的对应：是一种多对多的关系，所以使用一张中间表处理业务。给品牌管理添加关联分类功能，是一种多对多的关系。<br>
<img src="https://dxone1.github.io//post-images/1636373493726.png" alt="" loading="lazy"><br>
需要编写如下接口：</p>
<ul>
<li>查询所有当前品牌关联的分类</li>
<li>添加新的关联分类</li>
<li>删除关联分类<br>
在CategoryBrandRelationController这里写业务</li>
</ul>
<pre><code class="language-java">/**
    * 获取当前品牌关联的所有的分类的列表
    */
@RequestMapping(&quot;/catelog/list&quot;)
public R cateloglist(@RequestParam(&quot;brandId&quot;) Long brandId) {
    List&lt;CategoryBrandRelationEntity&gt; data = categoryBrandRelationService.list(
            new QueryWrapper&lt;CategoryBrandRelationEntity&gt;().eq(&quot;brand_id&quot;, brandId)
    );
    return R.ok().put(&quot;data&quot;, data);
}

// 重写了能保存品牌和分类名的service方法
@Override
public void saveDetail(CategoryBrandRelationEntity categoryBrandRelation) {
    Long brandId = categoryBrandRelation.getBrandId();
    Long catelogId = categoryBrandRelation.getCatelogId();
    // 先查询品牌名字和分类名
    BrandEntity brandEntity = brandDao.selectById(brandId);
    CategoryEntity categoryEntity = categoryDao.selectById(catelogId);
    // 设置字段再返回
    categoryBrandRelation.setBrandName(brandEntity.getName());
    categoryBrandRelation.setCatelogName(categoryEntity.getName());
    this.save(categoryBrandRelation);
}
</code></pre>
<p>效果如图：<br>
<img src="https://dxone1.github.io//post-images/1636374659495.png" alt="" loading="lazy"><br>
然而，之前的品牌更新代码代码只是在品牌表中进行增删改查，如果实际业务表格修改就会有很大的问题，因为关联表是有冗余条目存在的，必须同步，于是采用如下操作：重写品牌的update的逻辑。而新增则在关联发生之前不需要修改。</p>
<pre><code class="language-java">// brandServiceImpl.java
@Override
public void updateDetail(BrandEntity brand) {
    // 保证冗余字段的数据一致
    this.updateById(brand);
    // 品牌名发生修改，需要修改关联表中的数据
    if(!StringUtils.isEmpty(brand.getName())) {
        // 品牌和类别关联表
        categoryBrandRelationService.updateBrand(brand.getBrandId(), brand.getName());
        //TODO 更新其他关联
    }
}
// categoryBrandRelationService.updateBrand()
@Override
public void updateBrand(Long brandId, String name) {
    CategoryBrandRelationEntity relationEntity = new CategoryBrandRelationEntity();
    relationEntity.setBrandId(brandId);
    relationEntity.setBrandName(name);
    this.update(relationEntity, new UpdateWrapper&lt;CategoryBrandRelationEntity&gt;().eq(&quot;brand_id&quot;, brandId));
}
</code></pre>
<p>测试：将品牌改为华为2，关联分类中的也变化<br>
<img src="https://dxone1.github.io//post-images/1636375664862.png" alt="" loading="lazy"><br>
同理，分类的修改也要修改关联表项目<br>
最后，注意到同时修改两张表，要么同时成功，要么同时失败，需要使用事务保证一致性。在MybatisConfig配置类已经使用@EnableTransactionManagement开启了事务管理，只需要在方法上使用@Transactiona添加事务即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day4：品牌管理]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day4pin-pai-guan-li/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day4pin-pai-guan-li/">
        </link>
        <updated>2021-11-06T11:45:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用逆向工程的前后端代码">使用逆向工程的前后端代码</h2>
<p>renren-fast的代码生成器也可以生成前端代码，首先看sql表<br>
<img src="https://dxone1.github.io//post-images/1636199377250.png" alt="" loading="lazy"><br>
添加一个品牌管理的页面，直接使用逆向生成的前端代码即可。<br>
<img src="https://dxone1.github.io//post-images/1636200595120.png" alt="" loading="lazy"></p>
<h2 id="优化前端体验">优化前端体验</h2>
<p>首先将显示状态一栏变为开关按钮，更加的人性化</p>
<ul>
<li>显示状态一栏应该改为开关</li>
<li>新增的对话框中显示状态一栏也应为开关</li>
<li>品牌地址应该为文件上传（下一节）</li>
</ul>
<pre><code class="language-js">&lt;el-table-column
    prop=&quot;showStatus&quot;
    header-align=&quot;center&quot;
    align=&quot;center&quot;
    label=&quot;显示状态&quot;
&gt;
    &lt;!-- 插入一个template --&gt;
    &lt;template slot-scope=&quot;scope&quot;&gt;
        &lt;el-switch
            v-model=&quot;scope.row.showStatus&quot;
            active-color=&quot;#13ce66&quot;
            inactive-color=&quot;#ff4949&quot;
            // 修改为1显示，0关闭
            :active-value=&quot;1&quot;
            :inactive-value=&quot;0&quot;
            @change=&quot;updateBrandStatus(scope.row)&quot;
        &gt;
        &lt;/el-switch&gt;
    &lt;/template&gt;
&lt;/el-table-column&gt;

// 回调函数
// 更新显示状态
updateBrandStatus(data) {
    console.log(&quot;状态&quot;, data);
    let { brandId, showStatus } = data;
    this.$http({
        url: this.$http.adornUrl(&quot;/product/brand/update&quot;),
        method: &quot;post&quot;,
        data: this.$http.adornData({ brandId, showStatus }, false),
    }).then(({ data }) =&gt; {
        this.$message({
            type: &quot;success&quot;,
            message: &quot;状态更新成功&quot;,
        });
    });
},
</code></pre>
<p>效果：<br>
<img src="https://dxone1.github.io//post-images/1636202534702.png" alt="" loading="lazy"></p>
<h2 id="开通云存储和使用文件上传">开通云存储和使用：文件上传</h2>
<p><img src="https://dxone1.github.io//post-images/1636257477896.png" alt="" loading="lazy"><br>
在分布式系统中，如果文件保存在服务器本地则因为负载均衡而无法确保访问，所以需要使用统一的文件存储服务器。自建服务器的效率不高，这里使用阿里云的云存储服务功能。<br>
<img src="https://dxone1.github.io//post-images/1636257725534.png" alt="" loading="lazy"><br>
为了避免直接暴露阿里云服务器的账号密码，同时减少上传文件过服务器带来的性能压力，使用如下的架构<br>
<img src="https://dxone1.github.io//post-images/1636258870146.png" alt="" loading="lazy"></p>
<ol>
<li>先导入阿里云oss依赖</li>
<li>在阿里云上开通一个子账户，配置用户和密码(AccessKeyId AccessKeySecret)<br>
<img src="https://dxone1.github.io//post-images/1636260427009.png" alt="" loading="lazy"></li>
</ol>
<pre><code class="language-java">@Test
public void testUpload() throws FileNotFoundException {
    // yourEndpoint填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。
    String endpoint = &quot;oss-cn-shanghai.aliyuncs.com&quot;;
    // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。
    String accessKeyId = &quot;（隐藏）&quot;;
    String accessKeySecret = &quot;[KeySecret]（隐藏）&quot;;

    // 创建OSSClient实例。
    OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

    // 填写本地文件的完整路径。如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件流。
    InputStream inputStream = new FileInputStream(&quot;C:\\Users\\user\\Desktop\\惠2.jpg&quot;);
    // 依次填写Bucket名称（例如examplebucket）和Object完整路径（例如exampledir/exampleobject.txt）。Object完整路径中不能包含Bucket名称。
    ossClient.putObject(&quot;dxone-mall&quot;, &quot;惠2.jpg&quot;, inputStream);

    // 关闭OSSClient。
    ossClient.shutdown();
    System.out.println(&quot;上传成功...&quot;);
}
</code></pre>
<p>效果<br>
<img src="https://dxone1.github.io//post-images/1636260852130.png" alt="" loading="lazy"><br>
也可以使用SpringCloudAlibaba的功能</p>
<pre><code class="language-xml">&lt;!--Alibaba OSS--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alicloud-oss&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>只需要在aplication.yaml中配置即可</p>
<pre><code class="language-yaml"># 文件oos服务的配置
alicloud:
    access-key: 隐藏
    secret-key: 隐藏
    oss:
        endpoint: oss-cn-shanghai.aliyuncs.com
</code></pre>
<p>也成功了<br>
<img src="https://dxone1.github.io//post-images/1636261615240.png" alt="" loading="lazy"></p>
<p><strong>服务端签名后直传服务</strong><br>
mall-third-party<br>
将oss的部分全部迁移到这个服务里，测试成功<br>
<img src="https://dxone1.github.io//post-images/1636265327134.png" alt="" loading="lazy"><br>
参考官方文档：https://help.aliyun.com/document_detail/31926.html 是服务端签名直传的最佳实践。</p>
<ol>
<li>先编写一个OssController，用于获取阿里云的policy</li>
</ol>
<pre><code class="language-java">@RestController
public class OssController {

    @Autowired
    OSS ossClient;

    @Value(&quot;${spring.cloud.alicloud.oss.endpoint}&quot;)
    private String endpoint;

    @Value(&quot;${spring.cloud.alicloud.oss.bucket}&quot;)
    private String bucket;

    @Value(&quot;${spring.cloud.alicloud.access-key}&quot;)
    private String accessId;

    @RequestMapping(&quot;/oss/policy&quot;)
    public Map&lt;String, String&gt; policy() {

        String host = &quot;https://&quot; + bucket + &quot;.&quot; + endpoint; // host的格式为 bucketname.endpoint
        // callbackUrl为上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。
        //String callbackUrl = &quot;http://88.88.88.88:8888&quot;;
        String format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date());
        String dir = format + &quot;/&quot;; // 用户上传文件时指定的前缀。
        Map&lt;String, String&gt; respMap = null;
        try {
            long expireTime = 30;
            long expireEndTime = System.currentTimeMillis() + expireTime * 1000;
            Date expiration = new Date(expireEndTime);
            // PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。
            PolicyConditions policyConds = new PolicyConditions();
            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);
            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);

            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);
            byte[] binaryData = postPolicy.getBytes(StandardCharsets.UTF_8);
            String encodedPolicy = BinaryUtil.toBase64String(binaryData);
            String postSignature = ossClient.calculatePostSignature(postPolicy);

            respMap = new LinkedHashMap&lt;String, String&gt;();
            respMap.put(&quot;accessid&quot;, accessId);
            respMap.put(&quot;policy&quot;, encodedPolicy);
            respMap.put(&quot;signature&quot;, postSignature);
            respMap.put(&quot;dir&quot;, dir);
            respMap.put(&quot;host&quot;, host);
            respMap.put(&quot;expire&quot;, String.valueOf(expireEndTime / 1000));
            // respMap.put(&quot;expire&quot;, formatISO8601Date(expiration));

        } catch (Exception e) {
            // Assert.fail(e.getMessage());
            System.out.println(e.getMessage());
        } finally {
            ossClient.shutdown();
        }
        return respMap;
    }
}
</code></pre>
<ol start="2">
<li>在gateway中配置路由</li>
</ol>
<pre><code class="language-yaml">- id: third_party_route
    uri: lb://mall-third-party
    predicates:
        - Path=/api/thirdparty/**
    # 路径重写
    filters:
        - RewritePath=/api/thirdparty/(?&lt;segment&gt;.*),/$\{segment}
    # localhost:88/api/thirdparty/** -&gt; localhost:30000/**
</code></pre>
<ol start="3">
<li>前端联调<br>
先记下bucket域名：dxone-mall.oss-cn-shanghai.aliyuncs.com<br>
将其写入单文件/多文件上传的组件中（太长了省略，也是el-ui的组件）<br>
将组件导入品牌vue中</li>
</ol>
<pre><code class="language-js">import SingleUpload from &quot;@/components/upload/singleUpload&quot;

// 使用
&lt;single-upload v-model=&quot;dataForm.logo&quot;&gt;&lt;/single-upload&gt;

// vue中声明一个component
components: { SingleUpload },
</code></pre>
<p>调整：因为之前写的Controller返回的是一个map，需要返回成R对象。<br>
<strong>在提交给OSS时存在跨域问题，在阿里云中开放跨域即可</strong><br>
效果<br>
<img src="https://dxone1.github.io//post-images/1636268792634.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636268809062.png" alt="" loading="lazy"><br>
最终能拿到该图片：图片地址也能拿到<br>
<img src="https://dxone1.github.io//post-images/1636269250814.png" alt="" loading="lazy"><br>
4. 写品牌新增功能<br>
注意需要将展示的地址换为图片显示，一样使用element-ui<br>
<img src="https://dxone1.github.io//post-images/1636270562321.png" alt="" loading="lazy"><br>
5. 表单校验功能：例如首字母只能有一个字母等<br>
Form 组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。校验规则参见 async-validator<br>
在校验规则中可以用validator指定一个方法进行校验<br>
<strong>前端校验</strong></p>
<pre><code class="language-js">firstLetter: [
    {
        validator: (rule, value, callback) =&gt; {
            if (value == &quot;&quot;) {
                callback(new Error(&quot;首字母必须填写&quot;));
            } else if (!/^[a-zA-Z]$/.test(value)) {
                callback(new Error(&quot;首字母必须在a-z或A-Z之间&quot;));
            } else {
                callback();
            }
        },
        trigger: &quot;blur&quot;,
    },
],
sort: [
    {
        validator: (rule, value, callback) =&gt; {
            if (value == &quot;&quot;) {
                callback(new Error(&quot;排序字段必须填写&quot;));
            } else if (!Number.isInteger(value) ||  value &lt; 0) {
                callback(new Error(&quot;排序必须是一个非负整数&quot;));
            } else {
                callback();
            }
        },
        trigger: &quot;blur&quot;,
    },
],
</code></pre>
<p>注意：后端做保存更新等操作时也要进行校验，保证数据的可靠性！<br>
6. 后端校验：使用JSR303</p>
<ul>
<li>给需要校验的Bean添加校验注解（见javax.validation.constraints）</li>
</ul>
<pre><code class="language-java">/**
* 品牌名
*/
@NotBlank(message = &quot;品牌名必须提交&quot;)
private String name;
</code></pre>
<ul>
<li>在Controller标注对于校验传入值标注@Valid</li>
</ul>
<pre><code class="language-java">/**
* 保存
*/
@RequestMapping(&quot;/save&quot;)
    public R save(@Valid @RequestBody BrandEntity brand){
    brandService.save(brand);

    return R.ok();
}
</code></pre>
<p>简单测试下效果：400校验不通过<br>
<img src="https://dxone1.github.io//post-images/1636271891671.png" alt="" loading="lazy"><br>
业务上需要封装错误提示<br>
紧跟校验bean后加上BindingResult，就可以自己封装</p>
<pre><code class="language-java">/**
* 保存
*/
@RequestMapping(&quot;/save&quot;)
public R save(@Valid @RequestBody BrandEntity brand, BindingResult result) {
    if (result.hasErrors()) {
        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
        result.getFieldErrors().forEach((item) -&gt; {
            // 错误提示
            String message = item.getDefaultMessage();
            // 错误字段名
            String field = item.getField();
            map.put(field, message);
        });
        return R.error(400,&quot;提交数据不合法&quot;).put(&quot;data&quot;, map);
    } else {
        brandService.save(brand);
    }
    return R.ok();
}
</code></pre>
<p>效果<br>
<img src="https://dxone1.github.io//post-images/1636272559187.png" alt="" loading="lazy"><br>
@URL可以校验URL地址<br>
@Pattern注解自定义校验规则，传正则表达式<br>
完成一个基础的校验如下：<br>
<img src="https://dxone1.github.io//post-images/1636272938144.png" alt="" loading="lazy"></p>
<h3 id="高级主题统一异常处理">高级主题：统一异常处理</h3>
<p>提取出一个ControllerAdvice类，处理所有的异常，这样原Controller只需要把异常抛出即可</p>
<pre><code class="language-java">/**
 * 集中处理所有的异常
 */
@Slf4j
@RestControllerAdvice(basePackages = &quot;com.dong.mall.product.controller&quot;)
public class MallExceptionControllerAdvice {

    /**
     * 专职处理数据校验的异常
     * @param e 异常实例
     * @return 返回json的错误信息
     */
    @ExceptionHandler(value = MethodArgumentNotValidException.class)
    public R handleValidException(MethodArgumentNotValidException e) {
        log.error(&quot;数据校验问题{},异常类型{}&quot;,e.getMessage(), e.getClass());
        BindingResult result = e.getBindingResult();
        HashMap&lt;String, String&gt; errorMap = new HashMap&lt;&gt;();
        result.getFieldErrors().forEach((item) -&gt; {
            // 错误提示
            String message = item.getDefaultMessage();
            // 错误字段名
            String field = item.getField();
            errorMap.put(field, message);
        });
        return R.error(400,&quot;提交数据不合法&quot;).put(&quot;data&quot;, errorMap);
    }

    /**
     * 兜底异常处理
     * @param throwable
     * @return
     */
    @ExceptionHandler(value = Throwable.class)
    public R handleException(Throwable throwable) {
        return R.error();
    }
}
</code></pre>
<p>规范：采用这种状态码规格</p>
<pre><code class="language-txt">* 错误码和错误信息定义类
* 1. 错误码定义规则为 5 为数字
* 2. 前两位表示业务场景， 最后三位表示错误码。 例如： 100001。 10:通用 001:系统未知
异常
* 3. 维护错误码后需要维护错误描述， 将他们定义为枚举形式
* 错误码列表：
* 10: 通用
* 001： 参数格式校验
* 11: 商品
* 12: 订单
* 13: 购物车
* 14: 物流
</code></pre>
<p>添加一个enum定义状态码</p>
<pre><code class="language-java">public enum BizCodeEnum {
    UNKNOWN_EXCEPTION(10000, &quot;系统未知异常&quot;),
    VALID_EXCEPTION(10001, &quot;参数格式校验失败&quot;);

    private int code;
    private String msg;

    BizCodeEnum(int code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public int getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }
}
</code></pre>
<p>于是输出变为</p>
<pre><code class="language-java">return R.error(BizCodeEnum.VALID_EXCEPTION.getCode(),BizCodeEnum.VALID_EXCEPTION.getMsg()).put(&quot;data&quot;, errorMap);
/*********************************/
return R.error(BizCodeEnum.UNKNOWN_EXCEPTION.getCode(), BizCodeEnum.UNKNOWN_EXCEPTION.getMsg());
</code></pre>
<h3 id="高级主题分组校验">高级主题：分组校验</h3>
<p>新增规则和修改规则很有可能不同：例如id等部分<br>
使用方法：</p>
<ol>
<li>在校验注解上标注groups属性<br>
在common中再添加用于分组校验的接口<br>
<img src="https://dxone1.github.io//post-images/1636274707620.png" alt="" loading="lazy"><br>
校验注解标注上这些接口即可</li>
</ol>
<pre><code class="language-java">/**
* 品牌id
*/
// 修改时不允许为空
@NotNull(message = &quot;修改必须指定品牌id&quot;,groups = {UpdateGroup.class})
// 新增时必须为空
@Null(message = &quot;新增不能指定品牌id&quot;, groups = {AddGroup.class})
@TableId
private Long brandId;
</code></pre>
<ol start="2">
<li>在Controller上标注@Validated()指定该controller进行哪些group的校验</li>
</ol>
<pre><code class="language-java">@RequestMapping(&quot;/save&quot;)
public R save(@Validated(AddGroup.class) @RequestBody BrandEntity brand/*, BindingResult result*/) {
</code></pre>
<p><strong>在这种情况下，没有标注分组的注解是默认不起作用的。必须指定</strong><br>
每一个都按照上述分组进行处理即可完成多场景的复杂校验。</p>
<h3 id="高级主题自定义校验">高级主题：自定义校验</h3>
<ol>
<li>编写一个自定义的校验注解<br>
考虑指定showStatus必须为指定的几种可能性</li>
</ol>
<pre><code class="language-java">/**
* 显示状态[0-不显示；1-显示]
*/
@ListValue(vals={0,1})
private Integer showStatus;
</code></pre>
<p>注解编写：</p>
<pre><code class="language-java">@Documented
// 指定用哪个校验器
@Constraint(validatedBy = {ListValueConstraintValidator.class})
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface ListValue {
    // 抄已有的校验注解
    String message() default &quot;{com.dong.common.valid.ListValue.message}&quot;;

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    int[] vals() default {};
}
</code></pre>
<p>编写配置文件</p>
<pre><code class="language-properties">com.dong.common.valid.ListValue.message=必须提交指定的值
</code></pre>
<ol start="2">
<li>编写一个自定义校验器</li>
</ol>
<pre><code class="language-java">/**
 * 自定义一个校验器
 */
public class ListValueConstraintValidator implements ConstraintValidator&lt;ListValue, Integer&gt; {
    private Set&lt;Integer&gt; set = new HashSet&lt;&gt;();

    /**
     * 初始化方法
     * @param constraintAnnotation 能从中获得校验注解标注的信息
     */
    @Override
    public void initialize(ListValue constraintAnnotation) {
        int[] vals = constraintAnnotation.vals();
        for (int val : vals) {
            set.add(val);
        }
    }

    /**
     * 判断是否校验成功
     * @param value 需要校验的值
     * @param context 校验的上下文环境
     * @return
     */
    @Override
    public boolean isValid(Integer value, ConstraintValidatorContext context) {
        return set.contains(value);
    }
}
</code></pre>
<ol start="3">
<li>关联注解和校验器<br>
测试：<br>
<img src="https://dxone1.github.io//post-images/1636277405746.png" alt="" loading="lazy"><br>
前端效果<br>
<img src="https://dxone1.github.io//post-images/1636278646366.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1636278585870.jpg" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day3：业务三级分类]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day3ye-wu-san-ji-fen-lei/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day3ye-wu-san-ji-fen-lei/">
        </link>
        <updated>2021-11-05T07:38:21.000Z</updated>
        <content type="html"><![CDATA[<p>以京东为例：<br>
<img src="https://dxone1.github.io//post-images/1636099884131.png" alt="" loading="lazy"><br>
对应的业务表<br>
<img src="https://dxone1.github.io//post-images/1636100030209.png" alt="" loading="lazy"><br>
直接使用数据sql填充数据<br>
<img src="https://dxone1.github.io//post-images/1636100222867.png" alt="" loading="lazy"></p>
<h2 id="获取分类的递归树状结构">获取分类的递归树状结构</h2>
<ol>
<li>在CategoryEntity中增加一个表示孩子分类的属性，标记为不存在于表中</li>
</ol>
<pre><code class="language-java">/**
* 子分类
*/
@TableField(exist = false)
private List&lt;CategoryEntity&gt; children;
</code></pre>
<ol start="2">
<li>编写Service方法</li>
</ol>
<pre><code class="language-java">/**
    * 查出所有分类，组装成tree结构
    * @return
    */
@Override
public List&lt;CategoryEntity&gt; listWithTree() {
    // 使用mybatis-plus的ServiceImpl提供baseMapper
    List&lt;CategoryEntity&gt; entities = baseMapper.selectList(null);
    // 组装为父子结构
    // 1. 找一级分类
    List&lt;CategoryEntity&gt; level1Menus = entities.stream().filter(categoryEntity -&gt;
        categoryEntity.getParentCid() == 0
    ).map(menu -&gt; {
        menu.setChildren(getChildren(menu, entities));
        return menu;
    }).sorted((menu1, menu2) -&gt; {
        return (menu1.getSort() == null? 0: menu1.getSort()) - (menu2.getSort() == null? 0: menu2.getSort());
    }).collect(Collectors.toList());

    return level1Menus;
}

/**
    * 递归查找所有菜单的子菜单
    * @param root 当前菜单
    * @param all 所有菜单
    * @return 当前菜单的子菜单列表
    */
private List&lt;CategoryEntity&gt; getChildren(CategoryEntity root, List&lt;CategoryEntity&gt; all) {
    List&lt;CategoryEntity&gt; children = all.stream().filter(categoryEntity -&gt; {
        return categoryEntity.getParentCid() == root.getCatId();
    }).map(categoryEntity -&gt; {
        categoryEntity.setChildren(getChildren(categoryEntity, all));
        return categoryEntity;
    }).sorted((menu1, menu2) -&gt; {
        return (menu1.getSort() == null? 0: menu1.getSort()) - (menu2.getSort() == null? 0: menu2.getSort());
    }).collect(Collectors.toList());

    return children;
}
</code></pre>
<h2 id="配置网关路由和路径">配置网关路由和路径</h2>
<p>开启renren-fast前端脚手架，通过可视化界面添加</p>
<ul>
<li>一级菜单 商品系统</li>
<li>二级系统 分类维护<br>
<img src="https://dxone1.github.io//post-images/1636103513046.png" alt="" loading="lazy"><br>
该页面的路由为http://localhost:8001/#/product-category<br>
在前端项目对应的目录定义如下：<br>
<img src="https://dxone1.github.io//post-images/1636103880194.png" alt="" loading="lazy"><br>
从elementUI查找树形控件将其放入category.vue页面中</li>
</ul>
<ol>
<li>修改前端的基地址为网关gateway地址</li>
</ol>
<pre><code class="language-js">// api接口请求地址
window.SITE_CONFIG['baseUrl'] = 'http://localhost:88/api';
</code></pre>
<ol start="2">
<li>将renren-fast注册到nacos服务发现，并将网关配置到该服务</li>
</ol>
<pre><code class="language-yaml"># mall-gateway.application.yaml
spring:
  cloud:
    gateway:
      routes:
        - id: admin_route
          uri: lb://renren-fast
          predicates:
            - Path=/api/**
            #将localhost:88/api/** -&gt; localhost:8080:/renren-fast/**
          filters:
            - RewritePath=/api/(?&lt;segment&gt;.*),/renren-fast/$\{segment}
#定义前端发送的请求都带有 /api前缀
</code></pre>
<ol start="3">
<li>解决浏览器限制js跨域问题<br>
<img src="https://dxone1.github.io//post-images/1636112033591.png" alt="" loading="lazy"><br>
跨域流程：<br>
<img src="https://dxone1.github.io//post-images/1636112201174.png" alt="" loading="lazy"></li>
</ol>
<p><strong>方法：</strong></p>
<ol>
<li>使用Nginx将其都部署为同一个域<br>
<img src="https://dxone1.github.io//post-images/1636112332326.png" alt="" loading="lazy"></li>
<li>配置当前请求允许跨域：添加响应头</li>
</ol>
<ul>
<li>Access-Control-Allow-Origin：支持哪些来源的请求跨域</li>
<li>Access-Control-Allow-Methods：支持哪些方法跨域</li>
<li>Access-Control-Allow-Credentials：跨域请求默认不包含cookie，设置为true可以包含 cookie</li>
<li>Access-Control-Expose-Headers：跨域请求暴露的字段<br>
CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：  Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如 果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。<br>
Access-Control-Max-Age：表明该响应的有效时间为多少秒。在有效时间内，浏览器无 须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果 该首部字段的值超过了最大有效时间，将不会生效。只需要在网关配置filter添加响应头即可<br>
在网关添加一个组件即可完成跨域</li>
</ul>
<pre><code class="language-java">// com.dong.mall.gateway.config.MallCorsConfiguration
@Configuration
public class MallCorsConfiguration {

    @Bean
    public CorsWebFilter corsWebFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        // 配置跨域
        corsConfiguration.addAllowedHeader(&quot;*&quot;);
        corsConfiguration.addAllowedMethod(&quot;*&quot;);
        corsConfiguration.addAllowedOrigin(&quot;*&quot;);
        corsConfiguration.setAllowCredentials(true);

        source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);
        return new CorsWebFilter(source);
    }
}
</code></pre>
<h2 id="配置三级列表展示">配置三级列表展示</h2>
<p>前面的配置中将所有的动态请求，即<code>/api</code>起头的都通过网关转给了renren-fast，三级列表需要装给product服务。注意精确路由配在前面优先匹配</p>
<pre><code class="language-yaml">- id: product_route
    uri: lb://mall-product
    predicates:
    - Path=/api/product/**
    # 路径重写
    filters:
    - RewritePath=/api/(?&lt;segment&gt;.*),/$\{segment}\
    # localhost:88/api/product/** -&gt; localhost:10000/product/**
</code></pre>
<p>将mall-product的配置放在nacos注册中心中</p>
<pre><code class="language-txt">spring.application.name=mall-product
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.namespace=productbc5693c8-0926-49a5-89fe-e597de2e2740
</code></pre>
<p>已经拿到数据了<br>
<img src="https://dxone1.github.io//post-images/1636114988673.png" alt="" loading="lazy"><br>
调整前端项目，将其展示到页面上</p>
<h2 id="分类删除功能">分类删除功能</h2>
<p>没有子菜单且被引用的可以删除<br>
前端同样使用element-ui的组件构建：使用 scoped slot<br>
在category.vue中将template块添加插槽</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;el-tree :data=&quot;menus&quot; :props=&quot;defaultProps&quot; @node-click=&quot;handleNodeClick&quot;&gt;
    &lt;span class=&quot;custom-tree-node&quot; slot-scope=&quot;{ node, data }&quot;&gt;
      &lt;span&gt;{{ node.label }}&lt;/span&gt;
      &lt;span&gt;
        &lt;el-button type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;() =&gt; append(data)&quot;&gt;
          Append
        &lt;/el-button&gt;
        &lt;el-button type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;() =&gt; remove(node, data)&quot;&gt;
          Delete
        &lt;/el-button&gt;
      &lt;/span&gt;
    &lt;/span&gt;
  &lt;/el-tree&gt;
&lt;/template&gt;
</code></pre>
<p>效果如图<br>
<img src="https://dxone1.github.io//post-images/1636116542496.png" alt="" loading="lazy"><br>
定义：只有没有子菜单才能delete，只有一二级菜单才能append</p>
<ol>
<li>后端代码<br>
需要配置逻辑删除，在逻辑删除字段添加@TableLogic逻辑删除注解</li>
</ol>
<pre><code class="language-java">@Override
public void removeMenuByIds(List&lt;Long&gt; asList) {
    // TODO 1.检查当前菜单是否被其他地方引用，否则删除菜单
    // 逻辑删除：将标识位标为0不显示
    baseMapper.deleteBatchIds(asList);
}

// entity
@TableLogic(value = &quot;1&quot;, delval = &quot;0&quot;)
private Integer showStatus;
</code></pre>
<ol start="2">
<li>前后协调<br>
在前端编写remove(node, data)方法，通过post请求给后端（通过网关）删除操作。再请求页面刷新即可。需要完善的功能为：</li>
</ol>
<ul>
<li>消息提示框</li>
<li>删除后不能收起分栏</li>
<li>删除成功应当由消息框<br>
最终的前端代码如下：</li>
</ul>
<pre><code class="language-js">&lt;template&gt;
  &lt;el-tree
    :data=&quot;menus&quot;
    show-checkbox
    node-key=&quot;catId&quot;
    :props=&quot;defaultProps&quot;
    :expand-on-click-node=&quot;false&quot;
    :default-expanded-keys=&quot;expandedKey&quot;
  &gt;
    &lt;span class=&quot;custom-tree-node&quot; slot-scope=&quot;{ node, data }&quot;&gt;
      &lt;span&gt;{{ node.label }}&lt;/span&gt;
      &lt;span&gt;
        &lt;!-- 通过v-if完成菜单的显示条件 --&gt;
        &lt;el-button
          v-if=&quot;node.level &lt;= 2&quot;
          type=&quot;text&quot;
          size=&quot;mini&quot;
          @click=&quot;() =&gt; append(data)&quot;
        &gt;
          Append
        &lt;/el-button&gt;
        &lt;el-button
          v-if=&quot;node.childNodes.length == 0&quot;
          type=&quot;text&quot;
          size=&quot;mini&quot;
          @click=&quot;() =&gt; remove(node, data)&quot;
        &gt;
          Delete
        &lt;/el-button&gt;
      &lt;/span&gt;
    &lt;/span&gt;
  &lt;/el-tree&gt;
&lt;/template&gt;

&lt;script&gt;
//这里可以导入其他文件（比如： 组件， 工具 js， 第三方插件 js， json文件， 图片文件等等）
//例如： import 《组件名称》 from '《组件路径》 ';

export default {
  //import 引入的组件需要注入到对象中才能使用
  components: {},
  props: {},
  data() {
    return {
      menus: [],
      // 默认展开的属性
      expandedKey: [],
      defaultProps: {
        // 使用children分级
        children: &quot;children&quot;,
        // 取出name属性作为显示的
        label: &quot;name&quot;,
      },
    };
  },
  methods: {
    getMenus() {
      this.$http({
        url: this.$http.adornUrl(&quot;/product/category/list/tree&quot;),
        method: &quot;get&quot;,
        // 解构，取出data同名属性
        // 信息存在于data.data.data中
      }).then(({ data }) =&gt; {
        console.log(&quot;成功获取菜单数据：&quot;, data.data);
        // 提供给data中的menus实例
        this.menus = data.data;
      });
    },
    append(data) {
      console.log(&quot;append&quot;, data);
    },
    remove(node, data) {
      var ids = [data.catId];
    
      // 显示删除的消息提示
      this.$confirm(`是否删除【${data.name}】菜单?`, &quot;提示&quot;, {
        confirmButtonText: &quot;确定&quot;,
        cancelButtonText: &quot;取消&quot;,
        type: &quot;warning&quot;,
      })
        .then(() =&gt; {
          this.$http({
            url: this.$http.adornUrl(&quot;/product/category/delete&quot;),
            method: &quot;post&quot;,
            data: this.$http.adornData(ids, false),
          }).then(({ data }) =&gt; {
            console.log(&quot;删除成功...&quot;);
            // 重新请求菜单并展示
            this.getMenus();
            // 设置默认展开菜单
            this.expandedKey = [node.parent.data.catId]
          });
          // 消息提示：删除成功
          this.$message({
            message: &quot;菜单删除成功&quot;,
            type: &quot;success&quot;,
          });
        })
        .catch(() =&gt; {

        });
    },
  },

  //计算属性 类似于 data 概念
  computed: {},
  //监控 data 中的数据变化
  watch: {},
  //方法集合

  //生命周期 - 创建完成（可以访问当前 this 实例）
  created() {
    this.getMenus();
  },
  //生命周期 - 挂载完成（可以访问 DOM 元素）
  mounted() {},
  beforeCreate() {}, //生命周期 - 创建之前
  beforeMount() {}, //生命周期 - 挂载之前
  beforeUpdate() {}, //生命周期 - 更新之前
  updated() {}, //生命周期 - 更新之后
  beforeDestroy() {}, //生命周期 - 销毁之前
  destroyed() {}, //生命周期 - 销毁完成
  activated() {}, //如果页面有 keep-alive 缓存功能， 这个函数会触发
};
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<p>效果：<br>
<img src="https://dxone1.github.io//post-images/1636166899176.png" alt="" loading="lazy"></p>
<h2 id="分类增加功能">分类增加功能</h2>
<ol>
<li>先处理前端的代码<br>
我们希望在插入时会出现对话框可以写入添加的名字，并自动计算所需的数值（方便插入数据库）。首先在template中添加一个和el-dialog，并嵌入一个对话框。对话框输入框与属性绑定，设置对话框的回调函数。</li>
</ol>
<pre><code class="language-js">&lt;!-- 表单中的form, 和category绑定 --&gt;
&lt;el-dialog title=&quot;提示&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot;&gt;
    &lt;el-form :model=&quot;category&quot;&gt;
    &lt;el-form-item label=&quot;分类名称&quot;&gt;
        &lt;!-- 输入框和category.name双向绑定 --&gt;
        &lt;el-input v-model=&quot;category.name&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;/el-form&gt;

    &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;
    &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt;
    &lt;!-- 确定调用addCategory函数 --&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;addCategory&quot;&gt;确 定&lt;/el-button&gt;
    &lt;/span&gt;
&lt;/el-dialog&gt;
</code></pre>
<p>设置一组数据属性</p>
<pre><code class="language-js">category: { name: &quot;&quot;, parentCid: 0, catLevel: 0, showStatus: 1, sort: 0 },
</code></pre>
<p>在append()方法中添加相应的计算流程</p>
<pre><code class="language-js">append(data) {
    console.log(&quot;append&quot;, data);
    this.dialogVisible = true;
    // 在append时构造好category对象，方便插入
    this.category.parentCid = data.catId;
    this.category.catLevel = data.catLevel * 1 + 1;
},
</code></pre>
<p>编写<code>addCategory()</code>的回调函数</p>
<pre><code class="language-js">// 添加分类的方法
addCategory() {
    console.log(&quot;提交的数据,&quot;, this.category);
    this.$http({
    url: this.$http.adornUrl(&quot;/product/category/save&quot;),
    method: &quot;post&quot;,
    data: this.$http.adornData(this.category, false),
    }).then(({ data }) =&gt; {
    // 消息提示：保存成功
    this.$message({
        message: &quot;菜单保存成功&quot;,
        type: &quot;success&quot;,
    });
    // 关闭对话框并刷新
    this.dialogVisible = false;
    this.getMenus();
    this.expandedKey = [this.category.parentCid];
    });
}
</code></pre>
<p>效果<br>
<img src="https://dxone1.github.io//post-images/1636168720087.png" alt="" loading="lazy"></p>
<h2 id="分类修改功能">分类修改功能</h2>
<p>涉及到表单复用，回显等问题，代码如下</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;div&gt;
    &lt;el-tree
      :data=&quot;menus&quot;
      show-checkbox
      node-key=&quot;catId&quot;
      :props=&quot;defaultProps&quot;
      :expand-on-click-node=&quot;false&quot;
      :default-expanded-keys=&quot;expandedKey&quot;
    &gt;
      &lt;span class=&quot;custom-tree-node&quot; slot-scope=&quot;{ node, data }&quot;&gt;
        &lt;span&gt;{{ node.label }}&lt;/span&gt;
        &lt;span&gt;
          &lt;!-- 通过v-if完成菜单的显示条件 --&gt;
          &lt;el-button
            v-if=&quot;node.level &lt;= 2&quot;
            type=&quot;text&quot;
            size=&quot;mini&quot;
            @click=&quot;() =&gt; append(data)&quot;
          &gt;
            Append
          &lt;/el-button&gt;
          &lt;el-button
            v-if=&quot;node.childNodes.length == 0&quot;
            type=&quot;text&quot;
            size=&quot;mini&quot;
            @click=&quot;() =&gt; remove(node, data)&quot;
          &gt;
            Delete
          &lt;/el-button&gt;
          &lt;el-button type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;() =&gt; edit(data)&quot;&gt;
            Edit
          &lt;/el-button&gt;
        &lt;/span&gt;
      &lt;/span&gt;
    &lt;/el-tree&gt;

    &lt;!-- 表单中的form, 和category绑定 --&gt;
    &lt;el-dialog
      :title=&quot;title&quot;
      :visible.sync=&quot;dialogVisible&quot;
      width=&quot;30%&quot;
      :close-on-click-modal=&quot;false&quot;
    &gt;
      &lt;el-form :model=&quot;category&quot;&gt;
        &lt;el-form-item label=&quot;分类名称&quot;&gt;
          &lt;!-- 输入框和category.name双向绑定 --&gt;
          &lt;el-input v-model=&quot;category.name&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;图标&quot;&gt;
          &lt;!-- 输入框和category.name双向绑定 --&gt;
          &lt;el-input v-model=&quot;category.icon&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;计量单位&quot;&gt;
          &lt;!-- 输入框和category.name双向绑定 --&gt;
          &lt;el-input
            v-model=&quot;category.productUnit&quot;
            autocomplete=&quot;off&quot;
          &gt;&lt;/el-input&gt;
        &lt;/el-form-item&gt;
      &lt;/el-form&gt;

      &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;
        &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt;
        &lt;!-- 确定调用addCategory函数 --&gt;
        &lt;el-button type=&quot;primary&quot; @click=&quot;submitData&quot;&gt;确 定&lt;/el-button&gt;
      &lt;/span&gt;
    &lt;/el-dialog&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
//这里可以导入其他文件（比如： 组件， 工具 js， 第三方插件 js， json文件， 图片文件等等）
//例如： import 《组件名称》 from '《组件路径》 ';

export default {
  //import 引入的组件需要注入到对象中才能使用
  components: {},
  props: {},
  data() {
    return {
      category: {
        title: &quot;&quot;,
        dialogType: &quot;&quot;, //想复用对话框, add/edit表示
        name: &quot;&quot;,
        parentCid: 0,
        catLevel: 0,
        showStatus: 1,
        sort: 0,
        catId: null,
        icon: &quot;&quot;,
        productUnit: &quot;&quot;,
      },
      dialogVisible: false,
      menus: [],
      // 默认展开的属性
      expandedKey: [],
      defaultProps: {
        // 使用children分级
        children: &quot;children&quot;,
        // 取出name属性作为显示的
        label: &quot;name&quot;,
      },
    };
  },
  methods: {
    getMenus() {
      this.$http({
        url: this.$http.adornUrl(&quot;/product/category/list/tree&quot;),
        method: &quot;get&quot;,
        // 解构，取出data同名属性
      }).then(({ data }) =&gt; {
        console.log(&quot;成功获取菜单数据：&quot;, data.data);
        // 提供给data中的menus实例
        this.menus = data.data;
      });
    },
    append(data) {
      console.log(&quot;append&quot;, data);
      this.dialogType = &quot;add&quot;;
      // 对话框类型
      this.dialogVisible = true;
      // 对话框标题
      this.title = &quot;添加分类&quot;;
      // 在append时构造好category对象，方便插入
      this.category.parentCid = data.catId;
      this.category.catLevel = data.catLevel * 1 + 1;
      // 去除回显
      this.category.name = &quot;&quot;;
      this.category.catId = null;
      this.category.icon = &quot;&quot;;
      this.category.productUnit = &quot;&quot;;
      this.category.sort = 0;
      this.category.showStatus = 1;
    },
    remove(node, data) {
      var ids = [data.catId];

      // 显示删除的消息提示
      this.$confirm(`是否删除【${data.name}】菜单?`, &quot;提示&quot;, {
        confirmButtonText: &quot;确定&quot;,
        cancelButtonText: &quot;取消&quot;,
        type: &quot;warning&quot;,
      })
        .then(() =&gt; {
          this.$http({
            url: this.$http.adornUrl(&quot;/product/category/delete&quot;),
            method: &quot;post&quot;,
            data: this.$http.adornData(ids, false),
          }).then(({ data }) =&gt; {
            console.log(&quot;删除成功...&quot;);
            // 重新请求菜单并展示
            this.getMenus();
            // 设置默认展开菜单
            this.expandedKey = [node.parent.data.catId];
          });
          // 消息提示：删除成功
          this.$message({
            message: &quot;菜单删除成功&quot;,
            type: &quot;success&quot;,
          });
        })
        .catch(() =&gt; {});
    },
    edit(data) {
      console.log(&quot;修改的数据：&quot;, data);
      this.dialogType = &quot;edit&quot;;
      // 对话框标题
      this.title = &quot;修改分类&quot;;
      // 开启内嵌表单
      this.dialogVisible = true;
      // 发送请求获取最新数据
      this.$http({
        url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
        method: &quot;get&quot;,
      }).then(({ data }) =&gt; {
        console.log(&quot;回显数据&quot;, data);
        // 将当前分类名回显
        this.category.name = data.data.name;
        // 修改id
        this.category.catId = data.data.catId;
        this.category.icon = data.data.icon;
        this.category.productUnit = data.data.productUnit;
        this.category.parentCid = data.data.parentCid;
        this.category.catLevel = data.data.catLevel;
        this.category.sort = data.data.sort;
        this.category.showStatus = data.data.showStatus;
      });
    },
    // 添加分类的方法
    addCategory() {
      console.log(&quot;提交的数据,&quot;, this.category);
      this.$http({
        url: this.$http.adornUrl(&quot;/product/category/save&quot;),
        method: &quot;post&quot;,
        data: this.$http.adornData(this.category, false),
      }).then(({ data }) =&gt; {
        // 消息提示：保存成功
        this.$message({
          message: &quot;菜单保存成功&quot;,
          type: &quot;success&quot;,
        });
        // 关闭对话框并刷新
        this.dialogVisible = false;
        this.getMenus();
        this.expandedKey = [this.category.parentCid];
      });
    },
    // 修改分类的方法
    editCategory() {
      var { catId, name, icon, productUnit } = this.category;
      this.$http({
        url: this.$http.adornUrl(&quot;/product/category/update&quot;),
        method: &quot;post&quot;,
        data: this.$http.adornData(
          // 只发需要修改的部分
          { catId, name, icon, productUnit },
          false
        ),
      }).then(({ data }) =&gt; {
        // 消息提示：修改成功
        this.$message({
          message: &quot;菜单修改成功&quot;,
          type: &quot;success&quot;,
        });
        // 关闭对话框并刷新
        this.dialogVisible = false;
        this.getMenus();
        this.expandedKey = [this.category.parentCid];
      });
    },
    // 分支复用对话框
    submitData() {
      if (&quot;add&quot; == this.dialogType) {
        this.addCategory();
      }
      if (&quot;edit&quot; == this.dialogType) {
        this.editCategory();
      }
    },
  },

  //计算属性 类似于 data 概念
  computed: {},
  //监控 data 中的数据变化
  watch: {},
  //方法集合

  //生命周期 - 创建完成（可以访问当前 this 实例）
  created() {
    this.getMenus();
  },
  //生命周期 - 挂载完成（可以访问 DOM 元素）
  mounted() {},
  beforeCreate() {}, //生命周期 - 创建之前
  beforeMount() {}, //生命周期 - 挂载之前
  beforeUpdate() {}, //生命周期 - 更新之前
  updated() {}, //生命周期 - 更新之后
  beforeDestroy() {}, //生命周期 - 销毁之前
  destroyed() {}, //生命周期 - 销毁完成
  activated() {}, //如果页面有 keep-alive 缓存功能， 这个函数会触发
};
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<h2 id="拖拽功能">拖拽功能</h2>
<p>实现通过拖拽节点改变节点的父子关系，通过 draggable 属性可让节点变为可拖拽。</p>
<ol>
<li>不允许拖拽出第四层，所有要有一些判断，通过allow-drop设置</li>
</ol>
<pre><code class="language-js">allowDrop(draggingNode, dropNode, type) {
    // 被拖动的当前节点和父节点总层数不能大于三
    // 1. 当前节点层数
    console.log(draggingNode, dropNode, type)
    // 统计当前被拖动节点总层数
    this.countNodeLevel(draggingNode.data);
    let deep = this.maxLevel - draggingNode.data.catLevel + 1;
    // 拖动到里面
    if(type == &quot;inner&quot;) {
        return deep + dropNode.level &lt;= 3;
    }
    // 否则按前后拖动计算
    return deep + dropNode.parent.level &lt;= 3;
},
countNodeLevel(node) {
    if(node.children != null &amp;&amp; node.children.length &gt; 0) {
        for(let i=0; i &lt; node.children.length; i++) {
            if(node.children[i].catLevel &gt; this.maxLevel) {
                this.maxLevel = node.children[i].catLevel;
            }
            this.countNodeLevel(node.children[i]);
        }
    }
},
</code></pre>
<ol start="2">
<li>前端收集更改的数据，用于修改后端数据库<br>
使用node-drop，注意一旦拖拽就会改变如下内容：</li>
</ol>
<ul>
<li>拖拽节点和子节点的层级</li>
<li>拖拽节点和兄弟节点的sort</li>
<li>当前节点的父id<br>
根据拖拽的类型不同也需要做出区分，实现如下：<br>
先使用<code>@node-drop=&quot;handleDrop&quot;</code>启动拖拽回调，编写业务代码如下</li>
</ul>
<pre><code class="language-js">// 处理拖动事件
handleDrop(draggingNode, dropNode, dropType, ev) {
    console.log(&quot;tree drop: &quot;, draggingNode, dropNode, dropType);
    // 1.获取当前拖拽节点的最新父节点id
    let pCid = 0;
    let siblings = null;
    // 进入方式不同
    if (dropType == &quot;before&quot; || dropType == &quot;after&quot;) {
    pCid =
        dropNode.parent.data.catId == undefined
        ? 0
        : dropNode.parent.data.catId;
    siblings = dropNode.parent.childNodes;
    } else {
    pCid = dropNode.data.catId;
    siblings = dropNode.childNodes;
    }
    // 2.获取当前拖拽节点的sort
    for (let i = 0; i &lt; siblings.length; i++) {
    // 如果遍历的是正在拖拽的节点
    // 其父节点也会被改变
    if (siblings[i].data.catId == draggingNode.data.catId) {
        let catLevel = draggingNode.level;
        // 如果当前层级发生了变化
        if (siblings[i].level != draggingNode.level) {
        // 修改当前节点的层级
        catLevel = siblings[i].level;
        // 递归修改子节点的层级
        this.updateChildNodeLevel(siblings[i]);
        }
        this.updateNodes.push({
        catId: siblings[i].data.catId,
        sort: i,
        parentCid: pCid,
        catLevel: catLevel,
        });
    } else {
        this.updateNodes.push({ catId: siblings[i].data.catId, sort: i });
    }
    }
    console.log(&quot;updateNodes:&quot;, this.updateNodes);
    // 3.获取当前拖拽节点的最新层级
},
// 递归改变子节点的层级
updateChildNodeLevel(node) {
    if (node.childNodes.length &gt; 0) {
    for (let i = 0; i &lt; node.childNodes.length; i++) {
        var cNode = node.childNodes[i].data;
        this.updateNodes.push({
        catId: cNode.catId,
        catLevel: node.childNodes[i].level,
        });
        this.updateChildNodeLevel(node.childNodes[i]);
    }
    }
},
</code></pre>
<p>注意定义了一个新的data<code>updateNodes: [], // 需要修改的节点</code>，收集修改的数据<br>
3. 后端代码和前端调用<br>
后端直接用Servive自动生成的批量修改接口即可</p>
<pre><code class="language-java">/**
* 处理拖拽业务的批量更新
* @param category 分类数组
* @return 修改成功消息
*/
@RequestMapping(&quot;/update/sort&quot;)
public R updateSort(@RequestBody CategoryEntity[] category){
    categoryService.updateBatchById(Arrays.asList(category));
    return R.ok();
}
</code></pre>
<p>前端需要做以下工作：</p>
<ul>
<li>发送http请求</li>
<li>刷新页面并打开新的父节点层级</li>
<li><strong>重新初始化最大节点深度和需更新的节点信息</strong></li>
</ul>
<pre><code class="language-js"> // 3.获取当前拖拽节点的最新层级
// 将数据发送给后端
this.$http({
    url: this.$http.adornUrl(&quot;/product/category/update/sort&quot;),
    method: &quot;post&quot;,
    data: this.$http.adornData(this.updateNodes, false),
}).then(({ data }) =&gt; {
    // 消息提示：菜单顺序等修改成功
    this.$message({
        message: &quot;菜单顺序等修改成功&quot;,
        type: &quot;success&quot;,
    });
    // 还需要刷新菜单并展开新父节点
    this.getMenus();
    this.expandedKey = [pCid];
    // 记得完成后要及时复原需更新的节点和深度信息
    this.updateNodes = [];
    this.maxLevel = 0;
});
</code></pre>
<p>效果如图所示<br>
<img src="https://dxone1.github.io//post-images/1636185979878.png" alt="" loading="lazy"></p>
<h2 id="优化-批量拖拽功能">优化-批量拖拽功能</h2>
<ol>
<li>拖拽很容易误操作，首先添加一个开启拖拽的开关</li>
</ol>
<pre><code class="language-js">&lt;el-switch v-model=&quot;draggable&quot; active-text=&quot;开启拖拽&quot; inactive-text=&quot;关闭拖拽&quot;&gt;
&lt;/el-switch&gt;
&lt;el-tree
    :data=&quot;menus&quot;
    show-checkbox
    node-key=&quot;catId&quot;
    :props=&quot;defaultProps&quot;
    :expand-on-click-node=&quot;false&quot;
    :default-expanded-keys=&quot;expandedKey&quot;
    :draggable=&quot;draggable&quot;
    :allow-drop=&quot;allowDrop&quot;
    @node-drop=&quot;handleDrop&quot;
&gt;
</code></pre>
<ol start="2">
<li>添加按钮，只有提交的时候才提交给数据库</li>
</ol>
<pre><code class="language-js">&lt;el-button v-if=&quot;draggable&quot; @click=&quot;batchSave&quot;&gt;批量保存&lt;/el-button&gt;
</code></pre>
<ol start="3">
<li>各种修改，完成功能：</li>
</ol>
<ul>
<li>将发送请求变更为批量保存之后</li>
<li>将所有的变更项的父节点记录下来，以后要一起展开</li>
</ul>
<pre><code class="language-js"> // 批量保存拖动功能
batchSave() {
    // 将数据发送给后端
    this.$http({
        url: this.$http.adornUrl(&quot;/product/category/update/sort&quot;),
        method: &quot;post&quot;,
        data: this.$http.adornData(this.updateNodes, false),
    }).then(({ data }) =&gt; {
        // 消息提示：菜单顺序等修改成功
        this.$message({
            message: &quot;菜单顺序等修改成功&quot;,
            type: &quot;success&quot;,
        });
        // 还需要刷新菜单并展开新父节点
        this.getMenus();
        this.expandedKey = this.pCid;
        // 记得完成后要及时复原需更新的节点和深度信息
        this.updateNodes = [];
        this.maxLevel = 0;
        // this.pCid = 0;
    });
},
</code></pre>
<p>最终效果如图<br>
<img src="https://dxone1.github.io//post-images/1636188005367.png" alt="" loading="lazy"></p>
<h2 id="分类批量删除功能">分类批量删除功能</h2>
<p>添加一个危险样式的按钮：批量删除，绑定到一个方法上<br>
获取tree中的所有被选中的节点，element-ui提供了相关方法，但首先要给el-tree添加一个标志，从而能拿到该组件</p>
<pre><code class="language-js">ref=&quot;menuTree&quot;
</code></pre>
<p>编写批量删除的逻辑</p>
<pre><code class="language-js">// 批量删除功能
batchDelete() {
    // 获取所有全选中节点
    // 两个参数：是否只包含叶子节点、是否包含半选节点，默认都是false,符合业务逻辑
    let checkedNodes = this.$refs.menuTree.getCheckedNodes();
    console.log(&quot;被选中的元素:&quot;, checkedNodes);
    // 只要向后端发送批量删除请求即可
    // 要删除的ID集合
    let catIds = [];
    let names = [];
    for (let i = 0; i &lt; checkedNodes.length; i++) {
        catIds.push(checkedNodes[i].catId);
        names.push(checkedNodes[i].name);
    }
    // 确认和删除逻辑
    this.$confirm(`是否批量删除【${names}】菜单?`, &quot;提示&quot;, {
        confirmButtonText: &quot;确定&quot;,
        cancelButtonText: &quot;取消&quot;,
        type: &quot;warning&quot;,
    })
    .then(() =&gt; {
        this.$http({
            url: this.$http.adornUrl(&quot;/product/category/delete&quot;),
            method: &quot;post&quot;,
            data: this.$http.adornData(catIds, false),
            }).then(({ data }) =&gt; {
            console.log(&quot;删除成功...&quot;);
            // 消息提示：删除成功
            this.$message({
                message: &quot;菜单批量删除成功&quot;,
                type: &quot;success&quot;,
            });
            // 重新请求菜单并展示
            this.getMenus();
        });
    })
    .catch(() =&gt; {});
}
</code></pre>
<p>效果如下<br>
<img src="https://dxone1.github.io//post-images/1636189429981.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 番外：前端基础]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day0qian-duan-ji-chu/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day0qian-duan-ji-chu/">
        </link>
        <updated>2021-11-04T02:41:07.000Z</updated>
        <content type="html"><![CDATA[<p>之前没有什么前端经验，只是简单了解javaScript。本番外篇记录入门级的vue等前端知识学习。</p>
<h2 id="es6">ES6</h2>
<p>ECMAScript 6.0（ 以下简称 ES6， ECMAScript 是一种由 Ecma 国际(前身为欧洲计算机制造商协会,英文名称是 European Computer Manufacturers Association)通过 ECMA-262标准化的脚本程序设计语言） 是 JavaScript 语言的下一代标准。<br>
创建一个项目实操一下！</p>
<h3 id="1-声明变量">1 声明变量</h3>
<ol>
<li>在vscode中新建一个文件夹，新建一个文件：let.htlml</li>
<li>快捷键shift + !快速给html生成模板</li>
<li>测试代码：let声明变量的特性</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;script&gt;
        // var 声明的变量往往会越域
        // let 声明的变量有严格局部作用域
        {
            var a = 1;
            let b = 2;
        } 
        console.log(a); // 1
        console.log(b); // ReferenceError: b is not defined
        // var 可以声明多次
        // let 只能声明一次
        var m = 1
        var m = 2
        let n = 3
        // let n = 4
        console.log(m) // 2
        console.log(n) // Identifier 'n' has already been declared
        // var 会变量提升
        // let 不存在变量提升
        console.log(x); // undefined
        var x = 10;
        console.log(y); //ReferenceError: y is not defined
        let y = 20;
    &lt;/script&gt;
    
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="4">
<li>const声明的变量不能再次赋值</li>
<li>vs code鼠标右键open with live server可以调出浏览器查看</li>
</ol>
<h3 id="2-解构表达式">2 解构表达式</h3>
<ol>
<li>数组的快速赋值</li>
</ol>
<pre><code class="language-html">&lt;script&gt;
        let arr = [1,2,3];

        let [a,b,c] = arr;
        
        console.log(a,b,c);
 &lt;/script&gt;
</code></pre>
<ol start="2">
<li>对象解构<br>
vs code 的快速格式化代码快捷键是Alt + shift + F，不同于idea的ctrl + alt + L</li>
</ol>
<pre><code class="language-js">const person = {
    name: &quot;jack&quot;,
    age: 21,
    language: ['java', 'js', 'css']
}
// const name = person.name;
// const age = person.age;
// const language = person.language;

const {name:abc, age, language} = person;
console.log(abc, age, language);
</code></pre>
<ol start="3">
<li>字符串扩展</li>
</ol>
<pre><code class="language-js">let str = &quot;hello.vue&quot;;
console.log(str.startsWith(&quot;hello&quot;));//true
console.log(str.endsWith(&quot;.vue&quot;));//true
console.log(str.includes(&quot;e&quot;));//true
console.log(str.includes(&quot;hello&quot;));//true
</code></pre>
<ol start="4">
<li>字符串模板：用反引号引起的一长串字符串</li>
</ol>
<pre><code class="language-js">// 字符串模板
let ss = `
            &lt;div&gt;
                &lt;span&gt;hello world&lt;span&gt;
            &lt;/div&gt;
        `
console.log(ss)
</code></pre>
<ol start="5">
<li>插入变量和表达式或方法：通过${}</li>
</ol>
<pre><code class="language-js">// 插值
function fun() {
    return &quot;这是一个函数&quot;;
}

let name = &quot;张三&quot;;
let age = 18;
let info = `我是${name}， 今年${age + 10}了，我想说${fun()}`;
console.log(info)
</code></pre>
<h3 id="3-函数">3 函数</h3>
<ol>
<li>默认参数</li>
</ol>
<pre><code class="language-js">//在 ES6 以前， 我们无法给一个函数参数设置默认值， 只能采用变通写法：
function add(a, b) {
    // 判断 b 是否为空， 为空就给默认值 1
    b = b || 1;
    return a + b;
} 
// 传一个参数
console.log(add(10));

//现在可以这么写： 直接给参数写上默认值， 没传就会自动使用默认值
function add2(a, b = 1) {
    return a + b;
} 
// 传一个参数
console.log(add2(10));
</code></pre>
<ol start="2">
<li>支持不定参数</li>
</ol>
<pre><code class="language-js">// 不定参数
function fun(...values) {
    console.log(values.length)
} 
fun(1, 2) //2
fun(1, 2, 3, 4) //4
</code></pre>
<ol start="3">
<li>箭头函数</li>
</ol>
<pre><code class="language-js">// 箭头函数
//以前声明一个方法
// var print = function (obj) {
// console.log(obj);
// }
// 可以简写为：
var print = obj =&gt; console.log(obj);
// 测试调用
print(&quot;hello&quot;);
</code></pre>
<p>一个比较复杂的场景：和lambda十分相近</p>
<pre><code class="language-js">var sum2 = (a,b) =&gt; {
    c = a + b;
    return a + c;
}
console.log(sum2(2, 4));
</code></pre>
<p>实战</p>
<pre><code class="language-js">//需求， 声明一个对象， hello 方法需要对象的个别属性
//以前的方式：
const person = {
    name: &quot;jack&quot;,
    age: 21,
    language: ['java', 'js', 'css']
} 

function hello(person) {
    console.log(&quot;hello,&quot; + person.name)
} 

// 现在的方式: 箭头函数+对象解构！
var hello2 = ({ name }) =&gt; { console.log(&quot;hello,&quot; + name) };
//测试
hello2(person);
</code></pre>
<h3 id="4-对象">4 对象</h3>
<ol>
<li>keys, values, entries 获取对象属性</li>
</ol>
<pre><code class="language-js">const person = {
    name: &quot;jack&quot;,
    age: 21,
    language: ['java', 'js', 'css']
}
console.log(Object.keys(person));//[&quot;name&quot;, &quot;age&quot;, &quot;language&quot;]
console.log(Object.values(person));//[&quot;jack&quot;, 21, Array(3)]
console.log(Object.entries(person));//[Array(2), Array(2), Array(2)]
</code></pre>
<ol start="2">
<li>assign 复制</li>
</ol>
<pre><code class="language-js">const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
//Object.assign 方法的第一个参数是目标对象， 后面的参数都是源对象。
Object.assign(target, source1, source2);
console.log(target)//{a: 1, b: 2, c: 3}
</code></pre>
<ol start="3">
<li>简写声明变量</li>
</ol>
<pre><code class="language-js">// 简写声明对象
const age = 23
const name = &quot;张三&quot;
// 传统
const person1 = { age: age, name: name }
console.log(person1)
// ES6： 属性名和属性值变量名一样， 可以省略
const person2 = { age, name }
console.log(person2) //{age: 23, name: &quot;张三&quot;}
</code></pre>
<ol start="4">
<li>对象的函数的简写</li>
</ol>
<pre><code class="language-js">// 对象的函数属性简写
let person = {
    name: &quot;jack&quot;,
    // 以前：
    eat: function (food) {
        console.log(this.name + &quot;在吃&quot; + food);
    },
    // 箭头函数版： 这里拿不到 this
    eat2: food =&gt; console.log(person.name + &quot;在吃&quot; + food),
    // 简写版：
    eat3(food) {
        console.log(this.name + &quot;在吃&quot; + food);
    }
} 
person.eat(&quot;apple&quot;);
person.eat(&quot;banana&quot;);
person.eat(&quot;orange&quot;);
</code></pre>
<ol start="5">
<li>对象扩展运算符<br>
使用...表示取出参数所有可遍历的属性拷贝到当前对象中</li>
</ol>
<pre><code class="language-js">// 1、 拷贝对象（深拷贝）
let p1 = { name: &quot;Amy&quot;, age: 15 }
let someone = { ...p1 }
console.log(someone) //{name: &quot;Amy&quot;, age: 15}

// 2、 合并对象
let age1 = { age: 15 }
let name1 = { name: &quot;Amy&quot; }
let person2 = { ...age1, ...name1 } //如果两个对象的字段名重复， 后面对象字段值会覆盖前面对象的字段值
console.log(person2) //{age: 15, name: &quot;Amy&quot;}
</code></pre>
<h3 id="5-map与reduce">5 map与reduce</h3>
<ol>
<li>map()<br>
和 java8的stream流特性很像，接收一个函数，将数组的每个元素用这个函数处理后返回一个新的结果数组，实例如下</li>
</ol>
<pre><code class="language-js">let arr = ['1','20','-5','3'];
arr = arr.map((item) =&gt; {
    return item * 2;
})
console.log(arr);
</code></pre>
<ol start="2">
<li>
<p>reduce()<br>
为数组中每一个的元素执行回调函数，但是不包括数组中被删除或从未被赋值的元素， 接受四个参数： 初始值（或者上一次回调函数的返回值） ， 前元素值， 当前索引， 调用 reduce 的数组。<br>
callback （执行数组中每个值的函数， 包含四个参数）</p>
<ul>
<li>previousValue （上一次调用回调返回的值， 或者是提供的初始值（initialValue） ）</li>
<li>currentValue （数组中当前被处理的元素）</li>
<li>index （当前元素在数组中的索引）</li>
<li>array （调用 reduce 的数组）</li>
</ul>
<p>initialValue （作为第一次调用 callback 的第一个参数。 ）</p>
</li>
</ol>
<pre><code class="language-js">let arr = ['1','20','-5','3'];
arr = arr.map(item =&gt; item * 2)
console.log(arr);

// 求和
let result = arr.reduce((a, b)=&gt;{
    console.log(&quot;上次处理后的值：&quot; + a);
    console.log(&quot;当前值：&quot; + b);
    return a + b;
});
console.log(result);
</code></pre>
<p>可以设置初始值，设为100：</p>
<pre><code class="language-js">let result = arr.reduce((a, b)=&gt;{
    console.log(&quot;上次处理后的值：&quot; + a);
    console.log(&quot;当前值：&quot; + b);
    return a + b;
},100);
</code></pre>
<h3 id="6-promise-异步操作">6 Promise 异步操作</h3>
<p>如果在一个异步操作的场景中有如下代码</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script&gt;src = &quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;script&gt;
        $.ajax({
            url: &quot;mock/user.json&quot;,
            success(data) {
                console.log(&quot;查询用户： &quot;, data);
                $.ajax({
                    url: `mock/user_course_${data.id}.json`,
                    success(data) {
                        console.log(&quot;查询到课程： &quot;, data);
                        $.ajax({
                            url: `mock/course_score_${data.id}.json`,
                            success(data) {
                                console.log(&quot;查询到分数： &quot;, data);
                            },
                            error(error) {
                                console.log(&quot;出现异常了： &quot; + error);
                            }
                        });
                    },
                    error(error) {
                        console.log(&quot;出现异常了： &quot; + error);
                    }
                });
            },
            error(error) {
                console.log(&quot;出现异常了： &quot; + error);
            }
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>在mock文件夹下有如下三个json文件</p>
<pre><code class="language-json">// user.json
{
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;zhangsan&quot;,
    &quot;password&quot;: &quot;123456&quot;
}

// user_coruse_1.json
{
    &quot;id&quot;: 10,
    &quot;name&quot;: &quot;chinese&quot;
}

// course_score_10.json
{
    &quot;id&quot;: 100,
    &quot;score&quot;: 90
}
</code></pre>
<p>案例： 用户登录， 并展示该用户的各科成绩。 在页面发送两次请求：</p>
<ol>
<li>查询用户， 查询成功说明可以登录</li>
<li>查询用户成功， 查询科目</li>
<li>根据科目的查询结果， 获取去成绩<br>
这样层层嵌套就十分复杂！</li>
</ol>
<h4 id="使用promise的回调1">使用Promise的回调1</h4>
<pre><code class="language-js">let p = new Promise((resolve, reject) =&gt; {
    $.ajax({
        url: &quot;mock/user.json&quot;,
        success: function (data) {
            console.log(&quot;查询用户成功：&quot;, data)
            resolve(data);
        },
        error: function (err) {
            reject(err);
        }
    });
});

p.then((obj) =&gt; {
    return new Promise((resolve, reject) =&gt; {
        $.ajax({
            url: `mock/user_course_${obj.id}.json`,
            success: function (data) {
                console.log(&quot;查询用户课程成功:&quot;, data)
                resolve(data);
            },
            error: function (err) {
                reject(err);
            }
        });
    });
}).then((data) =&gt; {
    $.ajax({
        url: `mock/course_score_${data.id}.json`,
        success: function (data) {
            console.log(&quot;查询课程得分成功:&quot;, data)
        },
        error: function (err) {
        }
    });
})
</code></pre>
<h4 id="使用promise的回调2">使用Promise的回调2</h4>
<pre><code class="language-js">function get(url, data) {
    return new Promise((resolve, reject) =&gt; {
        $.ajax({
            url: url,
            data: data,
            success: function (data) {
                resolve(data);
            },
            error: function (err) {
                reject(err);
            }
        })
    });
}

get(&quot;mock/user.json&quot;)
    .then((data) =&gt; {
        console.log(&quot;用户查询成功: &quot;, data);
        return get(`mock/user_course_${data.id}.json`);
    })
    .then((data) =&gt; {
        console.log(&quot;课程查询成功: &quot;, data);
        return get(`mock/course_score_${data.id}.json`);
    })
    .then((data) =&gt; {
        console.log(&quot;成绩查询成功: &quot;, data);
    })
    .catch((err) =&gt; {
        console.log(&quot;出现异常: &quot;, err)
    });
</code></pre>
<h3 id="7-模块化">7 模块化</h3>
<p>模块化就是把代码进行拆分， 方便重复利用。 类似 java 中的导包： 要使用一个包， 必须先导包。 而 JS 中没有包的概念， 换来的是<strong>模块</strong>。使用import和export命令</p>
<pre><code class="language-js">var name = &quot;jack&quot;
var age = 21
function add(a, b) {
    return a + b;
}
export {name,age,add}
/***********************/
import abc from &quot;./hello.js&quot;
import {name, age, add} from &quot;./user&quot;

abc.sum(1, 2);
console.log(name);
add(1,3);
</code></pre>
<h2 id="vue">Vue</h2>
<h3 id="mvvm思想">MVVM思想</h3>
<ul>
<li>M： 即 Model， 模型， 包括数据和一些基本操作</li>
<li>V： 即 View， 视图， 页面渲染结果</li>
<li>VM： 即 View-Model， 模型与视图间的双向操作（无需开发人员干涉）<br>
<img src="https://dxone1.github.io//post-images/1636009915747.png" alt="" loading="lazy"></li>
</ul>
<h3 id="相关信息">相关信息</h3>
<p>官网： https://cn.vuejs.org/<br>
参考： https://cn.vuejs.org/v2/guide/<br>
Git 地址： https://github.com/vuejs</p>
<h3 id="学习">学习</h3>
<p>在vscode中使用npm管理工具导入Vue</p>
<ol>
<li><code>npm init -y</code> 初始化项目、</li>
<li><code>npm install vue</code>安装vue</li>
<li>html中使用</li>
</ol>
<pre><code class="language-html">&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>引入vue.js<br>
<strong>测试样例：</strong></p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;!-- {{}}是Vue提供的插值占位符 --&gt;
    &lt;h1&gt; {{name}},非常帅&lt;/h1&gt;
&lt;/div&gt;

&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    let vm = new Vue({
        // el接管div,通过id选择
        el: &quot;#app&quot;,
        // data可能有许多数据
        data: {
            name: &quot;张三&quot;,
        }
    });
&lt;/script&gt;
</code></pre>
<p>在浏览器控制台可以更改name属性，实时更新<br>
效果：<br>
<img src="https://dxone1.github.io//post-images/1636010691042.png" alt="" loading="lazy"></p>
<h3 id="vue基本语法与插件">Vue基本语法与插件</h3>
<ol>
<li>双向绑定<br>
模型变化会导致视图的变化，视图变化也会引起模型变化</li>
</ol>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;!-- {{}}是Vue提供的插值占位符, 实现双向绑定 --&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt;
    &lt;!-- 点赞实时增加 --&gt;
    &lt;button v-on:click=&quot;num++&quot;&gt;点赞&lt;/button&gt;
    &lt;button v-on:click=&quot;cancle&quot;&gt;取消点赞&lt;/button&gt;
    &lt;h1&gt; {{name}},非常帅，有{{num}}个人为他点赞&lt;/h1&gt;
&lt;/div&gt;

&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    let vm = new Vue({
        // el绑定元素
        el: &quot;#app&quot;,
        // data封装数据
        data: {
            name: &quot;张三&quot;,
            num: 1
        },
        // method封装函数
        methods: {
            cancle() {
                this.num--;
            }
        }
    });
&lt;/script&gt;
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1636011475076.png" alt="" loading="lazy"><br>
v-xx：指令，可以简单的进行dom的操作！<br>
插件安装Vetur和Vue 2 Snippets，方便Vue的语法提示等功能</p>
<h3 id="指令">指令</h3>
<ol>
<li>{{}}插值表达式</li>
</ol>
<ul>
<li>该表达式支持 JS 语法， 可以调用 js 内置函数（必须有返回值</li>
<li>表达式必须有返回结果。 例如 1 + 1， 没有结果的表达式不允许使用， 如： let a = 1 + 1;</li>
<li>可以直接获取 Vue 实例中定义的数据或函数</li>
</ul>
<ol start="2">
<li>v-html和v-text</li>
</ol>
<ul>
<li>v-text： 将数据输出到元素内部， 如果输出的数据有 HTML 代码， 会作为普通文本输出</li>
<li>v-html： 将数据输出到元素内部， 如果输出的数据有 HTML 代码， 会被渲染</li>
</ul>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    {{msg}} &lt;br/&gt;
    &lt;!-- 使用v-html和v-txt不会出现插值闪烁的现象 --&gt;
    &lt;!-- 以html形式展现，可以显示出H1样式 --&gt;
    &lt;span v-html=&quot;msg&quot;&gt;&lt;/span&gt;&lt;br/&gt;
    &lt;!-- 展示原先的样式，不会显示大标题 --&gt;
    &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;&lt;br/&gt;    
&lt;/div&gt;
</code></pre>
<ol start="3">
<li>v-bind<br>
html 属性不能使用双大括号形式绑定， 我们使用 v-bind 指令给 HTML 标签属性绑定值；而且在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时， Vue.js 做了专门的增强</li>
</ol>
<pre><code class="language-html">&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;a v-bind:href=&quot;link&quot;&gt;gogogo&lt;/a&gt;
    &lt;!-- 只有对应的属性为true才添加class --&gt;
    &lt;!-- style动态绑定 --&gt;
    &lt;span v-bind:class=&quot;{active:isActive,'text-danger':hasError}&quot; 
        v-bind:style=&quot;{color: color1, 'fontSize': size}&quot;&gt;你好&lt;/span&gt;
&lt;/div&gt;

&lt;script&gt;
    let vm = new Vue({
        el: &quot;#app&quot;,
        data: {
            link: &quot;https://www.baidu.com&quot;,
            isActive: true,
            hasError: true,
            color1: 'red',
            size: '36px'
        }
    });
&lt;/script&gt;
</code></pre>
<p><strong>以上均为单向绑定。</strong><br>
4. v-model 双向绑定</p>
<pre><code class="language-html">&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 
&lt;!-- 一般用于表单项 --&gt;
&lt;div id=&quot;app&quot;&gt;
    精通的语言:
        &lt;!-- 通过v-model双向绑定到Vue中 --&gt;
        &lt;input type=&quot;checkbox&quot; v-model=&quot;language&quot; value=&quot;Java&quot;&gt;Java&lt;br/&gt;
        &lt;input type=&quot;checkbox&quot; v-model=&quot;language&quot; value=&quot;PHP&quot;&gt;PHP&lt;br/&gt;
        &lt;input type=&quot;checkbox&quot; v-model=&quot;language&quot; value=&quot;Python&quot;&gt;Python&lt;br/&gt;
    选中了 {{language.join(&quot;,&quot;)}}
&lt;/div&gt;

&lt;script&gt;
    let vm = new Vue({
        el: &quot;#app&quot;,
        data: {
            language: []
        }
    })
&lt;/script&gt;
</code></pre>
<ol start="5">
<li>v-on配合修饰符实现功能</li>
</ol>
<ul>
<li>事件修饰符
<ul>
<li><code>.stop</code> ： 阻止事件冒泡到父元素</li>
<li><code>.prevent</code>： 阻止默认事件发生</li>
<li><code>.capture</code>： 使用事件捕获模式</li>
<li><code>.self</code>： 只有元素自身触发事件才执行。 （冒泡或捕获的都不执行）</li>
<li><code>.once</code>： 只执行一次</li>
</ul>
</li>
<li>按键修饰符
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
</li>
<li>组合按钮
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
</ul>
</li>
</ul>
<pre><code class="language-html">&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;app&quot;&gt;
   &lt;button v-on:click=&quot;num++&quot;&gt;点赞&lt;/button&gt;
   &lt;button @click=&quot;cancel&quot;&gt;取消&lt;/button&gt;
   &lt;h1&gt;有{{num}}个赞&lt;/h1&gt;
   &lt;!-- 阻止事件冒泡 --&gt;
   &lt;div style=&quot;border: 1px solid red;padding: 20px;&quot; @click.once=&quot;hello&quot;&gt;
       &lt;div style=&quot;border: 1px solid blue;padding: 20px;&quot; @click.stop=&quot;hello&quot;&gt;
           &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.stop=&quot;hello&quot;&gt;去百度&lt;/a&gt;
       &lt;/div&gt;
   &lt;/div&gt;

   &lt;!-- 按键修饰符 --&gt;
   &lt;!-- 上键加2，下键减2，单击鼠标+ctrl变成10 --&gt;
   &lt;input type=&quot;text&quot; v-model=&quot;num&quot; v-on:keyup.up=&quot;num+=2&quot; @keyup.down=&quot;num-=2&quot;
           @click.ctrl=&quot;num=10&quot;&gt;&lt;br/&gt;        
&lt;/div&gt;

&lt;script&gt;
   let vm = new Vue({
       el: &quot;#app&quot;,
       data: {
           num: 0
       },
       methods: {
           cancel() {
               this.num--;
           },
           hello() {
               alert(&quot;点击了&quot;)
           }
       }
   })
&lt;/script&gt;
</code></pre>
<ol start="6">
<li>v-for 遍历显示<br>
三种语法：</li>
</ol>
<ul>
<li><code>v-for=&quot;item in items&quot;</code></li>
<li><code>v-for=&quot;(item,index) in items&quot;</code></li>
<li>(v,k)
<ul>
<li><code>v-for=&quot;value in object&quot;</code></li>
<li><code>v-for=&quot;(value,key) in object&quot;</code></li>
<li><code>v-for=&quot;(value,key,index) in object&quot;</code></li>
</ul>
</li>
</ul>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;ul&gt;
        &lt;!-- v-for 元素遍历 --&gt;
        &lt;li v-for=&quot;user in users&quot;&gt;
            {{user.name}} - {{user.gender}} - {{user.age}}
        &lt;/li&gt;
        &lt;!-- v-for 序号遍历 --&gt;
        &lt;li v-for=&quot;(user, index) in users&quot;&gt;
            {{index + 1}} - {{user.name}} - {{user.gender}} - {{user.age}}&lt;br&gt;

            对象信息:
            &lt;span v-for=&quot;(v,k,i) in user&quot;&gt;
                {{k}} == {{v}} == {{i}}&lt;br&gt;
            &lt;/span&gt;
        &lt;/li&gt;          
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    let app = new Vue({
        el: &quot;#app&quot;,
        data: {
            users: [
                { name: '柳岩', gender: '女', age: 21 },
                { name: '张三', gender: '男', age: 18 },
                { name: '范冰冰', gender: '女', age: 24 },
                { name: '刘亦菲', gender: '女', age: 18 },
                { name: '古力娜扎', gender: '女', age: 25 }
            ]
        },
    })
&lt;/script&gt;
</code></pre>
<p>使用<code>:key</code>唯一标识</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li v-for=&quot;(item,index) in items&quot; :key=”index”&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<ol start="7">
<li>v-if 和 v-show<br>
v-if，顾名思义，条件判断。当得到结果为 true 时，所在的元素才会被渲染。<br>
v-show，当得到结果为 true 时，所在的元素才会被显示。使用display:none隐藏<br>
语法： <code>v-if=&quot;布尔表达式&quot;</code>, <code>v-show=&quot;布尔表达式&quot;</code>,</li>
</ol>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;button v-on:click=&quot;show = !show&quot;&gt;点我呀&lt;/button&gt;
    &lt;br&gt;
    &lt;h1 v-if=&quot;show&quot;&gt;
        看到我啦？ ！
    &lt;/h1&gt;
    &lt;h1 v-show=&quot;show&quot;&gt;
        看到我啦？ ！ show
    &lt;/h1&gt;
&lt;/div&gt;
&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    let app = new Vue({
        el: &quot;#app&quot;,
        data: {
            show: true
        }
    })
&lt;/script&gt;
</code></pre>
<ol start="8">
<li>v-else和v-else-if</li>
</ol>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;button v-on:click=&quot;random=Math.random()&quot;&gt;点我呀
    &lt;/button&gt;&lt;span&gt;{{random}}&lt;/span&gt;
    &lt;h1 v-if=&quot;random &gt;= 0.75&quot;&gt;
        看到我啦？ ！ v-if &gt;= 0.75
    &lt;/h1&gt;
    &lt;h1 v-else-if=&quot;random &gt; 0.5&quot;&gt;
        看到我啦？ ！ v-else-if &gt; 0.5
    &lt;/h1&gt;
    &lt;h1 v-else-if=&quot;random &gt; 0.25&quot;&gt;
        看到我啦？ ！ v-else-if &gt; 0.25
    &lt;/h1&gt;
    &lt;h1 v-else&gt;
        看到我啦？ ！ v-else
    &lt;/h1&gt;
&lt;/div&gt;
&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    let app = new Vue({
        el: &quot;#app&quot;,
        data: {
            random: 1
        }
    })
&lt;/script&gt;
</code></pre>
<h3 id="计算属性和侦听器">计算属性和侦听器</h3>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;ul&gt;
        &lt;li&gt;西游记： 价格{{xyjPrice}}， 数量：
            &lt;input type=&quot;number&quot; v-model=&quot;xyjNum&quot;&gt;
        &lt;/li&gt;
        &lt;li&gt;水浒传： 价格{{shzPrice}}， 数量：
            &lt;input type=&quot;number&quot; v-model=&quot;shzNum&quot;&gt;
        &lt;/li&gt;
        &lt;li&gt;总价： {{totalPrice}}&lt;/li&gt;
        {{msg}}
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    let app = new Vue({
        el: &quot;#app&quot;,
        data: {
            xyjPrice: 56.73,
            shzPrice: 47.98,
            xyjNum: 1,
            shzNum: 1,
            msg: &quot;&quot;
        },
        // 计算属性
        computed: {
            totalPrice() {
                return this.xyjPrice * this.xyjNum + this.shzPrice * this.shzNum;
            }
        },
        // 监听器
        watch: {
            xyjNum: function(newVal, oldVal) {
                if(newVal &gt;= 3) {
                    this.msg = &quot;库存超出限制&quot;;
                    this.xyjNum = 3;
                } else {
                    this.msg = &quot;&quot;;
                }
            }
        }
    })
&lt;/script&gt;
</code></pre>
<h3 id="过滤器">过滤器</h3>
<p>过滤器不改变真正的<code>data</code>， 而只是改变渲染的结果， 并返回过滤后的版本。 在很多不同的情况下， 过滤器都是有用的， 比如尽可能保持 API 响应的干净， 并在前端处理数据的格式。</p>
<ol>
<li>局部过滤</li>
</ol>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;table&gt;
        &lt;tr v-for=&quot;user in userList&quot;&gt;
            &lt;td&gt;{{user.id}}&lt;/td&gt;
            &lt;td&gt;{{user.name}}&lt;/td&gt;
            &lt;!-- 使用代码块实现， 有代码侵入 --&gt;
            &lt;!-- &lt;td&gt;{{user.gender===1? &quot;男&quot;:&quot;女&quot;}}&lt;/td&gt; --&gt;
            &lt;!-- 使用过滤器 --&gt;
            &lt;td&gt;{{user.gender | genderFilter}}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/div&gt;

&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    let app = new Vue({
        el: &quot;#app&quot;,
        data: {
            userList: [
                { id: 1, name: 'jacky', gender: 1 },
                { id: 2, name: 'peter', gender: 0 }
            ]
        },
        // 过滤器
        filters: {
            genderFilter(val) {
                if(val == 1) {
                    return &quot;男&quot;;
                } else {
                    return &quot;女&quot;;
                }
            }
        } 
    });
&lt;/script&gt;
</code></pre>
<ol start="2">
<li>全局过滤器</li>
</ol>
<pre><code class="language-html">&lt;script&gt;
    Vue.filter(&quot;gFilter&quot;, function (val) {
        if (val == 1) {
            return &quot;男!&quot;;
        } else {
            return &quot;女!&quot;;
        }
    })
&lt;/script&gt;
</code></pre>
<h3 id="vue组件化">Vue组件化</h3>
<p>在大型应用开发的时候， 页面可以划分成很多部分。 往往不同的页面， 也会有相同的部分。例如可能会有相同的头部导航。但是如果每个页面都独自开发， 这无疑增加了我们开发的成本。 所以我们会把页面的不同部分拆分成独立的组件， 然后在不同页面就可以共享这些组件， 避免重复开发。在 vue 里， 所有的 vue 实例都是组件</p>
<ul>
<li>组件其实也是一个 Vue 实例， 因此它在定义时也会接收： data、 methods、 生命周期函数等</li>
<li>不同的是组件不会与页面的元素绑定， 否则就无法复用了， 因此没有el 属性。</li>
<li>但是组件渲染需要 html 模板， 所以增加了 template 属性， 值就是 HTML 模板</li>
<li>全局组件定义完毕， 任何 vue 实例都可以直接在 HTML 中通过组件名称来使用组件了</li>
<li>data 必须是一个函数， 不再是一个对象。否则返回的都是一个对象</li>
</ul>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;count++&quot;&gt;我被点击了{{count}}次&lt;/button&gt;
    &lt;!-- 使用全局组件，都是独立的副本！ --&gt;
    &lt;counter&gt;&lt;/counter&gt;
    &lt;counter&gt;&lt;/counter&gt;
    &lt;counter&gt;&lt;/counter&gt;
    &lt;!-- 使用局部组件 --&gt;
    &lt;button-counter&gt;&lt;/button-counter&gt;
    &lt;button-counter&gt;&lt;/button-counter&gt;
    &lt;button-counter&gt;&lt;/button-counter&gt;
&lt;/div&gt;
&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    // 全局组件
    Vue.component(&quot;counter&quot;, {
        template: `&lt;button @click=&quot;count++&quot;&gt;我被点击了{{count}}次&lt;/button&gt;`,
        // 返回的是一个新的对象，所以以此为模板创建的都是独立的副本
        data() {
            return {
                count: 1
            }
        }
    });

    // 局部定义一个组件
    const buttonCounter = {
        template: `&lt;button @click=&quot;count++&quot;&gt;我被点击了{{count}}次&lt;/button&gt;`,
        // 返回的是一个新的对象，所以以此为模板创建的都是独立的副本
        data() {
            return {
                count: 1
            }
        }
    };

    let vm = new Vue({
        el: &quot;#app&quot;,
        data: {
            count: 1
        },
        // 声明局部一个组件
        components: {
            &quot;button-counter&quot;: buttonCounter
        }
    })
&lt;/script&gt;
</code></pre>
<h3 id="生命周期和钩子函数">生命周期和钩子函数</h3>
<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程 ： 创建实例， 装载模板， 渲染模板等等。 Vue 为生命周期中的每个状态都设置了钩子函数（监听函数） 。 每当 Vue 实例处于不同的生命周期时， 对应的函数就会被触发调用。<br>
<img src="https://dxone1.github.io//post-images/1636020701181.png" alt="" loading="lazy"></p>
<h3 id="vue的模块化开发">Vue的模块化开发</h3>
<p>1、 npm install webpack -g<br>
全局安装 webpack<br>
2、 npm install -g @vue/cli-init<br>
全局安装 vue 脚手架<br>
3、 初始化 vue 项目；<br>
vue init webpack appname： vue 脚手架使用 webpack 模板初始化一个 appname 项目<br>
4、 启动 vue 项目；<br>
项目的 package.json 中有 scripts， 代表我们能运行的命令<br>
- npm start = npm run dev： 启动项目<br>
- npm run build： 将项目打包</p>
<h3 id="vue整合elementui">Vue整合ElementUI</h3>
<p>1、 安装 element-ui: npm i element-ui<br>
2、 在 main.js 中引入 element-ui 就可以全局使用了。</p>
<pre><code class="language-js">import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'
Vue.use(ElementUI)
</code></pre>
<p>3、 将 App.vue 改为 element-ui 中的后台布局<br>
4、 添加测试路由、 组件， 测试跳转逻辑<br>
(1) 、 参照文档 el-menu 添加 router 属性<br>
(2) 、 参照文档 el-menu-item 指定 index 需要跳转的地址</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day2：分布式组件构建]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day3fen-bu-shi-zu-jian-gou-jian/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day3fen-bu-shi-zu-jian-gou-jian/">
        </link>
        <updated>2021-11-03T08:38:38.000Z</updated>
        <content type="html"><![CDATA[<p>之前已经学习过SpringCloud部分的组件并实际使用过。这次使用springcloud alibaba的组件完成如下功能</p>
<pre><code class="language-txt">nacos: 服务注册、发现和配置中心功能
ribbon, openfeign：服务远程调用和负载均衡
gateway：服务网关
sentinel：限流、降级和熔断保护
sleuth：调用链监控
seata：分布式事务
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1635929017334.png" alt="" loading="lazy"><br>
先统一版本，因为使用的是springboot 2.1.8.RELEASE，故采用SpringCloud Alibaba 2.1.0.RELEASE版本<br>
首先在项目的mall-common中引入依赖</p>
<pre><code class="language-xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<p>将其管理起来：<strong>没有引入</strong></p>
<h2 id="1-nacos注册中心">1 Nacos注册中心</h2>
<ol>
<li>所有微服务都需要nacos，所以在mall-common引入nacos的服务发现依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>在所有需要nacos服务注册的项目中配置，并设置name</li>
</ol>
<pre><code class="language-yaml">spring:
    cloud:
        nacos:
            discovery:
                server-addr: 127.0.0.1:8848
    application: 
        name: mall-coupon
</code></pre>
<ol start="3">
<li>使用<code>@EnableDiscoveryClient</code>注解即可开启发现功能</li>
<li>启动nacos，在windows下测试。本机已经配置好nacos的持久化设置，使用如下命令即可启动</li>
</ol>
<pre><code class="language-shell">D:\backup\document\installer\nacos-server-2.0.3\nacos\bin&gt;startup.cmd -m standalone
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dxone1.github.io//post-images/1635931291828.png" alt="" loading="lazy"></figure>
<p><strong>一个小细节</strong><br>
在2021版本的idea中不默认开启service工具，在view -&gt; Tool windows中开启。通过小+号打开Run Configuration Type选择Springboot即可<br>
<img src="https://dxone1.github.io//post-images/1635931972133.png" alt="" loading="lazy"></p>
<h2 id="2-openfeign进行远程调用">2 OpenFeign进行远程调用</h2>
<p>第一步仍然是引入依赖，不同的是这个项目使用Spring Initializer生成时使用了feign场景。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt; &lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>在nall-coupon中添加一个调用controller方法</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;coupon/coupon&quot;)
public class CouponController {
    @Autowired
    private CouponService couponService;

    @RequestMapping(&quot;/member/list&quot;)
    public R membercoupons() {
        CouponEntity couponEntity = new CouponEntity();
        couponEntity.setCouponName(&quot;满100减10&quot;);
        return R.ok().put(&quot;coupons&quot;, Arrays.asList(couponEntity));
    }
    ......
}
</code></pre>
<ol start="3">
<li>写一个用于远程调用的接口：FeignClient，标注被调用的完整controller和服务名称</li>
</ol>
<pre><code class="language-java">// com.dong.mall.member.feign.CouponFeignService
package com.dong.mall.coupon.feign;

import com.dong.common.utils.R;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.RequestMapping;

@FeignClient(&quot;mall-coupon&quot;)
public interface CouponFeignService {
    @RequestMapping(&quot;/coupon/coupon/member/list&quot;)
    public R membercoupons();
}
</code></pre>
<ol start="4">
<li>在调用发起方主启动类使用@EnableFeignClients(basePackages = &quot;com.dong.mall.member.feign&quot;)开启远程调用功能</li>
<li>在调用发起方mall-member中写一个调用测试方法</li>
</ol>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;member/member&quot;)
public class MemberController {
    @Autowired
    private MemberService memberService;
    // 远程调用接口
    @Autowired
    CouponFeignService couponFeignService;

    @RequestMapping(&quot;/coupons&quot;)
    public R test() {
        MemberEntity memberEntity = new MemberEntity();
        memberEntity.setNickname(&quot;张三&quot;);
        R membercoupons = couponFeignService.membercoupons();
        return R.ok().put(&quot;member&quot;, memberEntity).put(&quot;coupons&quot;, membercoupons.get(&quot;coupons&quot;));
    }
    ......
}
</code></pre>
<p>测试<br>
<img src="https://dxone1.github.io//post-images/1635937631422.png" alt="" loading="lazy"></p>
<h2 id="3-使用nacos做配置中心">3 使用Nacos做配置中心</h2>
<ol>
<li>在mall-common中引入配置中心依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>在需要管理配置的项目中编写bootstrap.properties文件，该文件会早于application.yml/application.properties生效</li>
</ol>
<pre><code class="language-txt">spring.application.name=mall-coupon
# 配置中心的地址
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
</code></pre>
<ol start="3">
<li>在control上添加一个注解 @RefreshScope</li>
<li>尝试使用nacos的配置中心功能。已经开启了持久化功能。配置文件名为mall-coupon.properties</li>
<li>测试</li>
</ol>
<pre><code class="language-java">@RefreshScope
@RestController
@RequestMapping(&quot;coupon/coupon&quot;)
public class CouponController {
    @Autowired
    private CouponService couponService;

    // 从配置中获取
    @Value(&quot;${coupon.user.name}&quot;)
    private String name;
    @Value(&quot;${coupon.user.age}&quot;)
    private String age;

    @RequestMapping(&quot;/test&quot;)
    public R test() {
        return R.ok().put(&quot;name&quot;, name).put(&quot;age&quot;, age);
    }
    ......
}
</code></pre>
<p><strong>会优先使用配置中心的配置</strong></p>
<h3 id="高级主题分组">高级主题：分组</h3>
<ol>
<li>默认命名空间为public，用于环境配置隔离<br>
开发、测试、生产...<br>
<img src="https://dxone1.github.io//post-images/1635939434661.png" alt="" loading="lazy"><br>
如何切换namespce?</li>
</ol>
<pre><code class="language-txt">spring.cloud.nacos.config.namespace=cb2b23c4-62ab-41e0-a131-70ae4b2c2772
</code></pre>
<p>上面的是对应的命名空间的ID，在nacos图形界面里显示<br>
也可以每个微服务之间互相隔离，建立不同的命名空间<br>
2. 配置集：配置集的集合<br>
3. 配置集id：类似于配置文件名， Data id<br>
4. 配置分组：默认属于DEFAULT_GROUP<br>
<img src="https://dxone1.github.io//post-images/1635939995992.png" alt="" loading="lazy"><br>
使用切换分组</p>
<pre><code class="language-txt">spring.cloud.nacos.config.group=1111
</code></pre>
<p><strong>本项目的约定</strong><br>
每个微服务设置一个命名空间，使用配置分组区分环境 dev, test, prod</p>
<h3 id="高级主题加载多配置集">高级主题：加载多配置集</h3>
<p>例子：</p>
<ol>
<li>将mall-coupons项目的配置拆分并托管给nacos</li>
</ol>
<pre><code class="language-yaml"># datasource.yaml
spring:
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.180.3:3306/mall_sms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
    driver-class-name: com.mysql.cj.jdbc.Driver
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1635940659201.png" alt="" loading="lazy"><br>
2. 在bootstrap.properties中配置多配置集</p>
<pre><code class="language-txt">spring.application.name=mall-coupon
# 配置中心的地址
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.namespace=527f3748-b8fe-44bb-8e4f-bf22371a0adc
spring.cloud.nacos.config.group=dev

# 配置集
# id
spring.cloud.nacos.config.ext-config[0].data-id=datasource.yaml
# 分组
spring.cloud.nacos.config.ext-config[0].group=dev
# 是否动态刷新
spring.cloud.nacos.config.ext-config[0].refresh=true

spring.cloud.nacos.config.ext-config[1].data-id=mybatis.yaml
spring.cloud.nacos.config.ext-config[1].group=dev
spring.cloud.nacos.config.ext-config[1].refresh=true

spring.cloud.nacos.config.ext-config[2].data-id=other.yaml
spring.cloud.nacos.config.ext-config[2].group=dev
spring.cloud.nacos.config.ext-config[2].refresh=true
</code></pre>
<h2 id="4-gateway服务网关">4 Gateway服务网关</h2>
<p>作用：鉴权、限流、日志<br>
<img src="https://dxone1.github.io//post-images/1635943097682.png" alt="" loading="lazy"><br>
关键词：路由、断言、过滤器<br>
<img src="https://dxone1.github.io//post-images/1635943846901.png" alt="" loading="lazy"><br>
创建一个项目，作为整体的api网关mall-gateway</p>
<ol>
<li>创建项目，生成时选择Gateway</li>
<li>修改pom文件，统一版本并引入mall-common</li>
<li>开启服务发现 @EnableDiscoveryClient</li>
<li>写application.properties，配置nacos的相关地址，服务发现和注册中心。网关设置为88端口</li>
</ol>
<pre><code class="language-yaml"># bootstrap.yml
spring:
  application:
    name: mall-gateway
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848
        namespace: 99df8f0b-1740-4545-b75e-108da1f752ff
        group: dev
</code></pre>
<pre><code class="language-txt"># application.properties
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
spring.application.name=mall-gateway
server.port=88
</code></pre>
<p>配置gateway的规则</p>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      routes:
        - id: baidu_route
          uri: https://www.baidu.com
          # 断言含有百度
          predicates:
            - Query=url,baidu
        - id: qq_route
          uri: https://www.qq.com
          predicates:
            - Query=url,qq
</code></pre>
<p>如果访问https://localhost:88/hello?url=baidu 会跳到www.baidu.com/hello</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day1：使用开源项目快速搭建]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day1/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day1/">
        </link>
        <updated>2021-11-02T02:35:33.000Z</updated>
        <content type="html"><![CDATA[<p>为了解决开发的繁重，使用gitee开源的人人开源脚手架工程快速搭建前后分离的项目工程。<br>
renren-fast: https://gitee.com/renrenio/renren-fast<br>
renren-fast-vue：https://gitee.com/renrenio/renren-fast-vue.git<br>
将renren-fast工程clone到本地导入项目，在父pom文件中定义这个模块即可。</p>
<h2 id="1-基于开源脚手架项目快速搭建">1 基于开源脚手架项目快速搭建</h2>
<h3 id="1-后台框架搭建">1 后台框架搭建</h3>
<p>将后端程序加入到项目文档中成为一个子模块。打开其中的建表命令，通过sqlyog连接centos中docker部署的数据库。执行建表指令，搭建起后台管理的后端框架。修改springboot的dev环境配置文件，将项目连接到数据库。项目启动成功如下图<br>
<img src="https://dxone1.github.io//post-images/1635837233452.png" alt="" loading="lazy"><br>
在浏览器中输入http://localhost:8080/renren-fast/ 即可进入raw后端项目，返回如下图（浏览器安装了json解析工具）<br>
<img src="https://dxone1.github.io//post-images/1635837314851.png" alt="" loading="lazy"></p>
<h3 id="2-前端框架搭建">2 前端框架搭建</h3>
<p>接下来进行前端工程。因为之前前端没有深入学习过，这里一边做一边学习。</p>
<ol>
<li>下载node.js环境并安装：版本10.16.3</li>
<li>配置npm使用淘宝镜像 npm config set registry http://registry.npm.taobao.org/</li>
<li>在vs code中打开renren-fast-vue项目，在控制台终端使用npm install命令下载项目需要的各种依赖：NPM 是随同 NodeJS 一起安装的包管理工具</li>
<li>在控制台输入 npm run dev即可开启前端项目。前端地址localhost:8001会将数据打到后端8080地址<br>
前端启动画面<br>
<img src="https://dxone1.github.io//post-images/1635838697500.png" alt="" loading="lazy"><br>
默认登陆账号为 admin admin</li>
</ol>
<h3 id="3-代码生成器">3 代码生成器</h3>
<p>gitee项目 https://gitee.com/renrenio/renren-generator.git<br>
将代码生成器放入后端项目目录中，添加为模块。将配置修改为对应的数据库和项目包。启动在80端口生成代码文档。<br>
将代码文档替换对应的微服务文档即可。注意需要引入许多新的公共依赖。在这里提取出一个公共项目mall-common。所有其他的微服务都依赖于这个模块，在其中的com.dong.common.utils等包中加入需要的类，在公共pom中添加需要的依赖。<br>
因为本项目使用了Mybatis-plus帮助快速开发，所以要按以下步骤进行：</p>
<ol>
<li>在公共项目mall-common中导入mybatis-plus的依赖</li>
<li>在yml文件中配置数据源、mybatis-plus信息等。注意和数据库版本匹配：5.7.36。使用8.0.26版本的数据库驱动即可</li>
<li>配置包扫描，在主启动类上用@Mapper注解指示Mapper接口路径</li>
</ol>
<pre><code class="language-java">@MapperScan(&quot;com.dong.mall.product.dao&quot;)
@SpringBootApplication
public class MallProductApplication {

    public static void main(String[] args) {
        SpringApplication.run(MallProductApplication.class, args);
    }

}
</code></pre>
<pre><code class="language-yaml"># application.yml配置的数据源和mybatis-plus
spring:
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.180.3:3306/mall_pms
    driver-class-name: com.mysql.cj.jdbc.Driver

mybatis-plus:
  mapper-locations: classpath:/mapper/**/*.xml
  # 配置自增主键 
  global-config:
    db-config:
      id-type: auto
</code></pre>
<p>注意本项目以后使用的是spring security保证安全，所以不需要renren开源项目中的部分文件，按需添加。最终的mall-common目录如下<br>
<img src="https://dxone1.github.io//post-images/1635921702816.png" alt="" loading="lazy"><br>
在test中使用单元测试，注意匹配jdk版本。同时注意springboot和springcloud版本的匹配。本项目是</p>
<pre><code class="language-yaml">springboot: 2.1.8.RELEASE
springcloud: Greenwich.SR3
</code></pre>
<p>接下来，按照上述步骤逆向生成除mall-product之外其他所有的微服务的代码，并调试。</p>
<h3 id="代码生成器的配置以mall-coupon为例">代码生成器的配置：以mall-coupon为例</h3>
<ol>
<li>首先在generator.properties中设置项目层级目录的相关信息</li>
</ol>
<pre><code class="language-properties">#\u4EE3\u7801\u751F\u6210\u5668\uFF0C\u914D\u7F6E\u4FE1\u606F

mainPath=com.dong
#\u5305\u540D
package=com.dong.mall
moduleName=coupon
#\u4F5C\u8005
author=dong
#Email
email=dongjiyu111@126.com
#\u8868\u524D\u7F00(\u7C7B\u540D\u4E0D\u4F1A\u5305\u542B\u8868\u524D\u7F00)
tablePrefix=sms_

#\u7C7B\u578B\u8F6C\u6362\uFF0C\u914D\u7F6E\u4FE1\u606F
tinyint=Integer
smallint=Integer
mediumint=Integer
int=Integer
integer=Integer
bigint=Long
float=Float
double=Double
decimal=BigDecimal
bit=Boolean

char=String
varchar=String
tinytext=String
text=String
mediumtext=String
longtext=String


date=Date
datetime=Date
timestamp=Date

NUMBER=Integer
INT=Integer
INTEGER=Integer
BINARY_INTEGER=Integer
LONG=String
FLOAT=Float
BINARY_FLOAT=Float
DOUBLE=Double
BINARY_DOUBLE=Double
DECIMAL=BigDecimal
CHAR=String
VARCHAR=String
VARCHAR2=String
NVARCHAR=String
NVARCHAR2=String
CLOB=String
BLOB=String
DATE=Date
DATETIME=Date
TIMESTAMP=Date
TIMESTAMP(6)=Date

int8=Long
int4=Integer
int2=Integer
numeric=BigDecimal

nvarchar=String
</code></pre>
<ol start="2">
<li>在application.yml中配置数据源信息，coupon逆向生成的表存在于mall_sms数据库中</li>
</ol>
<pre><code class="language-yaml">server:
  port: 80

# mysql
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    #MySQL配置
    driverClassName: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://192.168.180.3:3306/mall_sms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
    username: root
    password: root
    #oracle配置
    #    driverClassName: oracle.jdbc.OracleDriver
    #    url: jdbc:oracle:thin:@47.100.206.162:1521:xe
    #    username: renren
    #    password: 123456
    #SQLServer配置
    #    driverClassName: com.microsoft.sqlserver.jdbc.SQLServerDriver
    #    url: jdbc:sqlserver://192.168.10.10:1433;DatabaseName=renren_fast
    #    username: sa
    #    password: 123456
    #PostgreSQL配置
  #    driverClassName: org.postgresql.Driver
  #    url: jdbc:postgresql://192.168.10.10:5432/renren_fast
  #    username: postgres
  #    password: 123456



  jackson:
    time-zone: GMT+8
    date-format: yyyy-MM-dd HH:mm:ss
  resources:
    static-locations: classpath:/static/,classpath:/views/

#mongodb:
#  host: localhost
#  port: 27017
#  auth: false #是否使用密码验证
#  username: tincery
#  password: renren
#  source: 123456
#  database: test

mybatis-plus:
  mapperLocations: classpath:mapper/**/*.xml


pagehelper:
  reasonable: true
  supportMethodsArguments: true
  params: count=countSql


#指定数据库，可选值有【mysql、oracle、sqlserver、postgresql、mongodb】
renren:
  database: mysql
</code></pre>
<ol start="3">
<li>引入公共依赖</li>
<li>写application.yml文件</li>
</ol>
<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.180.3:3306/mall_sms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
    driver-class-name: com.mysql.cj.jdbc.Driver

mybatis-plus:
  mapper-locations: classpath:/mapper/**/*.xml
  # 配置自增主键
  global-config:
    db-config:
      id-type: auto
</code></pre>
<ol start="5">
<li>配置包扫描</li>
</ol>
<pre><code class="language-java">@MapperScan(&quot;com.dong.mall.product.dao&quot;)
@SpringBootApplication
public class MallCouponApplication {

    public static void main(String[] args) {
        SpringApplication.run(MallCouponApplication.class, args);
    }

}
</code></pre>
<ol start="6">
<li>test中junit重新导入包</li>
<li>测试完成<br>
<img src="https://dxone1.github.io//post-images/1635925644636.png" alt="" loading="lazy"></li>
</ol>
<h3 id="项目的端口分配">项目的端口分配</h3>
<pre><code class="language-yaml">mall-coupon: 7000
mall-member: 8000
mall-order: 9000
mall-product: 10000
mall-ware: 11000
</code></pre>
<p>重要的细心的耐心，按照步骤一步步即可完成。通过这个脚手架工程和代码生成器可以快速完成基本的crud搭建，快速进入下一阶段的业务编写和云配置部分。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[电商项目 day0：环境配置]]></title>
        <id>https://dxone1.github.io/post/dian-shang-xiang-mu-day0/</id>
        <link href="https://dxone1.github.io/post/dian-shang-xiang-mu-day0/">
        </link>
        <updated>2021-11-01T07:01:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-项目的总体架构">1 项目的总体架构</h2>
<p><img src="https://dxone1.github.io//post-images/1635752087534.jpg" alt="" loading="lazy"><br>
总体上会使用SpringcloudAlibaba和SpringCloud体系的其他组件完成整个微服务体系。</p>
<h2 id="2-linux环境搭建">2 Linux环境搭建</h2>
<h3 id="1-配置静态ip">1 配置静态IP</h3>
<p>这里提一下Vmware + Centos7的静态ip配置</p>
<ol>
<li>首先在Vmware上设置NAT桥接模式，禁用本地DHCP服务。设置一个子网IP，并将网关设置为统一网段中的地址</li>
<li>设置适配器VMware Network Adapter VMnet8的IPV4属性。将IP地址设置在同一个网段中，网关与上面的保持一致。设置首选DNS服务器为114.114.114.114，备用为223.5.5.5阿里云解析</li>
<li>修改配置文件<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></li>
</ol>
<pre><code class="language-vim">TYPE=&quot;Ethernet&quot;
PROXY_METHOD=&quot;none&quot;
BROWSER_ONLY=&quot;no&quot;
BOOTPROTO=&quot;static&quot;
DEFROUTE=&quot;yes&quot;
IPV4_FAILURE_FATAL=&quot;no&quot;
IPV6INIT=&quot;yes&quot;
IPV6_AUTOCONF=&quot;yes&quot;
IPV6_DEFROUTE=&quot;yes&quot;
IPV6_FAILURE_FATAL=&quot;no&quot;
IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;
NAME=&quot;ens33&quot;
UUID=&quot;012d6c4a-d6ac-45e3-ac99-80797072e5f7&quot;
DEVICE=&quot;ens33&quot;
ONBOOT=&quot;yes&quot;
IPADDR=192.168.180.3  #IP地址
GATEWAY=192.168.180.2  #网关
NETMASK=255.255.255.0  
DNS1=&quot;114.114.114.114&quot;
DNS2=&quot;223.5.5.5&quot;
</code></pre>
<h3 id="2-docker环境">2 Docker环境</h3>
<p>之前已经搭建完成Linux + Docker环境，这里下载开发所需的msyql和redis数据库镜像。首先使用<code>dcoker rmi -f $(docker images -qa)</code>删除所有本地已有的镜像，防止冲突。</p>
<h4 id="1-mysql">1 Mysql</h4>
<p>安装版本版本如下</p>
<pre><code class="language-txt">mysql:5.7
</code></pre>
<p>启动docker的mysql环境使用以下命令，这都是docker基础不再赘述。大体意思是后台启动并映射端口为3306 -&gt; 3306。同时添加数据卷用于共享文件，并设定root的密码</p>
<pre><code class="language-dockerfile">docker run -p 3306:3306 --name mysql 
-v /mydata/mysql/log:/var/log/mysql 
-v /mydata/mysql/data:/var/lib/mysql 
-v /mydata/mysql/conf:/etc/mysql 
-e MYSQL_ROOT_PASSWORD=root -d mysql:5.7
</code></pre>
<p>可以通过访问虚拟机的Linux端口映射访问到Container的Mysql服务<br>
<img src="https://dxone1.github.io//post-images/1635755403050.png" alt="" loading="lazy"><br>
验证：在container中建立一个数据库，并在其中测试建一张表，看外部访问是否成功。<br>
<img src="https://dxone1.github.io//post-images/1635756022893.png" alt="" loading="lazy"><br>
<img src="https://dxone1.github.io//post-images/1635756028396.png" alt="" loading="lazy"></p>
<p>接下来修改Mysql的配置文件</p>
<pre><code class="language-conf">[client]
default-character-set=utf8

[mysql]
default-character-set=utf8

[mysqld]
init_connect='SET collation_connection = utf8_unicode_ci'
init_connect='SET NAMES utf8'
character-set-server=utf8
collation-server=utf8_unicode_ci
skip-character-set-client-handshake
skip-name-resolve
</code></pre>
<h4 id="2-redis">2 Redis</h4>
<p>直接pull最新版本的redis，先创建实例</p>
<pre><code class="language-txt">mkdir -p /mydata/redis/conf
touch /mydata/redis/conf/redis.conf
</code></pre>
<p>启动命令如下：</p>
<pre><code class="language-dockerfile">docker run -p 6379:6379 --name redis \
-v /mydata/redis/data:/data \
-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \
-d redis redis-server /etc/redis/redis.conf
</code></pre>
<p>##测试Redis##<br>
<img src="https://dxone1.github.io//post-images/1635757265978.png" alt="" loading="lazy"></p>
<p>注意：新版本的redis会默认持久化，旧版本的则需要修改配置文件<code>/mydata/redis/conf/redis.conf</code></p>
<pre><code class="language-txt">appendonly yes
</code></pre>
<p>启用Redis AOF持久化模式</p>
<h2 id="2-开发环境">2 开发环境</h2>
<p>清单</p>
<pre><code class="language-txt">jdk1.8.0_291
Apache Maven 3.5.2
vsode 大量前端插件
</code></pre>
<p>使用gitee进行项目版本控制。注意现在网络流传的ssh公钥设置往往存在问题，通过查找官网成功配置：https://gitee.com/help/articles/4181#article-header0<br>
<img src="https://dxone1.github.io//post-images/1635765496610.png" alt="" loading="lazy"><br>
在gitee上创建一个仓库：https://gitee.com/dxone/mall.git<br>
在idea中使用git版本控制新建项目，并组织项目结构</p>
<ol>
<li>使用Spring Initializer搭建项目，使用Springboot 2.1.8RELEASE版本，搭建如下项目Module</li>
</ol>
<pre><code class="language-txt">mall-coupon
mall-member
mall-order
mall-product
mall-ware
</code></pre>
<ol start="2">
<li>在项目最外层以pom形式打包，聚合整个mvn工程</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.dong.mall&lt;/groupId&gt;
    &lt;artifactId&gt;mall&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;mall&lt;/name&gt;
    &lt;description&gt;聚合服务&lt;/description&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;

    &lt;modules&gt;
        &lt;module&gt;mall-coupon&lt;/module&gt;
        &lt;module&gt;mall-member&lt;/module&gt;
        &lt;module&gt;mall-order&lt;/module&gt;
        &lt;module&gt;mall-product&lt;/module&gt;
        &lt;module&gt;mall-ware&lt;/module&gt;
    &lt;/modules&gt;
&lt;/project&gt;
</code></pre>
<p><img src="https://dxone1.github.io//post-images/1635771275051.png" alt="" loading="lazy"><br>
commit并push到gitee项目仓库<br>
<img src="https://dxone1.github.io//post-images/1635771426712.png" alt="" loading="lazy"></p>
<h2 id="3-数据库设计">3 数据库设计</h2>
<p>根据模块分库分表，sql语句已提供。建库建表后结果如图<br>
<img src="https://dxone1.github.io//post-images/1635773709958.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>